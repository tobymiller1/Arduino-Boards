<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Kaleidoscope: libraries/Kaleidoscope/doc/CODING_STYLE.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Kaleidoscope
   </div>
   <div id="projectbrief">Customizable firmware for keyboards</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">libraries/Kaleidoscope/doc/CODING_STYLE.md</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;!-- -*- mode: markdown; fill-column: 8192 -*- --&gt;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;# Kaleidoscope C++ Coding Style</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="preprocessor">## Important warning</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;This document is currently a work in progress. While you certainly won<span class="stringliteral">&#39;t be penalized for following the style described herein, it&#39;</span>s still a moving target as of June 20, 2017.</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;Our style guide is based on the [Google C++ style guide][goog:c++-guide] which was current as of June 2, 2017, but has been modified to better reflect the constraints of embedded development and the peculiarities of an Arduino-compatible environment.</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160; [goog:c++-guide]: https:<span class="comment">//google.github.io/styleguide/cppguide.html</span></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="preprocessor">## Table of Contents</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;* [Background](#background)</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    * [Goals of the Style Guide](#goals-of-the-style-guide)</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;* [Library Guidelines](#library-guidelines)</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;* [Header Files](#header-files)</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    * [Self-contained Headers](#<span class="keyword">self</span>-contained-headers)</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    * [Header Guards](#header-guards)</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    * [Forward Declarations](#forward-declarations)</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    * [Inline Functions](#<span class="keyword">inline</span>-functions)</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    * [Names and Order of Includes](#names-and-order-of-includes)</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;* [Scoping](#scoping)</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    * [Namespaces](#namespaces)</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    * [Unnamed Namespaces and Static Variables](#unnamed-namespaces-and-<span class="keyword">static</span>-variables)</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    * [Nonmember, Static Member, and Global Functions](#nonmember-<span class="keyword">static</span>-member-and-global-functions)</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    * [Local Variables](#local-variables)</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    * [Static and Global Variables](#<span class="keyword">static</span>-and-global-variables)</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;* [Classes](#classes)</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    * [Doing Work in Constructors](#doing-work-in-constructors)</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    * [Implicit Conversions](#implicit-conversions)</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    * [Copyable and Movable Types](#copyable-and-movable-types)</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    * [Structs vs. Classes](#structs-vs-classes)</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    * [Inheritance](#inheritance)</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    * [Multiple Inheritance](#multiple-inheritance)</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    * [Interfaces](#interfaces)</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    * [Operator Overloading](#<span class="keyword">operator</span>-overloading)</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    * [Access Control](#access-control)</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    * [Declaration Order](#declaration-order)</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;* [Functions](#functions)</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    * [Parameter Ordering](#parameter-ordering)</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    * [Write Short Functions](#write-<span class="keywordtype">short</span>-functions)</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    * [Reference Arguments](#reference-arguments)</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    * [Function Overloading](#<span class="keyword">function</span>-overloading)</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    * [Default Arguments](#<span class="keywordflow">default</span>-arguments)</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    * [Trailing Return Type Syntax](#trailing-<span class="keywordflow">return</span>-type-syntax)</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;* [Google-specific magic](#google-specific-magic)</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    * [Ownership and Smart Pointers](#ownership-and-smart-pointers)</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    * [cpplint](#cpplint)</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;* [Other C++ Features](#other-c-features)</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    * [Rvalue References](#rvalue-references)</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    * [Friends](#friends)</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    * [Exceptions](#exceptions)</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    * [Run-Time Type Information (RTTI)](#run-time-type-information-rtti)</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    * [Casting](#casting)</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    * [Streams](#streams)</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    * [Preincrement and Predecrement](#preincrement-and-predecrement)</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    * [Use of <span class="keyword">const</span>](#use-of-<span class="keyword">const</span>)</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        * [Where to put the <span class="keyword">const</span>](#where-to-put-the-<span class="keyword">const</span>)</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    * [Use of constexpr](#use-of-constexpr)</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    * [Integer Types](#integer-types)</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        * [On Unsigned Integers](#on-<span class="keywordtype">unsigned</span>-integers)</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    * [Preprocessor Macros](#preprocessor-macros)</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    * [0 and <span class="keyword">nullptr</span>/NULL](#0-and-nullptrnull)</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    * [<span class="keyword">sizeof</span>](#<span class="keyword">sizeof</span>)</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    * [<span class="keyword">auto</span>](#<span class="keyword">auto</span>)</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    * [Braced Initializer List](#braced-initializer-list)</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    * [Lambda expressions](#lambda-expressions)</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    * [Template metaprogramming](#<span class="keyword">template</span>-metaprogramming)</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    * [C++11](#c11)</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    * [Nonstandard Extensions](#nonstandard-extensions)</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    * [Aliases](#aliases)</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;* [Naming](#naming)</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    * [General Naming Rules](#general-naming-rules)</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    * [File Names](#file-names)</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    * [Type Names](#type-names)</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    * [Variable Names](#variable-names)</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        * [Common Variable Names](#common-variable-names)</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        * [Class Data Members](#<span class="keyword">class</span>-data-members)</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        * [Struct Data Members](#<span class="keyword">struct</span>-data-members)</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    * [Constant Names](#constant-names)</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    * [Function Names](#<span class="keyword">function</span>-names)</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    * [Namespace Names](#<span class="keyword">namespace</span>-names)</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    * [Enumerator Names](#enumerator-names)</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    * [Macro Names](#macro-names)</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    * [Exceptions to Naming Rules](#exceptions-to-naming-rules)</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;* [Comments](#comments)</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    * [Comment Style](#comment-style)</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    * [File Comments](#file-comments)</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        * [Legal Notice and Author Line](#legal-notice-and-author-line)</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;        * [File Contents](#file-contents)</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    * [Class Comments](#<span class="keyword">class</span>-comments)</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    * [Function Comments](#<span class="keyword">function</span>-comments)</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;        * [Function Declarations](#<span class="keyword">function</span>-declarations)</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;        * [Function Definitions](#<span class="keyword">function</span>-definitions)</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    * [Variable Comments](#variable-comments)</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;        * [Class Data Member Comments](#<span class="keyword">class</span>-data-member-comments)</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        * [Global Variable Comments](#global-variable-comments)</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    * [Implementation Comments](#implementation-comments)</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        * [Explanatory Comments](#explanatory-comments)</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        * [Line Comments](#line-comments)</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    * [Function Argument Comments](#<span class="keyword">function</span>-argument-comments)</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    * [Dont<span class="stringliteral">&#39;s](#donts)</span></div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;<span class="stringliteral">    * [Punctuation, Spelling and Grammar](#punctuation-spelling-and-grammar)</span></div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;<span class="stringliteral">    * [TODO Comments](#todo-comments)</span></div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;<span class="stringliteral">    * [Deprecation Comments](#deprecation-comments)</span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;<span class="stringliteral">* [Formatting](#formatting)</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="stringliteral">    * [Line Length](#line-length)</span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="stringliteral">    * [Non-ASCII Characters](#non-ascii-characters)</span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="stringliteral">    * [Spaces vs. Tabs](#spaces-vs-tabs)</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="stringliteral">    * [Function Declarations and Definitions](#function-declarations-and-definitions)</span></div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="stringliteral">    * [Formatting Lambda Expressions](#formatting-lambda-expressions)</span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="stringliteral">    * [Function Calls](#function-calls)</span></div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="stringliteral">    * [Braced Initializer List Format](#braced-initializer-list-format)</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="stringliteral">    * [Conditionals](#conditionals)</span></div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="stringliteral">    * [Loops and Switch Statements](#loops-and-switch-statements)</span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="stringliteral">    * [Pointer and Reference Expressions](#pointer-and-reference-expressions)</span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="stringliteral">    * [Boolean Expressions](#boolean-expressions)</span></div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="stringliteral">    * [Return Values](#return-values)</span></div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="stringliteral">    * [Variable and Array Initialization](#variable-and-array-initialization)</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="stringliteral">    * [Preprocessor Directives](#preprocessor-directives)</span></div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;<span class="stringliteral">    * [Class Format](#class-format)</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="stringliteral">    * [Constructor Initializer Lists](#constructor-initializer-lists)</span></div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;<span class="stringliteral">    * [Namespace Formatting](#namespace-formatting)</span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="stringliteral">    * [Horizontal Whitespace](#horizontal-whitespace)</span></div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="stringliteral">        * [General](#general)</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="stringliteral">        * [Loops and Conditionals](#loops-and-conditionals)</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="stringliteral">        * [Operators](#operators)</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="stringliteral">        * [Templates and Casts](#templates-and-casts)</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="stringliteral">    * [Vertical Whitespace](#vertical-whitespace)</span></div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="stringliteral">* [Exceptions to the Rules](#exceptions-to-the-rules)</span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;<span class="stringliteral">    * [Existing Non-conformant Code](#existing-non-conformant-code)</span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="stringliteral">* [Parting Words](#parting-words)</span></div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;<span class="stringliteral">## Background</span></div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;<span class="stringliteral">&lt;!-- TODO: Review this section, the Google-specifc wording was replaced with something more appropriate --&gt;</span></div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;<span class="stringliteral">C++ is the language of Arduino libraries, and as a consequence, in which Kaleidoscope was written in. As every C++ programmer knows, the language has many powerful features, but this power brings with it complexity, which in turn can make code more bug-prone and harder to read and maintain.</span></div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;<span class="stringliteral">The goal of this guide is to manage this complexity by describing in detail the dos and don&#39;</span>ts of writing C++ code. These rules exist to keep the code base manageable <span class="keywordflow">while</span> still allowing coders to use C++ language features productively.</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;*Style*, also known as readability, is what we call the conventions that govern our C++ code. The term Style is a bit of a misnomer, since these conventions cover far more than just source file formatting.</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;Note that <span class="keyword">this</span> guide is not a C++ tutorial: we assume that the reader is familiar with the language.</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;### Goals of the Style Guide</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;&gt; Why <span class="keywordflow">do</span> we have <span class="keyword">this</span> document?</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;There are a few core goals that we believe <span class="keyword">this</span> guide should serve. These are the fundamental **why**s that underlie all of the individual rules. By bringing these ideas to the fore, we hope to ground discussions and make it clearer to our broader community why the rules are in place and why particular decisions have been made. If you understand what goals each rule is serving, it should be clearer to everyone when a rule may be waived (some can be), and what sort of argument or alternative would be necessary to change a rule in the guide.</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;The goals of the style guide as we currently see them are as follows:</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;&lt;dl&gt;</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;&lt;dt&gt;Style rules should pull their weight&lt;/dt&gt;</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;&lt;dd&gt;</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;The benefit of a style rule must be large enough to justify asking all of our engineers to remember it. The benefit is measured relative to the codebase we would <span class="keyword">get</span> without the rule, so a rule against a very harmful practice may still have a small benefit <span class="keywordflow">if</span> people are unlikely to <span class="keywordflow">do</span> it anyway. This principle mostly explains the rules we don<span class="stringliteral">&#39;t have, rather than the rules we do: for example, `goto` contravenes many of the following principles, but is already vanishingly rare, so the Style Guide doesn&#39;</span>t discuss it.</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;&lt;/dd&gt;</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;&lt;!-- TODO: Review the Kaleidoscope/Arduino bits --&gt;</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;&lt;dt&gt;Optimize <span class="keywordflow">for</span> the reader, not the writer&lt;/dt&gt;</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;&lt;dd&gt;</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;Our codebase (and most individual components submitted to it) is expected to <span class="keywordflow">continue</span> <span class="keywordflow">for</span> quite some time. As a result, more time will be spent reading most of our code than writing it. We explicitly choose to optimize <span class="keywordflow">for</span> the experience of our average software engineer reading, maintaining, and debugging code in our codebase rather than ease when writing said code. &lt;em&gt;<span class="stringliteral">&quot;Leave a trace for the reader&quot;</span>&lt;/em&gt; is a particularly common sub-point of <span class="keyword">this</span> principle: When something surprising or unusual is happening in a snippet of code (<span class="keywordflow">for</span> example, transfer of pointer ownership), leaving textual hints <span class="keywordflow">for</span> the reader at the point of use is valuable (&lt;code&gt;std::unique_ptr&lt;/code&gt; demonstrates the ownership transfer unambiguously at the call site). This is doubly <span class="keyword">true</span> <span class="keywordflow">for</span> libraries meant to be used by end-users, where the target audience is not software engineers, but novice users of the Arduino ecosystem. People <span class="keywordflow">for</span> whom their Sketch may be the first program they ever write.</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;&lt;/dd&gt;</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;&lt;dt&gt;Be consistent with existing code&lt;/dt&gt;</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;&lt;dd&gt;</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;Using one style consistently through our codebase lets us focus on other (more important) issues. Consistency also allows <span class="keywordflow">for</span> automation: tools that format your code or adjust your &lt;code&gt;#include&lt;/code&gt;s only work properly when your code is consistent with the expectations of the tooling. In many cases, rules that are attributed to &lt;em&gt;<span class="stringliteral">&quot;Be Consistent&quot;</span>&lt;/em&gt; boil down to &lt;em&gt;<span class="stringliteral">&quot;Just pick one and stop worrying about it&quot;</span>&lt;/em&gt;; the potential value of allowing flexibility on these points is outweighed by the cost of having people argue over them.</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;&lt;/dd&gt;</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;&lt;!-- TODO: Review the Kaleidoscope/Arduino bits --&gt;</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;&lt;dt&gt;Be consistent with the broader Arduino community when appropriate&lt;/dt&gt;</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;&lt;dd&gt;</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;Consistency with the way other Arduino libraries use C++ has value <span class="keywordflow">for</span> the same reasons as consistency within our code base. Our libraries <span class="keywordflow">do</span> not <span class="keyword">function</span> in isolation, and they may very well be used together with libraries by the broader Arduino community. However, sometimes the idioms, or style used in other libraries <span class="keywordflow">do</span> not fit the needs of our codebase. In those cases, it is appropriate to apply our own rules. Similarly, <span class="keywordflow">if</span> a feature in the C++ standard solves a problem, or <span class="keywordflow">if</span> some idiom is widely known and accepted, that<span class="stringliteral">&#39;s an argument for using it. However, sometimes standard features and idioms are flawed, or were just designed without our codebase&#39;</span>s needs in mind. In those cases (as described below) it<span class="stringliteral">&#39;s appropriate to constrain or ban standard features.</span></div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;<span class="stringliteral">&lt;/dd&gt;</span></div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;<span class="stringliteral">&lt;dt&gt;Avoid surprising or dangerous constructs&lt;/dt&gt;</span></div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;<span class="stringliteral">&lt;dd&gt;</span></div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;<span class="stringliteral">C++ has features that are more surprising or dangerous than one might think at a glance. Some style guide restrictions are in place to prevent falling into these pitfalls. There is a high bar for style guide waivers on such restrictions, because waiving such rules often directly risks compromising program correctness.</span></div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;<span class="stringliteral">&lt;/dd&gt;</span></div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;<span class="stringliteral">&lt;!-- TODO: Review the wording: changed to mention that our target are not necessarily programmers. --&gt;</span></div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;<span class="stringliteral">&lt;dt&gt;Avoid constructs that our average C++ programmer would find tricky or hard to maintain&lt;/dt&gt;</span></div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;<span class="stringliteral">&lt;dd&gt;</span></div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="stringliteral">C++ has features that may not be generally appropriate because of the complexity they introduce to the code. In widely used code, it may be more acceptable to use trickier language constructs, because any benefits of more complex implementation are multiplied widely by usage, and the cost in understanding the complexity does not need to be paid again when working with new portions of the codebase. When in doubt, waivers to rules of this type can be sought by asking your project leads. This is specifically important for our codebase because code ownership and team membership changes over time: even if everyone that works with some piece of code currently understands it, such understanding is not guaranteed to hold a few years from now. Not to mention that our target audience are average people, not average C++ programmers.</span></div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;<span class="stringliteral">&lt;/dd&gt;</span></div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;<span class="stringliteral">&lt;!-- TODO: Un-googlified... --&gt;</span></div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;<span class="stringliteral">&lt;dt&gt;Be mindful of our scale&lt;/dt&gt;</span></div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;<span class="stringliteral">&lt;dd&gt;</span></div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;<span class="stringliteral">With a codebase spanning many plugins, and even more when we consider the broader Arduino ecosystem, some mistakes and simplifications for one engineer can become costly for many. For instance it&#39;</span>s particularly important to avoid polluting the global <span class="keyword">namespace</span>: name collisions across a codebase of dozens of repositories are difficult to work with and hard to avoid <span class="keywordflow">if</span> everyone puts things into the global <span class="keyword">namespace</span>.</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;&lt;/dd&gt;</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;&lt;dt&gt;Concede to optimization when necessary&lt;/dt&gt;</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;&lt;dd&gt;</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;Performance optimizations can sometimes be necessary and appropriate, even when they conflict with the other principles of <span class="keyword">this</span> document.&lt;/dd&gt;</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;&lt;/dl&gt;</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;The intent of <span class="keyword">this</span> document is to provide maximal guidance with reasonable restriction. As always, common sense and good taste should prevail. By <span class="keyword">this</span> we specifically refer to the established conventions of the entire community (both Kaleidoscope and Arduino communities), not just your personal preferences or those of your team. Be skeptical about and reluctant to use clever or unusual constructs: the absence of a prohibition is not the same as a license to proceed. Use your judgment, and <span class="keywordflow">if</span> you are unsure, please don<span class="stringliteral">&#39;t hesitate to ask, to get additional input.</span></div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;<span class="stringliteral">## Library Guidelines</span></div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;<span class="stringliteral">&lt;!-- TODO: This is a whole new section! --&gt;</span></div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;<span class="stringliteral">Before looking at the coding style guidelines, we must first talk about libraries. Every Kaleidoscope plugin is also an Arduino library. The core firmware is an Arduino library too. As such, libraries should follow the [Arduino library specification][arduino:library-spec] (revision 2.1 or later), with a few additional recommendations:</span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;<span class="stringliteral"> [arduino:library-spec]: https://github.com/arduino/Arduino/wiki/Arduino-IDE-1.5:-Library-specification</span></div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;<span class="stringliteral">&lt;dl&gt;</span></div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;<span class="stringliteral">&lt;dt&gt;Use Semantic Versioning for versioning&lt;/dt&gt;</span></div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;<span class="stringliteral">&lt;dd&gt;</span></div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;<span class="stringliteral">We want to make it as easy for the consumers of the plugins to use them as possible. A big part of this is updating to a newer version of it. Using &lt;a href=&quot;http://semver.org&quot;&gt;semantic versioning&lt;/a&gt; makes it easier for our users to keep up with the libraries.</span></div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;<span class="stringliteral">&lt;/dd&gt;</span></div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;<span class="stringliteral">&lt;dt&gt;Have an example for the library&lt;/dt&gt;</span></div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;<span class="stringliteral">&lt;dd&gt;</span></div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;<span class="stringliteral">It does not matter much what hardware the example is for, as long as there is one. Because the Arduino IDE will offer examples, having one is of great benefit: it is a starting point. An easily accessible starting point.</span></div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;<span class="stringliteral">&lt;/dd&gt;</span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;<span class="stringliteral">&lt;dt&gt;Be mindful of the documentation&lt;/dt&gt;</span></div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;<span class="stringliteral">&lt;dd&gt;</span></div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;<span class="stringliteral">Documenting the interfaces of the library, how to use it, its dependencies, in a way that is meaningful for a novice user is a very strong recommendation. The `README.md` in a library should target a novice audience. Would one want or need to document parts of the code that is only meaningful for more advanced programmers, do so in the code.</span></div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;<span class="stringliteral">&lt;/dd&gt;</span></div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;<span class="stringliteral">&lt;dt&gt;Use the tools provided in Kaleidoscope-Plugin&lt;/dt&gt;</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="stringliteral">&lt;dd&gt;</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;<span class="stringliteral">The &lt;a href=&quot;https://github.com/keyboardio/Kaleidoscope-Plugin&quot;&gt;Kaleidoscope-Plugin&lt;/a&gt; repository is there to aid plugin and library developers. Use the tools it provides. They make everyone&#39;</span>s life easier, and help maintain consistency across the board.</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;&lt;/dd&gt;</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;&lt;/dl&gt;</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;<span class="preprocessor">## Header Files</span></div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;In general, every `.cpp` file should have an associated `.h` file. There are some common exceptions, such as unittests and examples.</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;Correct use of header files can make a huge difference to the readability, size and performance of your code.</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;The following rules will guide you through the various pitfalls of <span class="keyword">using</span> header files.</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;### Self-contained Headers</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;&gt; Header files should be <span class="keyword">self</span>-contained (compile on their own) and end in `.h`. Non-header files that are meant <span class="keywordflow">for</span> inclusion should end in `.inc` and be used sparingly.</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;All header files should be <span class="keyword">self</span>-contained. Users and refactoring tools should not have to adhere to special conditions to include the header. Specifically, a header should have [header guards](#header-guards) and include all other headers it needs.</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;Prefer placing the definitions <span class="keywordflow">for</span> <span class="keyword">template</span> and <span class="keyword">inline</span> functions in the same file as their declarations. The definitions of these constructs must be included into every `.cpp` file that uses them, or the program may fail to link in some build configurations. If declarations and definitions are in different files, including the former should transitively include the latter. Do not move these definitions to separately included header files (`-inl.h`).</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;As an exception, a <span class="keyword">template</span> that is explicitly instantiated <span class="keywordflow">for</span> all relevant sets of <span class="keyword">template</span> arguments, or that is a <span class="keyword">private</span> implementation detail of a <span class="keyword">class</span>, is allowed to be defined in the one and only `.cpp` file that instantiates the <span class="keyword">template</span>.</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;There are rare cases where a file designed to be included is not <span class="keyword">self</span>-contained. These are typically intended to be included at unusual locations, such as the middle of another file. They might not use [header guards](#header-guards), and might not include their prerequisites. Name such files with the `.inc` extension. Use sparingly, and prefer <span class="keyword">self</span>-contained headers when possible.</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;### Header Guards</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;All header files should have `#pragma once` guards at the top to prevent multiple inclusion.</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;### Forward Declarations</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;&gt; Avoid <span class="keyword">using</span> forward declarations where possible. Just `#include` the headers you need.</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;**Definition**</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;A *<span class="stringliteral">&quot;forward declaration&quot;</span>* is a declaration of a <span class="keyword">class</span>, <span class="keyword">function</span>, or <span class="keyword">template</span> without an associated definition.</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;**Pros**</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;* Forward declarations can save compile time, as `#include`s force the compiler to open more files and process more input.</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;* Forward declarations can save on unnecessary recompilation. `#include`s can force your code to be recompiled more often, due to unrelated changes in the header.</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;**Cons**</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;* Forward declarations can hide a dependency, allowing user code to skip necessary recompilation when headers change.</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;* A forward declaration may be broken by subsequent changes to the library. Forward declarations of functions and templates can prevent the header owners from making otherwise-compatible changes to their APIs, such as widening a parameter type, adding a <span class="keyword">template</span> parameter with a <span class="keywordflow">default</span> value, or migrating to a <span class="keyword">new</span> <span class="keyword">namespace</span>.</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;* It can be difficult to determine whether a forward declaration or a full `#include` is needed. Replacing an `#include` with a forward declaration can silently change the meaning of code.</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;* Forward declaring multiple symbols from a header can be more verbose than simply `#include`ing the header.</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;* Structuring code to enable forward declarations (e.g. <span class="keyword">using</span> pointer members instead of <span class="keywordtype">object</span> members) can make the code slower and more complex.</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;**Decision**</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;* Try to avoid forward declarations of entities defined in another project.</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;* When <span class="keyword">using</span> a <span class="keyword">function</span> declared in a header file, always `#include` that header.</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;* When <span class="keyword">using</span> a <span class="keyword">class </span><span class="keyword">template</span>, prefer to `#include` its header file.</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;Please see [Names and Order of Includes](#names-and-order-of-includes) <span class="keywordflow">for</span> rules about when to #include a header.</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;### Inline Functions</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;&gt; Define <span class="keyword">inline</span> functions when required to <span class="keywordflow">do</span> so in order to <span class="keyword">get</span> the compiler to generate more compact code.</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;**Definition**</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;You can declare functions in a way that allows the compiler to expand them <span class="keyword">inline</span> rather than calling them through the usual <span class="keyword">function</span> call mechanism. Sometimes the compiler does <span class="keyword">this</span> automatically, sometimes we need to instruct it explicitly <span class="keywordflow">for</span> the sake of either performance, or code size.</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;**Pros**</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;Inlining a <span class="keyword">function</span> can generate more efficient <span class="keywordtype">object</span> code, as <span class="keywordtype">long</span> as the inlined <span class="keyword">function</span> is small. Feel free to <span class="keyword">inline</span> accessors and mutators, and other <span class="keywordtype">short</span>, performance-critical functions.</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;**Cons**</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;Overuse of inlining can actually make programs slower. Depending on a <span class="keyword">function</span><span class="stringliteral">&#39;s size, inlining it can cause the code size to increase or decrease. Inlining a very small accessor function will usually decrease code size while inlining a very large function can dramatically increase code size.</span></div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;<span class="stringliteral">**Decision**</span></div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;<span class="stringliteral">A decent rule of thumb is to not inline a function if it is more than 10 lines long. Beware of destructors, which are often longer than they appear because of implicit member- and base-destructor calls!</span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;<span class="stringliteral">Another useful rule of thumb: it&#39;</span>s typically not cost effective to <span class="keyword">inline</span> functions with loops or <span class="keywordflow">switch</span> statements (unless, in the common <span class="keywordflow">case</span>, the loop or <span class="keywordflow">switch</span> statement is never executed).</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;It is important to know that functions are not always inlined even <span class="keywordflow">if</span> they are declared as such; <span class="keywordflow">for</span> example, <span class="keyword">virtual</span> and recursive functions are not normally inlined. Usually recursive functions should not be <span class="keyword">inline</span>. The main reason <span class="keywordflow">for</span> making a <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">inline</span> is to place its definition in the <span class="keyword">class</span>, either <span class="keywordflow">for</span> convenience or to document its behavior, e.g., <span class="keywordflow">for</span> accessors and mutators.</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;### Names and Order of Includes</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;&lt;!-- TODO: This section could be simplified, and clarified, I believe. --&gt;</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;&gt; Use standard order <span class="keywordflow">for</span> readability and to avoid hidden dependencies: Related header, Arduino libraries, other libraries<span class="stringliteral">&#39; `.h`, your project&#39;</span>s `.h`.</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;All libraries must have at least one header in their top-level `src/` directory, to be included without any path components. This is the way Arduino finds libraries, and a limitation we must adhere to. These headers should - in general - include any other headers they may need, so that the consumer of the library only has to include one header. The name of <span class="keyword">this</span> header must be the same as the name of the library.</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;The recommended naming is to prefix the library name with `Kaleidoscope-`.</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;If there is more than one header, they should be listed as descendants of the project<span class="stringliteral">&#39;s source directory without use of UNIX directory shortcuts `.` (the current directory) or `..` (the parent directory), and live in a `Kaleidoscope` subdirectory. For example, if we have a plugin named `Kaleidoscope-Something`, which has an additional header file other than `Kaleidoscope-Something.h`, it should be in `src/Kaleidoscope/Something-Other.h`, and be included as:</span></div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;<span class="stringliteral">#include &quot;Kaleidoscope-Something.h&quot;</span></div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;<span class="stringliteral">#include &quot;Kaleidoscope/Something-Other.h&quot;</span></div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;<span class="stringliteral">Having more than one level of subdirectories is not recommended.</span></div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;<span class="stringliteral">In `dir/foo.cpp` or `dir/foo_test.cc`, whose main purpose is to implement or test the stuff in `dir2/foo2.h`, order your includes as follows:</span></div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;<span class="stringliteral">1. `dir2/foo2.h`</span></div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;<span class="stringliteral">2. Arduino libraries.</span></div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;<span class="stringliteral">3. Other libraries&#39;</span> `.h` files.</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;4. Your project<span class="stringliteral">&#39;s `.h` files.</span></div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;<span class="stringliteral">With the preferred ordering, if `dir2/foo2.h` omits any necessary includes, the build of `dir/foo.cpp` or `dir/foo_test.cpp` will break. Thus, this rule ensures that build breaks show up first for the people working on these files, not for innocent people in other packages.</span></div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;<span class="stringliteral">`dir/foo.cc` and `dir2/foo2.h` are usually in the same directory (e.g. `Kaleidoscope/Something_test.cpp` and `Kaleidoscope/Something.h`), but may sometimes be in different directories too.</span></div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;<span class="stringliteral">Within each section the includes should be ordered alphabetically.</span></div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;<span class="stringliteral">You should include all the headers that define the symbols you rely upon, except in the unusual case of [forward declarations](#forward-declarations) . If you rely on symbols from `bar.h`, don&#39;</span>t count on the fact that you included `foo.h` which (currently) includes `bar.h`: include `bar.h` yourself, unless `foo.h` explicitly demonstrates its intent to provide you the symbols of `bar.h`. However, any includes present in the related header do not need to be included again in the related `cc` (i.e., `foo.cc` can rely on `foo.h`&#39;s includes).</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;For example, the includes in `Kaleidoscope-Something/src/Kaleidoscope/Something.cpp` might look like this:</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;```c++</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;<span class="preprocessor">#include &quot;Kaleidoscope/Something.h&quot;</span></div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;<span class="preprocessor">#include &quot;Arduino.h&quot;</span></div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;<span class="preprocessor">#include &quot;Kaleidoscope-LEDControl.h&quot;</span></div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;<span class="preprocessor">#include &quot;Kaleidoscope-Focus.h&quot;</span></div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;```</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;**Exception**</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;Sometimes, system-specific code needs conditional includes. Such code can put conditional includes after other includes. Of course, keep your system-specific code small and localized. Example:</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;```c++</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;<span class="preprocessor">#include &quot;Kaleidoscope.h&quot;</span></div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;<span class="preprocessor">#if defined(ARDUINO_AVR_MODEL01)</span></div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;<span class="preprocessor"></span><span class="preprocessor">#include &quot;Kaleidoscope/Something-Model01.h&quot;</span></div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;<span class="preprocessor">#if defined(ARDUINO_AVR_SHORTCUT)</span></div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;<span class="preprocessor"></span><span class="preprocessor">#include &quot;Kaleidoscope/Something-Shortcut.h&quot;</span></div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;<span class="preprocessor"></span>```</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;&lt;!-- TODO: Finish converting the rest... --&gt;</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;## Scoping</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;&lt;!-- TODO: Rethink <span class="keyword">this</span> section within the context of Arduino.</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;Suggested changes:</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;- plugins should put their stuff in the `kaleidoscope` <span class="keyword">namespace</span>.</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;- plugins <span class="keywordflow">do</span> not neccessarily need their own namespaces.</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;- plugins should declare an <span class="keyword">extern</span>, non-namespaced <span class="keywordtype">object</span>.</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;- <span class="keyword">remove</span> google-specific stuff, like gflags.</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;- projects =&gt; plugins</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;- <span class="keyword">namespace </span>terminating comments? Do we need those? I don<span class="stringliteral">&#39;t think so.</span></div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;<span class="stringliteral">- no need to mention std. We don&#39;</span>t use std to begin with.</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;--&gt;</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;### Namespaces</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;&gt; With few exceptions, place code in a <span class="keyword">namespace</span>. Namespaces should have unique names based on the project name, and possibly its path. Do not use *<span class="keyword">using</span>-directives* (e.g. `<span class="keyword">using namespace </span>foo`). Do not use <span class="keyword">inline</span> namespaces. For unnamed namespaces, see [Unnamed Namespaces and Static Variables](#unnamed-namespaces-and-<span class="keyword">static</span>-variables).</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;**Definition**</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;Namespaces subdivide the global scope into distinct, named scopes, and so are useful <span class="keywordflow">for</span> preventing name collisions in the global scope.</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;**Pros**</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;Namespaces provide a method <span class="keywordflow">for</span> preventing name conflicts in large programs <span class="keywordflow">while</span> allowing most code to use reasonably <span class="keywordtype">short</span> names.</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;For example, <span class="keywordflow">if</span> two different projects have a <span class="keyword">class </span>`Foo` in the global scope, these symbols may collide at compile time or at runtime. If each project places their code in a <span class="keyword">namespace</span>, `project1::Foo` and `project2::Foo` are now distinct symbols that <span class="keywordflow">do</span> not collide, and code within each project<span class="stringliteral">&#39;s namespace can continue to refer to `Foo` without the prefix.</span></div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;<span class="stringliteral">Inline namespaces automatically place their names in the enclosing scope. Consider the following snippet, for example:</span></div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;<span class="stringliteral">namespace X {</span></div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;<span class="stringliteral">inline namespace Y {</span></div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;<span class="stringliteral">  void foo();</span></div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;<span class="stringliteral">}  // namespace Y</span></div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;<span class="stringliteral">}  // namespace X</span></div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;<span class="stringliteral">The expressions `X::Y::foo()` and `X::foo()` are interchangeable. Inline namespaces are primarily intended for ABI compatibility across versions.</span></div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;<span class="stringliteral">**Cons**</span></div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;<span class="stringliteral">Namespaces can be confusing, because they complicate the mechanics of figuring out what definition a name refers to.</span></div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;<span class="stringliteral">Inline namespaces, in particular, can be confusing because names aren&#39;</span>t actually restricted to the <span class="keyword">namespace </span>where they are declared. They are only useful as part of some larger versioning policy.</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;In some contexts, it<span class="stringliteral">&#39;s necessary to repeatedly refer to symbols by their fully-qualified names. For deeply-nested namespaces, this can add a lot of clutter.</span></div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;<span class="stringliteral">**Decision**</span></div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;<span class="stringliteral">Namespaces should be used as follows:</span></div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;<span class="stringliteral">* Follow the rules on [Namespace Names](#namespace-names).</span></div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;<span class="stringliteral">* Terminate namespaces with comments as shown in the given examples.</span></div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;<span class="stringliteral">* Namespaces wrap the entire source file after includes, &lt;a href=&quot;https://gflags.github.io/gflags/&quot;&gt; gflags&lt;/a&gt; definitions/declarations and forward declarations of classes from other namespaces.</span></div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;<span class="stringliteral">    ```c++</span></div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;<span class="stringliteral">    // In the .h file</span></div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;<span class="stringliteral">    namespace mynamespace {</span></div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;<span class="stringliteral">    // All declarations are within the namespace scope.</span></div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;<span class="stringliteral">    // Notice the lack of indentation.</span></div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;<span class="stringliteral">    class MyClass {</span></div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;<span class="stringliteral">     public:</span></div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;<span class="stringliteral">      ...</span></div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;<span class="stringliteral">      void Foo();</span></div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;<span class="stringliteral">    };</span></div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;<span class="stringliteral">    }  // namespace mynamespace</span></div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;<span class="stringliteral">    ```</span></div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;<span class="stringliteral">    ```c++</span></div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;<span class="stringliteral">    // In the .cc file</span></div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;<span class="stringliteral">    namespace mynamespace {</span></div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;<span class="stringliteral">    // Definition of functions is within scope of the namespace.</span></div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;<span class="stringliteral">    void MyClass::Foo() {</span></div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;<span class="stringliteral">      ...</span></div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;<span class="stringliteral">    }  // namespace mynamespace</span></div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;<span class="stringliteral">    ```</span></div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;<span class="stringliteral">    More complex `.cpp` files might have additional details, like flags or using-declarations.</span></div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;<span class="stringliteral">    ```c++</span></div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;<span class="stringliteral">    #include &quot;a.h&quot;</span></div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;<span class="stringliteral">    DEFINE_FLAG(bool, someflag, false, &quot;dummy flag&quot;);</span></div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;<span class="stringliteral">    namespace a {</span></div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;<span class="stringliteral">    using ::foo::bar;</span></div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;<span class="stringliteral">    ...code for a...         // Code goes against the left margin.</span></div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;<span class="stringliteral">    }  // namespace a</span></div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;<span class="stringliteral">    ```</span></div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;<span class="stringliteral">* Do not declare anything in namespace `std`, including forward declarations of standard library classes. Declaring entities in namespace `std` is undefined behavior, i.e., not portable. To declare entities from the standard library, include the appropriate header file.</span></div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;<span class="stringliteral">* You may not use a `using`-directive to make all names from a namespace available.</span></div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;<span class="stringliteral">    ```c++</span></div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;<span class="stringliteral">    // Forbidden -- This pollutes the namespace.</span></div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;<span class="stringliteral">    using namespace foo;</span></div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;<span class="stringliteral">    ```</span></div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;<span class="stringliteral">* Do not use *Namespace aliases* at namespace scope in header files except in explicitly marked internal-only namespaces, because anything imported into a namespace in a header file becomes part of the public API exported by that file.</span></div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;<span class="stringliteral">    ```c++</span></div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;<span class="stringliteral">    // Shorten access to some commonly used names in .cc files.</span></div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;<span class="stringliteral">    namespace baz = ::foo::bar::baz;</span></div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;<span class="stringliteral">    ```</span></div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;<span class="stringliteral">    ```c++</span></div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;<span class="stringliteral">    // Shorten access to some commonly used names (in a .h file).</span></div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;<span class="stringliteral">    namespace librarian {</span></div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;<span class="stringliteral">    namespace impl {  // Internal, not part of the API.</span></div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;<span class="stringliteral">    namespace sidetable = ::pipeline_diagnostics::sidetable;</span></div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;<span class="stringliteral">    }  // namespace impl</span></div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;<span class="stringliteral">    inline void my_inline_function() {</span></div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;<span class="stringliteral">      // namespace alias local to a function (or method).</span></div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;<span class="stringliteral">      namespace baz = ::foo::bar::baz;</span></div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;<span class="stringliteral">      ...</span></div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;<span class="stringliteral">    }  // namespace librarian</span></div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;<span class="stringliteral">    ```</span></div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;<span class="stringliteral">* Do not use inline namespaces.</span></div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;<span class="stringliteral">### Unnamed Namespaces and Static Variables</span></div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;<span class="stringliteral">&gt; When definitions in a `.cpp` file do not need to be referenced outside that file, place them in an unnamed namespace or declare them `static`. Do not use either of these constructs in `.h` files.</span></div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;<span class="stringliteral">**Definition**</span></div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;<span class="stringliteral">All declarations can be given internal linkage by placing them in unnamed namespaces, and functions and variables can be given internal linkage by declaring them `static`. This means that anything you&#39;</span>re declaring can<span class="stringliteral">&#39;t be accessed from another file. If a different file declares something with the same name, then the two entities are completely independent.</span></div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;<span class="stringliteral">**Decision**</span></div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;<span class="stringliteral">Use of internal linkage in `.cc` files is encouraged for all code that does not need to be referenced elsewhere. Do not use internal linkage in `.h` files.</span></div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;<span class="stringliteral">Format unnamed namespaces like named namespaces. In the terminating comment, leave the namespace name empty:</span></div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;<span class="stringliteral">namespace {</span></div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;<span class="stringliteral">...</span></div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;<span class="stringliteral">}  // namespace</span></div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;<span class="stringliteral">### Nonmember, Static Member, and Global Functions</span></div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;<span class="stringliteral">&gt; Prefer placing nonmember functions in a namespace; use completely global functions rarely. Prefer grouping functions with a namespace instead of using a class as if it were a namespace. Static methods of a class should generally be closely related to instances of the class or the class&#39;</span>s <span class="keyword">static</span> data.</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;**Pros**</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;Nonmember and <span class="keyword">static</span> member functions can be useful in some situations. Putting nonmember functions in a <span class="keyword">namespace </span>avoids polluting the global <span class="keyword">namespace</span>.</div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;</div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;**Cons**</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;Nonmember and <span class="keyword">static</span> member functions may make more sense as members of a <span class="keyword">new</span> <span class="keyword">class</span>, especially <span class="keywordflow">if</span> they access external resources or have significant dependencies.</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;</div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;**Decision**</div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;</div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;&lt;!-- TODO: Update once the <span class="keyword">namespace </span>naming conventions are finalised --&gt;</div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;Sometimes it is useful to define a <span class="keyword">function</span> not bound to a <span class="keyword">class </span>instance. Such a <span class="keyword">function</span> can be either a <span class="keyword">static</span> member or a nonmember <span class="keyword">function</span>. Nonmember functions should not depend on external variables, and should nearly always exist in a <span class="keyword">namespace</span>. Rather than creating classes only to group <span class="keyword">static</span> member functions which <span class="keywordflow">do</span> not share <span class="keyword">static</span> data, use [namespaces](#namespaces) instead. For a header `myproject/foo_bar.h`, <span class="keywordflow">for</span> example, write</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;```c++</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;<span class="keyword">namespace</span> myproject {</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;<span class="keyword">namespace</span> foo_bar {</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;<span class="keywordtype">void</span> Function1();</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;<span class="keywordtype">void</span> Function2();</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;}  <span class="comment">// namespace foo_bar</span></div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;}  <span class="comment">// namespace myproject</span></div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;```</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;</div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;instead of</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;</div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;```c++</div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;<span class="keyword">namespace </span>myproject {</div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;<span class="keyword">class </span>FooBar {</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160; <span class="keyword">public</span>:</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;  <span class="keyword">static</span> <span class="keywordtype">void</span> Function1();</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;  <span class="keyword">static</span> <span class="keywordtype">void</span> Function2();</div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;};</div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;}  <span class="comment">// namespace myproject</span></div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;```</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;</div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;If you define a nonmember <span class="keyword">function</span> and it is only needed in its `.cpp` file, use [<span class="keyword">internal</span> linkage](#unnamed-namespaces-and-<span class="keyword">static</span>-variables) to limit its scope.</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;</div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;### Local Variables</div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;</div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;&lt;!-- TODO: Rework the examples to be more relevant. No `std::` stuff. --&gt;</div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;&gt; Place a <span class="keyword">function</span><span class="stringliteral">&#39;s variables in the narrowest scope possible, and initialize variables in the declaration.</span></div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;<span class="stringliteral">C++ allows you to declare variables anywhere in a function. We encourage you to declare them in as local a scope as possible, and as close to the first use as possible. This makes it easier for the reader to find the declaration and see what type the variable is and what it was initialized to. In particular, initialization should be used instead of declaration and assignment, e.g.:</span></div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;<span class="stringliteral">int i;</span></div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;<span class="stringliteral">i = f();      // Bad -- initialization separate from declaration.</span></div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;<span class="stringliteral">int j = g();  // Good -- declaration has initialization.</span></div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;<span class="stringliteral">std::vector&lt;int&gt; v;</span></div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;<span class="stringliteral">v.push_back(1);  // Prefer initializing using brace initialization.</span></div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;<span class="stringliteral">v.push_back(2);</span></div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;<span class="stringliteral">std::vector&lt;int&gt; v = {1, 2};  // Good -- v starts initialized.</span></div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;<span class="stringliteral">Variables needed for `if`, `while` and `for` statements should normally be declared within those statements, so that such variables are confined to those scopes. E.g.:</span></div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;<span class="stringliteral">while (const char* p = strchr(str, &#39;</span>/<span class="stringliteral">&#39;)) str = p + 1;</span></div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;<span class="stringliteral">There is one caveat: if the variable is an object, its constructor is invoked every time it enters scope and is created, and its destructor is invoked every time it goes out of scope.</span></div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;<span class="stringliteral">// Inefficient implementation:</span></div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;<span class="stringliteral">for (int i = 0; i &lt; 1000000; ++i) {</span></div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;<span class="stringliteral">  Foo f;  // My ctor and dtor get called 1000000 times each.</span></div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;<span class="stringliteral">  f.DoSomething(i);</span></div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;<span class="stringliteral">It may be more efficient to declare such a variable used in a loop outside that loop:</span></div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;<span class="stringliteral">Foo f;  // My ctor and dtor get called once each.</span></div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;<span class="stringliteral">for (int i = 0; i &lt; 1000000; ++i) {</span></div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;<span class="stringliteral">  f.DoSomething(i);</span></div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;<span class="stringliteral">### Static and Global Variables</span></div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;<span class="stringliteral">&gt; Variables of class type with [static storage duration][cppref:storage-duration] are forbidden: they cause hard-to-find bugs due to indeterminate order of construction and destruction. However, such variables are allowed if they are `constexpr`: they have no dynamic initialization or destruction.</span></div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;<span class="stringliteral"> [cppref:storage-duration]: http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration</span></div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;<span class="stringliteral">Objects with static storage duration, including global variables, static variables, static class member variables, and function static variables, must be Plain Old Data (POD): only ints, chars, floats, or pointers, or arrays/structs of POD.</span></div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;<span class="stringliteral">&lt;!-- TODO: Reword. getenv() / getpid() make little sense in our context, for example --&gt;</span></div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;<span class="stringliteral">The order in which class constructors and initializers for static variables are called is only partially specified in C++ and can even change from build to build, which can cause bugs that are difficult to find. Therefore in addition to banning globals of class type, we do not allow non-local static variables to be initialized with the result of a function, unless that function (such as `getenv()`, or `getpid()`) does not itself depend on any other globals. However, a static POD variable within function scope may be initialized with the result of a function, since its initialization order is well-defined and does not occur until control passes through its declaration.</span></div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;<span class="stringliteral">&lt;!-- TODO: reword: no threads in our context --&gt;</span></div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;<span class="stringliteral">Likewise, global and static variables are destroyed when the program terminates, regardless of whether the termination is by returning from `main()` or by calling `exit()`. The order in which destructors are called is defined to be the reverse of the order in which the constructors were called. Since constructor order is indeterminate, so is destructor order. For example, at program-end time a static variable might have been destroyed, but code still running - perhaps in another thread - tries to access it and fails. Or the destructor for a static `string` variable might be run prior to the destructor for another variable that contains a reference to that string.</span></div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;<span class="stringliteral">&lt;!-- TODO: reword: we do not terminate. --&gt;</span></div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;<span class="stringliteral">One way to alleviate the destructor problem is to terminate the program by calling `quick_exit()` instead of `exit()`. The difference is that `quick_exit()` does not invoke destructors and does not invoke any handlers that were registered by calling `atexit()`. If you have a handler that needs to run when a program terminates via `quick_exit()` (flushing logs, for example), you can register it using `at_quick_exit()`. (If you have a handler that needs to run at both `exit()` and `quick_exit()`, you need to register it in both places.)&lt;/p&gt;</span></div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;<span class="stringliteral">As a result we only allow static variables to contain POD data. This rule completely disallows `std::vector` (use C arrays instead), or `string` (use `const char []`).</span></div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;<span class="stringliteral">If you need a static or global variable of a class type, consider initializing a pointer (which will never be freed), from either your main() function or from pthread_once(). Note that this must be a raw pointer, not a &quot;smart&quot; pointer, since the smart pointer&#39;</span>s destructor will have the order-of-destructor issue that we are trying to avoid.</div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;</div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;## Classes</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;</div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;Classes are the fundamental unit of code in C++. Naturally, we use them extensively. This section lists the main dos and don<span class="stringliteral">&#39;ts you should follow when writing a class.</span></div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;<span class="stringliteral">### Doing Work in Constructors</span></div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;<span class="stringliteral">&gt; Avoid virtual method calls in constructors, and avoid initialization that can fail if you can&#39;</span>t signal an error.</div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;</div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;**Definition**</div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;</div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;It is possible to perform arbitrary initialization in the body of the constructor.</div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;</div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;**Pros**</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;</div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;* No need to worry about whether the <span class="keyword">class</span> has been initialized or not.</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;* Objects that are fully initialized by constructor call can be `<span class="keyword">const</span>` and may also be easier to use with standard containers or algorithms.</div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;</div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;**Cons**</div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;</div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;&lt;!-- TODO: We <span class="keywordflow">do</span> not have threads, possibly <span class="keyword">remove</span> the last item? --&gt;</div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;</div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;* If the work calls <span class="keyword">virtual</span> functions, these calls will not <span class="keyword">get</span> dispatched to the subclass implementations. Future modification to your <span class="keyword">class</span> can quietly introduce <span class="keyword">this</span> problem even <span class="keywordflow">if</span> your <span class="keyword">class</span> is not currently subclassed, causing much confusion.</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;* There is no easy way <span class="keywordflow">for</span> constructors to signal errors, <span class="keywordtype">short</span> of crashing the program (not always appropriate) or <span class="keyword">using</span> exceptions (which are [forbidden](#exceptions)).</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;* If the work fails, we now have an <span class="keywordtype">object</span> whose initialization code failed, so it may be an unusual state requiring a `<span class="keywordtype">bool</span> IsValid()` state checking mechanism (or similar) which is easy to forget to call.</div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;* You cannot take the address of a constructor, so whatever work is done in the constructor cannot easily be handed off to, <span class="keywordflow">for</span> example, another thread.</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;</div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;**Decision**</div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;</div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;&lt;!-- TODO: we <span class="keywordflow">do</span> not terminate, and most of our objects are initialized by the library itself. Work that in, somehow? Perhaps into Cons above? --&gt;</div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;</div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;Constructors should never call <span class="keyword">virtual</span> functions. If appropriate <span class="keywordflow">for</span> your code , terminating the program may be an appropriate error handling response. Otherwise, consider a factory <span class="keyword">function</span> or `Init()` method. Avoid `Init()` methods on objects with no other states that affect which <span class="keyword">public</span> methods may be called (semi-constructed objects of <span class="keyword">this</span> form are particularly hard to work with correctly).</div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;### Implicit Conversions</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;&gt; Do not define implicit conversions. Use the `<span class="keyword">explicit</span>` keyword <span class="keywordflow">for</span> conversion operators and single-argument constructors.</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;</div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;**Definition**</div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;</div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;Implicit conversions allow an <span class="keywordtype">object</span> of one type (called the *source type*) to be used where a different type (called the *destination type*) is expected, such as when passing an `<span class="keywordtype">int</span>` argument to a function that takes a `<span class="keywordtype">double</span>` parameter.</div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;</div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;In addition to the implicit conversions defined by the language, users can define their own, by adding appropriate members to the class definition of the source or destination type. An implicit conversion in the source type is defined by a type conversion operator named after the destination type (e.g. `operator <span class="keywordtype">bool</span>()`). An implicit conversion in the destination type is defined by a constructor that can take the source type as its only argument (or only argument with no default value).</div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;</div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;The `explicit` keyword can be applied to a constructor or (since C++11) a conversion operator, to ensure that it can only be used when the destination type is explicit at the point of use, e.g. with a cast. This applies not only to implicit conversions, but to C++11&#39;s list initialization syntax:</div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;</div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;```c++</div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;class Foo {</div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;  <span class="keyword">explicit</span> Foo(<span class="keywordtype">int</span> x, <span class="keywordtype">double</span> y);</div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;  ...</div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;};</div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;</div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;<span class="keywordtype">void</span> Func(Foo f);</div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;```</div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;</div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;```c++</div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;Func({42, 3.14});  <span class="comment">// Error!</span></div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;```</div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;</div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;This kind of code isn<span class="stringliteral">&#39;t technically an implicit conversion, but the language treats it as one as far as `explicit` is concerned.</span></div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;<span class="stringliteral">**Pros**</span></div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;<span class="stringliteral">* Implicit conversions can make a type more usable and expressive by eliminating the need to explicitly name a type when it&#39;</span>s obvious.</div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;* Implicit conversions can be a simpler alternative to overloading.</div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;* List initialization syntax is a concise and expressive way of initializing objects.</div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;</div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;**Cons**</div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;</div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;* Implicit conversions can hide type-mismatch bugs, where the destination type does not match the user<span class="stringliteral">&#39;s expectation, or the user is unaware that any conversion will take place.</span></div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;<span class="stringliteral">* Implicit conversions can make code harder to read, particularly in the presence of overloading, by making it less obvious what code is actually getting called.</span></div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;<span class="stringliteral">* Constructors that take a single argument may accidentally be usable as implicit type conversions, even if they are not intended to do so.</span></div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;<span class="stringliteral">* When a single-argument constructor is not marked `explicit`, there&#39;</span>s no reliable way to tell whether it<span class="stringliteral">&#39;s intended to define an implicit conversion, or the author simply forgot to mark it.</span></div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;<span class="stringliteral">* It&#39;</span>s not always clear which type should provide the conversion, and <span class="keywordflow">if</span> they both <span class="keywordflow">do</span>, the code becomes ambiguous.</div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;* List initialization can suffer from the same problems <span class="keywordflow">if</span> the destination type is implicit, particularly <span class="keywordflow">if</span> the list has only a single element.</div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;</div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;**Decision**</div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;</div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;Type conversion operators, and constructors that are callable with a single argument, must be marked `<span class="keyword">explicit</span>` in the <span class="keyword">class </span>definition. As an exception, copy and move constructors should not be `<span class="keyword">explicit</span>`, since they <span class="keywordflow">do</span> not perform type conversion. Implicit conversions can sometimes be necessary and appropriate <span class="keywordflow">for</span> types that are designed to transparently wrap other types. In that <span class="keywordflow">case</span>, contact your project leads to request a waiver of <span class="keyword">this</span> rule.</div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;</div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;Constructors that cannot be called with a single argument should usually omit `<span class="keyword">explicit</span>`. Constructors that take a single `std::initializer_list` parameter should also omit `<span class="keyword">explicit</span>`, in order to support copy-initialization (e.g. `MyType m = {1, 2};`).</div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;</div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;### Copyable and Movable Types</div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;</div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;&lt;!-- TODO: Do we need <span class="keyword">this</span> section? Most of our classes will not need copying, or moving. They<span class="stringliteral">&#39;re ~singletons. --&gt;</span></div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;<span class="stringliteral">&gt; Support copying and/or moving if these operations are clear and meaningful for your type. Otherwise, disable the implicitly generated special functions that perform copies and moves.</span></div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;<span class="stringliteral">**Definition**</span></div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;<span class="stringliteral">A copyable type allows its objects to be initialized or assigned from any other object of the same type, without changing the value of the source. For user-defined types, the copy behavior is defined by the copy constructor and the copy-assignment operator. `string` is an example of a copyable type.</span></div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;<span class="stringliteral">A movable type is one that can be initialized and assigned from temporaries (all copyable types are therefore movable). `std::unique_ptr&lt;int&gt;` is an example of a movable but not copyable type. For user-defined types, the move behavior is defined by the move constructor and the move-assignment operator.</span></div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;<span class="stringliteral">The copy/move constructors can be implicitly invoked by the compiler in some situations, e.g. when passing objects by value.</span></div>
<div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;<span class="stringliteral">**Pros**</span></div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;<span class="stringliteral">Objects of copyable and movable types can be passed and returned by value, which makes APIs simpler, safer, and more general. Unlike when passing objects by pointer or reference, there&#39;</span>s no risk of confusion over ownership, lifetime, mutability, and similar issues, and no need to specify them in the contract. It also prevents non-local interactions between the client and the implementation, which makes them easier to understand, maintain, and optimize by the compiler. Further, such objects can be used with <span class="keyword">generic</span> APIs that require pass-by-value, such as most containers, and they allow <span class="keywordflow">for</span> additional flexibility in e.g., type composition.</div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;</div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;Copy/move constructors and assignment operators are usually easier to define correctly than alternatives like `Clone()`, `CopyFrom()` or `Swap()`, because they can be generated by the compiler, either implicitly or with `= <span class="keywordflow">default</span>`. They are concise, and ensure that all data members are copied. Copy and move constructors are also generally more efficient, because they don<span class="stringliteral">&#39;t require heap allocation or separate initialization and assignment steps, and they&#39;</span>re eligible <span class="keywordflow">for</span> optimizations such as [copy elision][cppref:copy-elision].</div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;</div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160; [cppref:copy-elision]: http:<span class="comment">//en.cppreference.com/w/cpp/language/copy_elision</span></div>
<div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;</div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;Move operations allow the implicit and efficient transfer of resources out of rvalue objects. This allows a plainer coding style in some cases.</div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;</div>
<div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;**Cons**</div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;</div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;Some types <span class="keywordflow">do</span> not need to be copyable, and providing copy operations <span class="keywordflow">for</span> such types can be confusing, nonsensical, or outright incorrect. Types representing singleton objects (`Registerer`), objects tied to a specific scope (`Cleanup`), or closely coupled to <span class="keywordtype">object</span> identity (`Mutex`) cannot be copied meaningfully. Copy operations for base class types that are to be used polymorphically are hazardous, because use of them can lead to [<span class="keywordtype">object</span> slicing][wikipedia:<span class="keywordtype">object</span>-slicing]. Defaulted or carelessly-implemented copy operations can be incorrect, and the resulting bugs can be confusing and difficult to diagnose.</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;</div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160; [wikipedia:<span class="keywordtype">object</span>-slicing]: https:<span class="comment">//en.wikipedia.org/wiki/Object_slicing</span></div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;</div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;Copy constructors are invoked implicitly, which makes the invocation easy to miss. This may cause confusion for programmers used to languages where pass-by-reference is conventional or mandatory. It may also encourage excessive copying, which can cause performance problems.</div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;</div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;**Decision**</div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;</div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;Provide the copy and move operations if their meaning is clear to a casual user and the copying/moving does not incur unexpected costs. If you define a copy or move constructor, define the corresponding assignment operator, and vice-versa. If your type is copyable, do not define move operations unless they are significantly more efficient than the corresponding copy operations. If your type is not copyable, but the correctness of a move is obvious to users of the type, you may make the type move-only by defining both of the move operations.</div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;</div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;If your type provides copy operations, it is recommended that you design your class so that the default implementation of those operations is correct. Remember to review the correctness of any defaulted operations as you would any other code, and to document that your class is copyable and/or cheaply movable if that&#39;s an API guarantee.</div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;</div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;```c++</div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;class Foo {</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160; <span class="keyword">public</span>:</div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;  Foo(Foo&amp;&amp; other) : field_(other.field) {}</div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;  <span class="comment">// Bad, defines only move constructor, but not operator=.</span></div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;</div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160; <span class="keyword">private</span>:</div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;  Field field_;</div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;};</div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;```</div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;</div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;Due to the risk of slicing, avoid providing an assignment <span class="keyword">operator</span> or <span class="keyword">public</span> copy/move constructor <span class="keywordflow">for</span> a <span class="keyword">class </span>that<span class="stringliteral">&#39;s intended to be derived from (and avoid deriving from a class with such members). If your base class needs to be copyable, provide a public virtual `Clone()` method, and a protected copy constructor that derived classes can use to implement it.</span></div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;<span class="stringliteral">If you do not want to support copy/move operations on your type, explicitly disable them using `= delete` in the `public:` section:&lt;/p&gt;</span></div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;<span class="stringliteral">// MyClass is neither copyable nor movable.</span></div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;<span class="stringliteral">MyClass(const MyClass&amp;) = delete;</span></div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;<span class="stringliteral">MyClass&amp; operator=(const MyClass&amp;) = delete;</span></div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;<span class="stringliteral">### Structs vs. Classes</span></div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;<span class="stringliteral">&gt; Use a `struct` only for passive objects that carry data; everything else is a `class`.</span></div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;<span class="stringliteral">The `struct` and `class` keywords behave almost identically in C++. We add our own semantic meanings to each keyword, so you should use the appropriate keyword for the data-type you&#39;</span>re defining.</div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;</div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;`structs` should be used <span class="keywordflow">for</span> passive objects that carry data, and may have associated constants, but lack any functionality other than access/setting the data members. The accessing/setting of fields is done by directly accessing the fields rather than through method invocations. Methods should not provide behavior but should only be used to set up the data members, e.g., constructor, destructor, `Initialize()`, `Reset()`, `Validate()`.</div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;</div>
<div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;If more functionality is required, a `<span class="keyword">class</span>` is more appropriate. If in doubt, make it a `<span class="keyword">class</span>`.</div>
<div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;</div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;For consistency with STL, you can use `<span class="keyword">struct</span>` instead of `<span class="keyword">class</span>` <span class="keywordflow">for</span> functors and traits.</div>
<div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;</div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;Note that member variables in structs and classes have [different naming rules](#variable-names).</div>
<div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;</div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;### Inheritance</div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;</div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;&gt; Composition is often more appropriate than inheritance. When <span class="keyword">using</span> inheritance, make it `<span class="keyword">public</span>`.</div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;</div>
<div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;**Definition**</div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;</div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;When a sub-<span class="keyword">class</span> inherits from a base <span class="keyword">class</span>, it includes the definitions of all the data and operations that the parent base <span class="keyword">class</span> defines. In practice, inheritance is used in two major ways in C++: implementation inheritance, in which actual code is inherited by the child, and [interface inheritance](#interfaces) , in which only method names are inherited.</div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;</div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;**Pros**</div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;</div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;Implementation inheritance reduces code size by re-<span class="keyword">using</span> the base <span class="keyword">class </span>code as it specializes an existing type. Because inheritance is a compile-time declaration, you and the compiler can understand the operation and detect errors. Interface inheritance can be used to programmatically enforce that a <span class="keyword">class </span>expose a particular API. Again, the compiler can detect errors, in <span class="keyword">this</span> <span class="keywordflow">case</span>, when a <span class="keyword">class </span>does not define a necessary method of the API.</div>
<div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;</div>
<div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;**Cons**</div>
<div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;</div>
<div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;For implementation inheritance, because the code implementing a sub-<span class="keyword">class </span>is spread between the base and the sub-<span class="keyword">class</span>, it can be more difficult to understand an implementation. The sub-<span class="keyword">class </span>cannot <span class="keyword">override</span> functions that are not <span class="keyword">virtual</span>, so the sub-<span class="keyword">class </span>cannot change implementation. The base <span class="keyword">class </span>may also define some data members, so that specifies physical layout of the base <span class="keyword">class</span>.</div>
<div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;</div>
<div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;**Decision**</div>
<div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;</div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;All inheritance should be `<span class="keyword">public</span>`. If you</div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;want to <span class="keywordflow">do</span> <span class="keyword">private</span> inheritance, you should be including</div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;an instance of the base <span class="keyword">class </span>as a member instead.</div>
<div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;</div>
<div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;Do not overuse implementation inheritance. Composition is often more appropriate. Try to restrict use of inheritance to the *<span class="stringliteral">&quot;is-a&quot;</span>* <span class="keywordflow">case</span>: `Bar` subclasses `Foo` <span class="keywordflow">if</span> it can reasonably be said that `Bar` <span class="stringliteral">&quot;is a kind of&quot;</span> `Foo`.</div>
<div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;</div>
<div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;Make your destructor `<span class="keyword">virtual</span>` <span class="keywordflow">if</span> necessary. If your <span class="keyword">class </span>has <span class="keyword">virtual</span> methods, its destructor should be <span class="keyword">virtual</span>.</div>
<div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;</div>
<div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;&lt;!-- TODO: Access control needs rework, update <span class="keyword">this</span> too afterwards. --&gt;</div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;Limit the use of `<span class="keyword">protected</span>` to those member functions that might need to be accessed from subclasses. Note that [data members should be <span class="keyword">private</span>](#access-control).</div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;</div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;Explicitly annotate overrides of <span class="keyword">virtual</span> functions or <span class="keyword">virtual</span> destructors with an `<span class="keyword">override</span>` or (less frequently) `<span class="keyword">final</span>` specifier. Older (pre-C++11) code will use the `virtual` keyword as an inferior alternative annotation. For clarity, use exactly one of `override`, `final`, or `virtual` when declaring an override. Rationale: A function or destructor marked `override` or `final` that is not an override of a base class virtual function will not compile, and this helps catch common errors. The specifiers serve as documentation; if no specifier is present, the reader has to check all ancestors of the class in question to determine if the function or destructor is virtual or not.</div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;</div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;<span class="preprocessor">### Multiple Inheritance</span></div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;&gt; Only very rarely is multiple implementation inheritance actually useful. We allow multiple inheritance only when at most one of the base classes has an implementation; all other base classes must be [pure interface](#interfaces) classes tagged with the `Interface` suffix.</div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;</div>
<div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;**Definition**</div>
<div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;</div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;Multiple inheritance allows a sub-<span class="keyword">class</span> to have more than one base <span class="keyword">class</span>. We distinguish between base classes that are *pure interfaces* and those that have an *implementation*.</div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;</div>
<div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;**Pros**</div>
<div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;</div>
<div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;Multiple implementation inheritance may let you re-use even more code than single inheritance (see [Inheritance](#inheritance)).</div>
<div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;</div>
<div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;**Cons**</div>
<div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;</div>
<div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;Only very rarely is multiple *implementation* inheritance actually useful. When multiple implementation inheritance seems like the solution, you can usually find a different, more <span class="keyword">explicit</span>, and cleaner solution.</div>
<div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;</div>
<div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;**Decision**</div>
<div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;</div>
<div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;Multiple inheritance is allowed only when all superclasses, with the possible exception of the first one, are [pure interfaces](#interfaces). In order to ensure that they remain pure interfaces, they must end with the `Interface` suffix.</div>
<div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;</div>
<div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;### Interfaces</div>
<div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;</div>
<div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;&gt; Classes that satisfy certain conditions are allowed, but not required, to end with an `Interface` suffix.</div>
<div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;</div>
<div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;**Definition**</div>
<div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;</div>
<div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;A <span class="keyword">class </span>is a pure interface if it meets the following requirements:</div>
<div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;</div>
<div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;* It has only <span class="keyword">public</span> pure <span class="keyword">virtual</span> (&quot;`= 0`&quot;) methods and static methods (but see below for destructor).</div>
<div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;* It may not have non-static data members.</div>
<div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;* It need not have any constructors defined. If a constructor is provided, it must take no arguments and it must be <span class="keyword">protected</span>.</div>
<div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;* If it is a subclass, it may only be derived from classes that satisfy these conditions and are tagged with the `Interface` suffix.</div>
<div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;</div>
<div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;An interface class can never be directly instantiated because of the pure <span class="keyword">virtual</span> method(s) it declares. To make sure all implementations of the interface can be destroyed correctly, the interface must also declare a <span class="keyword">virtual</span> destructor (in an exception to the first rule, this should not be pure). See Stroustrup, &lt;cite&gt;The C++ Programming Language&lt;/cite&gt;, 3rd edition, section 12.4 for details.</div>
<div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;</div>
<div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;**Pros**</div>
<div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;</div>
<div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;&lt;!-- Do we need to mention Java programmers? Kinda irrelevant in our context. --&gt;</div>
<div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;</div>
<div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;Tagging a class with the `Interface` suffix lets others know that they must not add implemented methods or non static data members. This is particularly important in the case of [multiple inheritance](#multiple-inheritance). Additionally, the interface concept is already well-understood by Java programmers.</div>
<div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;</div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;**Cons**</div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;</div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;The `Interface` suffix lengthens the class name, which can make it harder to read and understand. Also, the interface property may be considered an implementation detail that shouldn&#39;t be exposed to clients.</div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;</div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;**Decision**</div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;</div>
<div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;A class may end with `Interface` only if it meets the above requirements. We do not require the converse, however: classes that meet the above requirements are not required to end with `Interface`.</div>
<div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;</div>
<div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;<span class="preprocessor">### Operator Overloading</span></div>
<div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;&gt; Overload operators judiciously. Do not create user-defined literals.</div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;</div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;**Definition**</div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;</div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;C++ permits user code to [declare overloaded versions of the built-in operators][cppref:operators] using the `operator` keyword, so long as one of the parameters is a user-defined type. The `operator` keyword also permits user code to define new kinds of literals using `operator&quot;&quot;`, and to define type-conversion functions such as `operator bool()`.</div>
<div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;</div>
<div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160; [cppref:operators]: http:<span class="comment">//en.cppreference.com/w/cpp/language/operators</span></div>
<div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;</div>
<div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;**Pros**</div>
<div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;</div>
<div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;Operator overloading can make code more concise and intuitive by enabling user-defined types to behave the same as built-in types. Overloaded operators are the idiomatic names for certain operations (e.g. `==`, `&lt;`, `=`, and `&lt;&lt;`), and adhering to those conventions can make user-defined types more readable and enable them to interoperate with libraries that expect those names.</div>
<div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;</div>
<div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;User-defined literals are a very concise notation for creating objects of user-defined types.</div>
<div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;</div>
<div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;**Cons**</div>
<div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;</div>
<div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;* Providing a correct, consistent, and unsurprising set of operator overloads requires some care, and failure to do so can lead to confusion and bugs.</div>
<div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;* Overuse of operators can lead to obfuscated code, particularly if the overloaded operator&#39;s semantics don&#39;t follow convention.</div>
<div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;* The hazards of function overloading apply just as much to operator overloading, if not more so.</div>
<div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;* Operator overloads can fool our intuition into thinking that expensive operations are cheap, built-in operations.</div>
<div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;* Finding the call sites for overloaded operators may require a search tool that&#39;s aware of C++ syntax, rather than e.g. grep.</div>
<div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;* If you get the argument type of an overloaded operator wrong, you may get a different overload rather than a compiler error. For example, `foo &lt; bar` may do one thing, while `&amp;foo &lt; &amp;bar` does something totally different.</div>
<div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;* Certain operator overloads are inherently hazardous. Overloading unary `&amp;` can cause the same code to have different meanings depending on whether the overload declaration is visible. Overloads of `&amp;&amp;`, `||`, and `,` (comma) cannot match the evaluation-order semantics of the built-in operators.</div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;* Operators are often defined outside the class, so there&#39;s a risk of different files introducing different definitions of the same operator. If both definitions are linked into the same binary, this results in undefined behavior, which can manifest as subtle run-time bugs.</div>
<div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;* User-defined literals allow the creation of new syntactic forms that are unfamiliar even to experienced C++ programmers.</div>
<div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;</div>
<div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;**Decision**</div>
<div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;</div>
<div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;Define overloaded operators only if their meaning is obvious, unsurprising, and consistent with the corresponding built-in operators. For example, use `|` as a bitwise- or logical-or, not as a shell-style pipe.</div>
<div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;</div>
<div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;Define operators only on your own types. More precisely, define them in the same headers, `.cpp` files, and namespaces as the types they operate on. That way, the operators are available wherever the type is, minimizing the risk of multiple definitions. If possible, avoid defining operators as templates, because they must satisfy this rule for any possible template arguments. If you define an operator, also define any related operators that make sense, and make sure they are defined consistently. For example, if you overload `&lt;`, overload all the comparison operators, and make sure `&lt;` and `&gt;` never return true for the same arguments.</div>
<div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;</div>
<div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;Prefer to define non-modifying binary operators as non-member functions. If a binary operator is defined as a class member, implicit conversions will apply to the right-hand argument, but not the left-hand one. It will confuse your users if `a &lt; b` compiles but `b &lt; a` doesn&#39;t.</div>
<div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;</div>
<div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;&lt;!-- TODO: Find a bettere example, we do not use `std::set`... --&gt;</div>
<div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;</div>
<div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;Don&#39;t go out of your way to avoid defining operator overloads. For example, prefer to define `==`, `=`, and `&lt;&lt;`, rather than `Equals()`, `CopyFrom()`, and `PrintTo()`. Conversely, don&#39;t define operator overloads just because other libraries expect them. For example, if your type doesn&#39;t have a natural ordering, but you want to store it in a `std::set`, use a custom comparator rather than overloading `&lt;`.</div>
<div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;</div>
<div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;Do not overload `&amp;&amp;`, `||`, `,` (comma), or unary `&amp;`. Do not overload `operator&quot;&quot;`, i.e. do not introduce user-defined literals.</div>
<div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;</div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;Type conversion operators are covered in the section on [implicit conversions](#implicit-conversions). The `=` operator is covered in the section on [copy constructors](#copyable-and-movable-types) . Overloading `&lt;&lt;` for use with streams is covered in the section on [streams](#streams). See also the rules on [function overloading](#function-overloading) , which apply to operator overloading as well.</div>
<div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;</div>
<div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;### Access Control</div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;</div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;&lt;!-- TODO: This guidance isn&#39;t quite right for embedded, where accessors often add too much overhead. --&gt;</div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;</div>
<div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;&gt; Make data members `private`, unless they are `static const` (and follow the [naming convention for constants](#constant-names)). &lt;strike&gt;For technical reasons, we allow data members of a test fixture class to be `protected` when using &lt;a href=&quot;https:<span class="comment">//github.com/google/googletest&quot;&gt;Google Test&lt;/a&gt;).&lt;/strike&gt;</span></div>
<div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;</div>
<div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;### Declaration Order</div>
<div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;</div>
<div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;&gt; Group similar declarations together, placing public parts earlier.</div>
<div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;</div>
<div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;A class definition should usually start with a `public:` section, followed by `protected:`, then `private:`. Omit sections that would be empty.</div>
<div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;</div>
<div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;Within each section, generally prefer grouping similar kinds of declarations together, and generally prefer the following order: types (including `typedef`, `using`, and nested structs and classes), constants, factory functions, constructors, assignment operators, destructor, all other methods, data members.</div>
<div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;</div>
<div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;Do not put large method definitions inline in the class definition. Usually, only trivial or performance-critical, and very short, methods may be defined inline. See [Inline Functions](#inline-functions) for more details.</div>
<div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;</div>
<div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;## Functions</div>
<div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;</div>
<div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;## Parameter Ordering</div>
<div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;</div>
<div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;&gt; When defining a function, parameter order is: inputs, then outputs.</div>
<div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;</div>
<div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;Parameters to C/C++ functions are either input to the function, output from the function, or both. Input parameters are usually values or `const` references, while output and input/output parameters will be pointers to non-`const`. When ordering function parameters, put all input-only parameters before any output parameters. In particular, do not add new parameters to the end of the function just because they are new; place new input-only parameters before the output parameters.</div>
<div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;</div>
<div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;This is not a hard-and-fast rule. Parameters that are both input and output (often classes/structs) muddy the waters, and, as always, consistency with related functions may require you to bend the rule.</div>
<div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;</div>
<div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;## Write Short Functions</div>
<div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;</div>
<div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;&gt; Prefer small and focused functions.</div>
<div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;</div>
<div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;We recognize that long functions are sometimes appropriate, so no hard limit is placed on functions length. If a function exceeds about 40 lines, think about whether it can be broken up without harming the structure of the program.</div>
<div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;</div>
<div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;Even if your long function works perfectly now, someone modifying it in a few months may add new behavior. This could result in bugs that are hard to find. Keeping your functions short and simple makes it easier for other people to read and modify your code.</div>
<div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;</div>
<div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;You could find long and complicated functions when working with some code. Do not be intimidated by modifying existing code: if working with such a function proves to be difficult, you find that errors are hard to debug, or you want to use a piece of it in several different contexts, consider breaking up the function into smaller and more manageable pieces.</div>
<div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;</div>
<div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;## Reference Arguments</div>
<div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;</div>
<div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;&gt; All parameters passed by reference must be labeled `const`.</div>
<div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;</div>
<div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;**Definition**</div>
<div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;</div>
<div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;In C, if a function needs to modify a variable, the parameter must use a pointer, eg `int foo(int *pval)`. In C++, the function can alternatively declare a reference parameter: `int foo(int &amp;val)`.</div>
<div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;</div>
<div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;**Pros**</div>
<div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;</div>
<div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;Defining a parameter as reference avoids ugly code like `(*pval)++`. Necessary for some applications like copy constructors. Makes it clear, unlike with pointers, that a null pointer is not a possible value.</div>
<div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;</div>
<div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;**Cons**</div>
<div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;</div>
<div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;References can be confusing, as they have value syntax but pointer semantics.</div>
<div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;</div>
<div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;**Decision**</div>
<div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;</div>
<div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;Within function parameter lists all references must be `const`:</div>
<div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;</div>
<div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;```c++</div>
<div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;void Foo(const string &amp;in, string *out);</div>
<div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;```</div>
<div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;</div>
<div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;In fact it is a very strong convention in Google code that input arguments are values or `const` references while output arguments are pointers. Input parameters may be `const` pointers, but we never allow non-`const` reference parameters except when required by convention, e.g., `swap()`.</div>
<div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;</div>
<div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;However, there are some instances where using `const T*` is preferable to `const T&amp;` for input parameters. For example:</div>
<div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;</div>
<div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;* You want to pass in a null pointer.</div>
<div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;* The function saves a pointer or reference to the input.</div>
<div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;</div>
<div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;Remember that most of the time input parameters are going to be specified as `const T&amp;`. Using `const T*` instead communicates to the reader that the input is somehow treated differently. So if you choose `const T*` rather than `const T&amp;`, do so for a concrete reason; otherwise it will likely confuse readers by making them look for an explanation that doesn&#39;t exist.</div>
<div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;</div>
<div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;## Function Overloading</div>
<div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;</div>
<div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;&gt; Use overloaded functions (including constructors) only if a reader looking at a call site can get a good idea of what is happening without having to first figure out exactly which overload is being called.</div>
<div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;</div>
<div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;**Definition**</div>
<div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;</div>
<div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;You may write a function that takes a `const string&amp;` and overload it with another that takes `const char*`.</div>
<div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;</div>
<div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;```c++</div>
<div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;class MyClass {</div>
<div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160; public:</div>
<div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;  void Analyze(const string &amp;text);</div>
<div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;  void Analyze(const char *text, size_t textlen);</div>
<div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;};</div>
<div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;```</div>
<div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;</div>
<div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;**Pros**</div>
<div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;</div>
<div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;Overloading can make code more intuitive by allowing an identically-named function to take different arguments. It may be necessary for templatized code, and it can be convenient for Visitors.</div>
<div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;</div>
<div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;**Cons**</div>
<div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;</div>
<div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;If a function is overloaded by the argument types alone, a reader may have to understand C++&#39;s complex matching rules in order to tell what&#39;s going on. Also many people are confused by the semantics of inheritance if a derived class overrides only some of the variants of a function.</div>
<div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;</div>
<div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;**Decision**</div>
<div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;</div>
<div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;If you want to overload a function, consider qualifying the name with some information about the arguments, e.g., `AppendString()`, `AppendInt()` rather than just `Append()`. If you are overloading a function to support variable number of arguments of the same type, consider making it take a `std::vector` so that the user can use an [initializer list](#braced-initializer-list) to specify the arguments.</div>
<div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;</div>
<div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;### Default Arguments</div>
<div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;</div>
<div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;&gt; Default arguments are allowed on non-virtual functions when the default is guaranteed to always have the same value. Follow the same restrictions as for [function overloading](#function-overloading), and prefer overloaded functions if the readability gained with default arguments doesn&#39;t outweigh the downsides below.</div>
<div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;</div>
<div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;**Pros**</div>
<div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;</div>
<div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;Often you have a function that uses default values, but occasionally you want to override the defaults. Default parameters allow an easy way to do this without having to define many functions for the rare exceptions. Compared to overloading the function, default arguments have a cleaner syntax, with less boilerplate and a clearer distinction between &#39;required&#39; and &#39;optional&#39; arguments.</div>
<div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;</div>
<div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;**Cons**</div>
<div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;</div>
<div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;Defaulted arguments are another way to achieve the semantics of overloaded functions, so all the [reasons not to overload functions](#function-overloading) apply.</div>
<div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;</div>
<div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;The defaults for arguments in a virtual function call are determined by the static type of the target object, and there&#39;s no guarantee that all overrides of a given function declare the same defaults.</div>
<div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;</div>
<div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;Default parameters are re-evaluated at each call site, which can bloat the generated code. Readers may also expect the default&#39;s value to be fixed at the declaration instead of varying at each call.</div>
<div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;</div>
<div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;Function pointers are confusing in the presence of default arguments, since the function signature often doesn&#39;t match the call signature. Adding function overloads avoids these problems.</div>
<div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;</div>
<div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;**Decision**</div>
<div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;</div>
<div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;Default arguments are banned on virtual functions, where they don&#39;t work properly, and in cases where the specified default might not evaluate to the same value depending on when it was evaluated. (For example, don&#39;t write `void f(int n = counter++);`.)</div>
<div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;</div>
<div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;In some other cases, default arguments can improve the readability of their function declarations enough to overcome the downsides above, so they are allowed. When in doubt, use overloads.</div>
<div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;</div>
<div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;### Trailing Return Type Syntax</div>
<div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;</div>
<div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;&gt; Use trailing return types only where using the ordinary syntax (leading return types) is impractical or much less readable.</div>
<div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;</div>
<div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;**Definition**</div>
<div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;</div>
<div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;C++ allows two different forms of function declarations. In the older form, the return type appears before the function name. For example:</div>
<div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;</div>
<div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;```c++</div>
<div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;int foo(int x);</div>
<div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;```</div>
<div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;</div>
<div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;The new form, introduced in C++11, uses the `auto` keyword before the function name and a trailing return type after the argument list. For example, the declaration above could equivalently be written:</div>
<div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;</div>
<div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;```c++</div>
<div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;auto foo(int x) -&gt; int;</div>
<div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;```</div>
<div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;</div>
<div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;The trailing return type is in the function&#39;s scope. This doesn&#39;t make a difference for a simple case like `int` but it matters for more complicated cases, like types declared in class scope or types written in terms of the function parameters.</div>
<div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;</div>
<div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;**Pros**</div>
<div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;</div>
<div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;Trailing return types are the only way to explicitly specify the return type of a [lambda expression](#lambda-expressions). In some cases the compiler is able to deduce a lambda&#39;s return type, but not in all cases. Even when the compiler can deduce it automatically, sometimes specifying it explicitly would be clearer for readers.</div>
<div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;</div>
<div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;Sometimes it&#39;s easier and more readable to specify a return type after the function&#39;s parameter list has already appeared. This is particularly true when the return type depends on template parameters. For example:</div>
<div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;</div>
<div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;```c++</div>
<div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;template &lt;class T, class U&gt; auto add(T t, U u) -&gt; decltype(t + u);</div>
<div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;```</div>
<div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;</div>
<div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;versus</div>
<div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;</div>
<div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;```c++</div>
<div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;template &lt;class T, class U&gt; decltype(declvall&lt;T&gt;() + declval&lt;U&gt;()) add(T t, U u);</div>
<div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;```</div>
<div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;</div>
<div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;**Cons**</div>
<div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;</div>
<div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;Trailing return type syntax is relatively new and it has no analogue in C++-like languages like C and Java, so some readers may find it unfamiliar.</div>
<div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;</div>
<div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;Existing code bases have an enormous number of function declarations that aren&#39;t going to get changed to use the new syntax, so the realistic choices are using the old syntax only or using a mixture of the two. Using a single version is better for uniformity of style.</div>
<div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;</div>
<div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;**Decision**</div>
<div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;</div>
<div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;In most cases, continue to use the older style of function declaration where the return type goes before the function name. Use the new trailing-return-type form only in cases where it&#39;s required (such as lambdas) or where, by putting the type after the function&#39;s parameter list, it allows you to write the type in a much more readable way. The latter case should be rare; it&#39;s mostly an issue in fairly complicated template code, which is [discouraged in most cases](#template-metaprogramming).</div>
<div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;</div>
<div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;## Google-Specific Magic</div>
<div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;</div>
<div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;There are various tricks and utilities that we use to make C++ code more robust, and various ways we use C++ that may differ from what you see elsewhere.</div>
<div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;</div>
<div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;### Ownership and Smart Pointers</div>
<div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;</div>
<div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;&gt; Prefer to have single, fixed owners for dynamically allocated objects. Prefer to transfer ownership with smart pointers.</div>
<div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;</div>
<div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;**Definition**</div>
<div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;</div>
<div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;&quot;Ownership&quot; is a bookkeeping technique for managing dynamically allocated memory (and other resources). The owner of a dynamically allocated object is an object or function that is responsible for ensuring that it is deleted when no longer needed. Ownership can sometimes be shared, in which case the last owner is typically responsible for deleting it. Even when ownership is not shared, it can be transferred from one piece of code to another.</div>
<div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;</div>
<div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;&quot;Smart&quot; pointers are classes that act like pointers, e.g. by overloading the `*` and `-&gt;` operators. Some smart pointer types can be used to automate ownership bookkeeping, to ensure these responsibilities are met. [`std::unique_ptr`][cppref:unique_ptr] is a smart pointer type introduced in C++11, which expresses exclusive ownership of a dynamically allocated object; the object is deleted when the `std::unique_ptr` goes out of scope. It cannot be copied, but can be *moved* to represent ownership transfer. [`std::shared_ptr`][cppref:shared_ptr] is a smart pointer type that expresses shared ownership of a dynamically allocated object. `std::shared_ptr`s can be copied; ownership of the object is shared among all copies, and the object is deleted when the last `std::shared_ptr` is destroyed.</div>
<div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;</div>
<div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160; [cppref:unique_ptr]: http:<span class="comment">//en.cppreference.com/w/cpp/memory/unique_ptr</span></div>
<div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160; [cppref:shared_ptr]: http:<span class="comment">//en.cppreference.com/w/cpp/memory/shared_ptr</span></div>
<div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;</div>
<div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;**Pros**</div>
<div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;</div>
<div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;* It&#39;s virtually impossible to manage dynamically allocated memory without some sort of ownership logic.</div>
<div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;* Transferring ownership of an object can be cheaper than copying it (if copying it is even possible).</div>
<div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;* Transferring ownership can be simpler than &#39;borrowing&#39; a pointer or reference, because it reduces the need to coordinate the lifetime of the object between the two users.</div>
<div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;* Smart pointers can improve readability by making ownership logic explicit, self-documenting, and unambiguous.</div>
<div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;* Smart pointers can eliminate manual ownership bookkeeping, simplifying the code and ruling out large classes of errors.</div>
<div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;* For const objects, shared ownership can be a simple and efficient alternative to deep copying.</div>
<div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;</div>
<div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;**Cons**</div>
<div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;* Ownership must be represented and transferred via pointers (whether smart or plain). Pointer semantics are more complicated than value semantics, especially in APIs: you have to worry not just about ownership, but also aliasing, lifetime, and mutability, among other issues.</div>
<div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;* The performance costs of value semantics are often overestimated, so the performance benefits of ownership transfer might not justify the readability and complexity costs.</div>
<div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;* APIs that transfer ownership force their clients into a single memory management model.</div>
<div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;* Code using smart pointers is less explicit about where the resource releases take place.</div>
<div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;* `std::unique_ptr` expresses ownership transfer using C++11&#39;s move semantics, which are relatively new and may confuse some programmers.</div>
<div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;* Shared ownership can be a tempting alternative to careful ownership design, obfuscating the design of a system.</div>
<div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;* Shared ownership requires explicit bookkeeping at run-time, which can be costly.</div>
<div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;* In some cases (e.g. cyclic references), objects with shared ownership may never be deleted.</div>
<div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;* Smart pointers are not perfect substitutes for plain pointers.</div>
<div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;</div>
<div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;**Decision**</div>
<div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;</div>
<div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;If dynamic allocation is necessary, prefer to keep ownership with the code that allocated it. If other code needs access to the object, consider passing it a copy, or passing a pointer or reference without transferring ownership. Prefer to use `std::unique_ptr` to make ownership transfer explicit. For example:</div>
<div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;</div>
<div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;```c++</div>
<div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;std::unique_ptr&lt;Foo&gt; FooFactory();</div>
<div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;void FooConsumer(std::unique_ptr&lt;Foo&gt; ptr);</div>
<div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;```</div>
<div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;</div>
<div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;Do not design your code to use shared ownership without a very good reason. One such reason is to avoid expensive copy operations, but you should only do this if the performance benefits are significant, and the underlying object is immutable (i.e. `std::shared_ptr&lt;const Foo&gt;`&gt;). If you do use shared ownership, prefer to use `std::shared_ptr`.</div>
<div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;</div>
<div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;Never use `std::auto_ptr`. Instead, use `std::unique_ptr`.</div>
<div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;</div>
<div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;### cpplint</div>
<div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;</div>
<div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;&gt; Use `cpplint.py` to detect style errors.</div>
<div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;</div>
<div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;`cpplint.py` is a tool that reads a source file and identifies many style errors. It is not perfect, and has both false positives and false negatives, but it is still a valuable tool. False positives can be ignored by putting `<span class="comment">// NOLINT` at the end of the line or `// NOLINTNEXTLINE` in the previous line.</span></div>
<div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;</div>
<div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;Some projects have instructions on how to run `cpplint.py` from their project tools. If the project you are contributing to does not, you can download [`cpplint.py`](https:<span class="comment">//raw.githubusercontent.com/google/styleguide/gh-pages/cpplint/cpplint.py) separately.</span></div>
<div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;</div>
<div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;## Other C++ Features</div>
<div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;</div>
<div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;### Rvalue References</div>
<div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;</div>
<div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;&gt; Use rvalue references only to define move constructors and move assignment operators, or for perfect forwarding.</div>
<div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;</div>
<div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;**Definition**</div>
<div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;</div>
<div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;Rvalue references are a type of reference that can only bind to temporary objects. The syntax is similar to traditional reference syntax. For example, `void f(string&amp;&amp; s);` declares a function whose argument is an rvalue reference to a string.</div>
<div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;</div>
<div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;**Pros**</div>
<div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;</div>
<div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;* Defining a move constructor (a constructor taking an rvalue reference to the class type) makes it possible to move a value instead of copying it. If `v1` is a `std::vector&lt;string&gt;`, for example, then `auto v2(std::move(v1))` will probably just result in some simple pointer manipulation instead of copying a large amount of data. In some cases this can result in a major performance improvement.</div>
<div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;* Rvalue references make it possible to write a generic function wrapper that forwards its arguments to another function, and works whether or not its arguments are temporary objects. (This is sometimes called &quot;perfect forwarding&quot;.)</div>
<div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;* Rvalue references make it possible to implement types that are movable but not copyable, which can be useful for types that have no sensible definition of copying but where you might still want to pass them as function arguments, put them in containers, etc.</div>
<div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;* `std::move` is necessary to make effective use of some standard-library types, such as `std::unique_ptr`.</div>
<div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;</div>
<div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;**Cons**</div>
<div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;* Rvalue references are a relatively new feature (introduced as part of C++11), and not yet widely understood. Rules like reference collapsing, and automatic synthesis of move constructors, are complicated.</div>
<div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;</div>
<div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;**Decision**</div>
<div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;</div>
<div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;Use rvalue references only to define move constructors and move assignment operators (as described in [Copyable and Movable Types](#copyable-and-movable-types) and, in conjunction with [`std::forward`][cppref:std::forward], to support perfect forwarding. You may use `std::move` to express moving a value from one object to another rather than copying it.</div>
<div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;</div>
<div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160; [cppref:std::forward]: http:<span class="comment">//en.cppreference.com/w/cpp/utility/forward</span></div>
<div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;</div>
<div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;### Friends</div>
<div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;</div>
<div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;&gt; We allow use of `friend` classes and functions, within reason.</div>
<div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;</div>
<div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;Friends should usually be defined in the same file so that the reader does not have to look in another file to find uses of the <span class="keyword">private</span> members of a class. A common use of `friend` is to have a `FooBuilder` class be a friend of `Foo` so that it can construct the inner state of `Foo` correctly, without exposing this state to the world. In some cases it may be useful to make a unittest class a friend of the class it tests.</div>
<div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;</div>
<div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;Friends extend, but do not break, the encapsulation boundary of a class. In some cases this is better than making a member <span class="keyword">public</span> when you want to give only one other class access to it. However, most classes should interact with other classes solely through their <span class="keyword">public</span> members.</div>
<div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;</div>
<div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;<span class="preprocessor">### Exceptions</span></div>
<div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;&gt; We do not use C++ exceptions.</div>
<div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;</div>
<div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;**Pros**</div>
<div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;</div>
<div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;* Exceptions allow higher levels of an application to decide how to handle &quot;can&#39;t happen&quot; failures in deeply nested functions, without the obscuring and error-prone bookkeeping of error codes.</div>
<div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;* Exceptions are used by most other modern languages. Using them in C++ would make it more consistent with Python, Java, and the C++ that others are familiar with.</div>
<div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;* Some third-party C++ libraries use exceptions, and turning them off internally makes it harder to integrate with those libraries.</div>
<div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;* Exceptions are the only way for a constructor to fail. We can simulate this with a factory function or an `Init()` method, but these require heap allocation or a new &quot;invalid&quot; state, respectively.</div>
<div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;* Exceptions are really handy in testing frameworks.</div>
<div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;</div>
<div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;**Cons**</div>
<div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;</div>
<div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;* When you add a `throw` statement to an existing function, you must examine all of its transitive callers. Either they must make at least the basic exception safety guarantee, or they must never catch the exception and be happy with the program terminating as a result. For instance, if `f()` calls `g()` calls `h()`, and `h` throws an exception that `f` catches, `g` has to be careful or it may not clean up properly.</div>
<div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;* More generally, exceptions make the control flow of programs difficult to evaluate by looking at code: functions may return in places you don&#39;t expect. This causes maintainability and debugging difficulties. You can minimize this cost via some rules on how and where exceptions can be used, but at the cost of more that a developer needs to know and understand.</div>
<div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;* Exception safety requires both RAII and different coding practices. Lots of supporting machinery is needed to make writing correct exception-safe code easy. Further, to avoid requiring readers to understand the entire call graph, exception-safe code must isolate logic that writes to persistent state into a &quot;commit&quot; phase. This will have both benefits and costs (perhaps where you&#39;re forced to obfuscate code to isolate the commit). Allowing exceptions would force us to always pay those costs even when they&#39;re not worth it.</div>
<div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;* Turning on exceptions adds data to each binary produced, increasing compile time (probably slightly) and possibly increasing address space pressure.</div>
<div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;* The availability of exceptions may encourage developers to throw them when they are not appropriate or recover from them when it&#39;s not safe to do so. For example, invalid user input should not cause exceptions to be thrown. We would need to make the style guide even longer to document these restrictions!</div>
<div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;</div>
<div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;**Decision**</div>
<div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;</div>
<div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;On their face, the benefits of using exceptions outweigh the costs, especially in new projects. However, for existing code, the introduction of exceptions has implications on all dependent code. If exceptions can be propagated beyond a new project, it also becomes problematic to integrate the new project into existing exception-free code. Because most existing C++ code at Google is not prepared to deal with exceptions, it is comparatively difficult to adopt new code that generates exceptions.</div>
<div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;</div>
<div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;Given that Google&#39;s existing code is not exception-tolerant, the costs of using exceptions are somewhat greater than the costs in a new project. The conversion process would be slow and error-prone. We don&#39;t believe that the available alternatives to exceptions, such as error codes and assertions, introduce a significant burden.</div>
<div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;</div>
<div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;Our advice against using exceptions is not predicated on philosophical or moral grounds, but practical ones. Because we&#39;d like to use our open-source projects at Google and it&#39;s difficult to do so if those projects use exceptions, we need to advise against exceptions in Google open-source projects as well. Things would probably be different if we had to do it all over again from scratch.</div>
<div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;</div>
<div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;This prohibition also applies to the exception-related features added in C++11, such as `noexcept`, `std::exception_ptr`, and `std::nested_exception`.</div>
<div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;</div>
<div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;<span class="preprocessor">### Run-Time Type Information (RTTI)</span></div>
<div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;&gt; Avoid using Run Time Type Information (RTTI).</div>
<div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;</div>
<div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;**Definition**</div>
<div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;</div>
<div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;RTTI allows a programmer to query the C++ class of an object at run time. This is done by use of `typeid` or `dynamic_cast`.</div>
<div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;</div>
<div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;**Cons**</div>
<div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;</div>
<div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;Querying the type of an object at run-time frequently means a design problem. Needing to know the type of an object at runtime is often an indication that the design of your class hierarchy is flawed.</div>
<div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;</div>
<div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;Undisciplined use of RTTI makes code hard to maintain. It can lead to type-based decision trees or switch statements scattered throughout the code, all of which must be examined when making further changes.</div>
<div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;</div>
<div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;**Pros**</div>
<div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;</div>
<div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;The standard alternatives to RTTI (described below) require modification or redesign of the class hierarchy in question. Sometimes such modifications are infeasible or undesirable, particularly in widely-used or mature code.</div>
<div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;</div>
<div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;RTTI can be useful in some unit tests. For example, it is useful in tests of factory classes where the test has to verify that a newly created object has the expected dynamic type. It is also useful in managing the relationship between objects and their mocks.</div>
<div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;</div>
<div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;RTTI is useful when considering multiple abstract objects. Consider</div>
<div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;</div>
<div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;```c++</div>
<div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;bool Base::Equal(Base* other) = 0;</div>
<div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;bool Derived::Equal(Base* other) {</div>
<div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;  Derived* that = <span class="keyword">dynamic_cast&lt;</span>Derived*<span class="keyword">&gt;</span>(other);</div>
<div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;  <span class="keywordflow">if</span> (that == NULL)</div>
<div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;  ...</div>
<div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;}</div>
<div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;```</div>
<div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;</div>
<div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;**Decision**</div>
<div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;</div>
<div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;RTTI has legitimate uses but is prone to abuse, so you</div>
<div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;must be careful when <span class="keyword">using</span> it. You may use it freely in</div>
<div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;unittests, but avoid it when possible in other code. In</div>
<div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;particular, think twice before <span class="keyword">using</span> RTTI in <span class="keyword">new</span> code. If</div>
<div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;you find yourself needing to write code that behaves</div>
<div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;differently based on the <span class="keyword">class </span>of an object, consider one</div>
<div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;of the following alternatives to querying the type:</div>
<div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;</div>
<div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;* Virtual methods are the preferred way of executing different code paths depending on a specific subclass type. This puts the work within the object itself.</div>
<div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;* If the work belongs outside the object and instead in some processing code, consider a double-dispatch solution, such as the Visitor design pattern. This allows a facility outside the object itself to determine the type of class using the built-in type system.</div>
<div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;</div>
<div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;When the logic of a program guarantees that a given instance of a base class is in fact an instance of a particular derived class, then a `dynamic_cast` may be used freely on the object. Usually one can use a `static_cast` as an alternative in such situations.</div>
<div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;</div>
<div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;Decision trees based on type are a strong indication that your code is on the wrong track.</div>
<div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;</div>
<div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;```c++</div>
<div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;if (typeid(*data) == typeid(D1)) {</div>
<div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;  ...</div>
<div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">typeid</span>(*data) == <span class="keyword">typeid</span>(D2)) {</div>
<div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;  ...</div>
<div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">typeid</span>(*data) == <span class="keyword">typeid</span>(D3)) {</div>
<div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;...</div>
<div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;```</div>
<div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;</div>
<div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;Code such as <span class="keyword">this</span> usually breaks when additional subclasses are added to the <span class="keyword">class </span>hierarchy. Moreover, when properties of a subclass change, it is difficult to find and modify all the affected code segments.</div>
<div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;</div>
<div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;Do not hand-implement an RTTI-like workaround. The arguments against RTTI apply just as much to workarounds like class hierarchies with type tags. Moreover, workarounds disguise your true intent.</div>
<div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;</div>
<div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;### Casting</div>
<div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;</div>
<div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;&gt; Use C++-style casts like `static_cast&lt;float&gt;(double_value)`, or brace initialization for conversion of arithmetic types like `int64 y = int64{1} &lt;&lt; 42`. Do not use cast formats like `<span class="keywordtype">int</span> y = (int)x` or `<span class="keywordtype">int</span> y = <span class="keywordtype">int</span>(x)` (but the latter is okay when invoking a constructor of a <span class="keyword">class </span>type).</div>
<div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;</div>
<div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;**Definition**</div>
<div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;</div>
<div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;C++ introduced a different cast system from C that distinguishes the types of cast operations.</div>
<div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;</div>
<div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;**Pros**</div>
<div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;</div>
<div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;The problem with C casts is the ambiguity of the operation; sometimes you are doing a *conversion* (e.g., `(int)3.5`) and sometimes you are doing a *cast* (e.g., `(<span class="keywordtype">int</span>)&quot;hello&quot;`). Brace initialization and C++ casts can often help avoid this ambiguity. Additionally, C++ casts are more visible when searching for them.</div>
<div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;</div>
<div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;**Cons**</div>
<div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;The C++-style cast syntax is verbose and cumbersome.</div>
<div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;</div>
<div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;**Decision**</div>
<div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;</div>
<div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;Do not use C-style casts. Instead, use these C++-style casts when explicit type conversion is necessary.</div>
<div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;</div>
<div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;* Use brace initialization to convert arithmetic types (e.g. `int64{x}`). This is the safest approach because code will not compile <span class="keywordflow">if</span> conversion can result in information loss. The syntax is also concise.</div>
<div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;* Use `static_cast` as the equivalent of a C-style cast that does value conversion, when you need to explicitly up-cast a pointer from a <span class="keyword">class</span> to its superclass, or when you need to explicitly cast a pointer from a superclass to a subclass. In <span class="keyword">this</span> last <span class="keywordflow">case</span>, you must be sure your <span class="keywordtype">object</span> is actually an instance of the subclass.</div>
<div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;* Use `const_cast` to <span class="keyword">remove</span> the `<span class="keyword">const</span>` qualifier (see [<span class="keyword">const</span>](#use-of-<span class="keyword">const</span>)).</div>
<div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;* Use `reinterpret_cast` to <span class="keywordflow">do</span> unsafe conversions of pointer types to and from integer and other pointer types. Use <span class="keyword">this</span> only <span class="keywordflow">if</span> you know what you are doing and you understand the aliasing issues.</div>
<div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;</div>
<div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;See the [RTTI section](#run-time-type-information-rtti) <span class="keywordflow">for</span> guidance on the use of `dynamic_cast`.</div>
<div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;</div>
<div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;### Streams</div>
<div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160;</div>
<div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;&gt; Use streams where appropriate, and stick to <span class="stringliteral">&quot;simple&quot;</span></div>
<div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;usages.</div>
<div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;</div>
<div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;**Definition**</div>
<div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;</div>
<div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;Streams are the standard I/O abstraction in C++, as exemplified by the standard header `&lt;iostream&gt;`. They are widely used in Google code, but only <span class="keywordflow">for</span> debug logging and test diagnostics.</div>
<div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;</div>
<div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;**Pros**</div>
<div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;</div>
<div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;The `&lt;&lt;`` and `&gt;&gt;` stream operators provide an API <span class="keywordflow">for</span> formatted I/O that is easily learned, portable, reusable, and extensible. `printf`, by contrast, doesn<span class="stringliteral">&#39;t even support `string`, to say nothing of user-defined types, and is very difficult to use portably. `printf` also obliges you to choose among the numerous slightly different versions of that function, and navigate the dozens of conversion specifiers.</span></div>
<div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;<span class="stringliteral">Streams provide first-class support for console I/O via `std::cin`, `std::cout`, `std::cerr`, and `std::clog`. The C APIs do as well, but are hampered by the need to manually buffer the input.</span></div>
<div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;<span class="stringliteral">**Cons**</span></div>
<div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;<span class="stringliteral">* Stream formatting can be configured by mutating the state of the stream. Such mutations are persistent, so the behavior of your code can be affected by the entire previous history of the stream, unless you go out of your way to restore it to a known state every time other code might have touched it. User code can not only modify the built-in state, it can add new state variables and behaviors through a registration system.</span></div>
<div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;<span class="stringliteral">* It is difficult to precisely control stream output, due to the above issues, the way code and data are mixed in streaming code, and the use of operator overloading (which may select a different overload than you expect).</span></div>
<div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;<span class="stringliteral">* The practice of building up output through chains of `&lt;&lt;` operators interferes with internationalization, because it bakes word order into the code, and streams&#39;</span> support <span class="keywordflow">for</span> localization is &lt;a href=<span class="stringliteral">&quot;http://www.boost.org/doc/libs/1_48_0/libs/locale/doc/html/rationale.html#rationale_why&quot;</span>&gt;flawed&lt;/a&gt;.</div>
<div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;* The streams API is subtle and complex, so programmers must develop experience with it in order to use it effectively. However, streams were historically banned in Google code (except <span class="keywordflow">for</span> logging and diagnostics), so Google engineers tend not to have that experience. Consequently, streams-based code is likely to be less readable and maintainable by Googlers than code based on more familiar abstractions.</div>
<div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;* Resolving the many overloads of `&lt;&lt;` is extremely costly <span class="keywordflow">for</span> the compiler. When used pervasively in a large code base, it can consume as much as 20% of the parsing and semantic analysis time.</div>
<div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;</div>
<div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;**Decision**</div>
<div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;</div>
<div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;Use streams only when they are the best tool <span class="keywordflow">for</span> the job. This is typically the <span class="keywordflow">case</span> when the I/O is ad-hoc, local, human-readable, and targeted at other developers rather than end-users. Be consistent with the code around you, and with the codebase as a whole; <span class="keywordflow">if</span> there<span class="stringliteral">&#39;s an established tool for your problem, use that tool instead.</span></div>
<div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;<span class="stringliteral">Avoid using streams for I/O that faces external users or handles untrusted data. Instead, find and use the appropriate templating libraries to handle issues like internationalization, localization, and security hardening.</span></div>
<div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160;<span class="stringliteral">If you do use streams, avoid the stateful parts of the streams API (other than error state), such as `imbue()`, `xalloc()`, and `register_callback()`. Use explicit formatting functions rather than stream manipulators or formatting flags to control formatting details such as number base, precision, or padding.</span></div>
<div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;<span class="stringliteral">Overload `&lt;&lt;` as a streaming operator for your type only if your type represents a value, and `&lt;&lt;` writes out a human-readable string representation of that value. Avoid exposing implementation details in the output of `&lt;&lt;`; if you need to print object internals for debugging, use named functions instead (a method named `DebugString()` is the most common convention).</span></div>
<div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;<span class="stringliteral">### Preincrement and Predecrement</span></div>
<div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;<span class="stringliteral">&gt; Use prefix form (`++i`) of the increment and decrement operators with iterators and other template objects.</span></div>
<div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;<span class="stringliteral">**Definition**</span></div>
<div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;<span class="stringliteral">When a variable is incremented (`++i` or `i++`) or decremented (`--i` or `i--`) and the value of the expression is not used, one must decide whether to preincrement (decrement) or postincrement (decrement).</span></div>
<div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;<span class="stringliteral">**Pros**</span></div>
<div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;<span class="stringliteral">When the return value is ignored, the &quot;pre&quot; form (`++i`) is never less efficient than the &quot;post&quot; form (`i++`), and is often more efficient. This is because post-increment (or decrement) requires a copy of `i` to be made, which is the value of the expression. If `i` is an iterator or other non-scalar type, copying `i` could be expensive. Since the two types of increment behave the same when the value is ignored, why not just always pre-increment?</span></div>
<div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;<span class="stringliteral">**Cons**</span></div>
<div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;<span class="stringliteral">The tradition developed, in C, of using post-increment when the expression value is not used, especially in `for` loops. Some find post-increment easier to read, since the &quot;subject&quot; (`i`) precedes the &quot;verb&quot; (`++`), just like in English.</span></div>
<div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;<span class="stringliteral">**Decision**</span></div>
<div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;<span class="stringliteral">For simple scalar (non-object) values there is no reason to prefer one form and we allow either. For iterators and other template types, use pre-increment.</span></div>
<div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;<span class="stringliteral">### Use of const</span></div>
<div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;<span class="stringliteral">&gt; Use `const` whenever it makes sense. With C++11, `constexpr` is a better choice for some uses of const.</span></div>
<div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;<span class="stringliteral">**Definition**</span></div>
<div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;<span class="stringliteral">Declared variables and parameters can be preceded by the keyword `const` to indicate the variables are not changed (e.g., `const int foo`). Class functions can have the `const` qualifier to indicate the function does not change the state of the class member variables (e.g., `class Foo { int Bar(char c) const; };`).</span></div>
<div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;<span class="stringliteral">**Pros**</span></div>
<div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;<span class="stringliteral">Easier for people to understand how variables are being used. Allows the compiler to do better type checking, and, conceivably, generate better code. Helps people convince themselves of program correctness because they know the functions they call are limited in how they can modify your variables. Helps people know what functions are safe to use without locks in multi-threaded programs.</span></div>
<div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;<span class="stringliteral">**Cons**</span></div>
<div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;<span class="stringliteral">`const` is viral: if you pass a `const` variable to a function, that function must have `const` in its prototype (or the variable will need a `const_cast`). This can be a particular problem when calling library functions.</span></div>
<div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;<span class="stringliteral">**Decision**</span></div>
<div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;<span class="stringliteral">`const` variables, data members, methods and arguments add a level of compile-time type checking; it is better to detect errors as soon as possible. Therefore we strongly recommend that you use `const` whenever it makes sense to do so:</span></div>
<div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;<span class="stringliteral">* If a function guarantees that it will not modify an argument passed by reference or by pointer, the corresponding function parameter should be a reference-to-const (`const T&amp;`) or pointer-to-const (`const T*`), respectively.</span></div>
<div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;<span class="stringliteral">* Declare methods to be `const` whenever possible. Accessors should almost always be `const`. Other methods should be const if they do not modify any data members, do not call any non-`const` methods, and do not return a non-`const` pointer or non-`const` reference to a data member.</span></div>
<div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;<span class="stringliteral">* Consider making data members `const` whenever they do not need to be modified after construction.</span></div>
<div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;<span class="stringliteral">The `mutable` keyword is allowed but is unsafe when used with threads, so thread safety should be carefully considered first.</span></div>
<div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01376"></a><span class="lineno"> 1376</span>&#160;<span class="stringliteral">#### Where to put the const</span></div>
<div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;<span class="stringliteral">Some people favor the form `int const *foo` to `const int* foo`. They argue that this is more readable because it&#39;</span>s more consistent: it keeps the rule that `<span class="keyword">const</span>` always follows the <span class="keywordtype">object</span> it<span class="stringliteral">&#39;s describing. However, this consistency argument doesn&#39;</span>t apply in codebases with few deeply-nested pointer expressions since most `<span class="keyword">const</span>` expressions have only one `<span class="keyword">const</span>`, and it applies to the underlying value. In such cases, there<span class="stringliteral">&#39;s no consistency to maintain. Putting the `const` first is arguably more readable, since it follows English in putting the &quot;adjective&quot; (`const`) before the &quot;noun&quot; (`int`).</span></div>
<div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;<span class="stringliteral">That said, while we encourage putting `const` first, we do not require it. But be consistent with the code around you!</span></div>
<div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;<span class="stringliteral">### Use of constexpr</span></div>
<div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;<span class="stringliteral">&gt; In C++11, use `constexpr` to define true constants or to ensure constant initialization.</span></div>
<div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160;<span class="stringliteral">**Definition**</span></div>
<div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;<span class="stringliteral">Some variables can be declared `constexpr` to indicate the variables are true constants, i.e. fixed at compilation/link time. Some functions and constructors can be declared `constexpr` which enables them to be used in defining a `constexpr` variable.</span></div>
<div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;<span class="stringliteral">**Pros**</span></div>
<div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;<span class="stringliteral">Use of `constexpr` enables definition of constants with floating-point expressions rather than just literals; definition of constants of user-defined types; and definition of constants with function calls.</span></div>
<div class="line"><a name="l01393"></a><span class="lineno"> 1393</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;<span class="stringliteral">**Cons**</span></div>
<div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;<span class="stringliteral">Prematurely marking something as constexpr may cause migration problems if later on it has to be downgraded. Current restrictions on what is allowed in constexpr functions and constructors may invite obscure workarounds in these definitions.</span></div>
<div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;<span class="stringliteral">**Decision**</span></div>
<div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;<span class="stringliteral">`constexpr` definitions enable a more robust specification of the constant parts of an interface. Use `constexpr` to specify true constants and the functions that support their definitions. Avoid complexifying function definitions to enable their use with `constexpr`. Do not use `constexpr` to force inlining.</span></div>
<div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;<span class="stringliteral">### Integer Types</span></div>
<div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;<span class="stringliteral">Of the built-in C++ integer types, the only one used is `int`. If a program needs a variable of a different size, use a precise-width integer type from `&lt;stdint.h&gt;`, such as `int16_t`. If your variable represents a value that could ever be greater than or equal to 2^31 (2GiB), use a 64-bit type such as `int64_t`. Keep in mind that even if your value won&#39;</span>t ever be too large <span class="keywordflow">for</span> an `<span class="keywordtype">int</span>`, it may be used in intermediate calculations which may require a larger type. When in doubt, choose a larger type.</div>
<div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;</div>
<div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;**Definition**</div>
<div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;</div>
<div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;C++ does not specify the sizes of its integer types. Typically people assume that `<span class="keywordtype">short</span>` is 16 bits, `<span class="keywordtype">int</span>` is 32 bits, `<span class="keywordtype">long</span>` is 32 bits and `<span class="keywordtype">long</span> <span class="keywordtype">long</span>` is 64 bits.</div>
<div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;</div>
<div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;**Pros**</div>
<div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;</div>
<div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;Uniformity of declaration.</div>
<div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;</div>
<div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;**Cons**</div>
<div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;</div>
<div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;The sizes of integral types in C++ can vary based on compiler and architecture.</div>
<div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;</div>
<div class="line"><a name="l01418"></a><span class="lineno"> 1418</span>&#160;**Decision**</div>
<div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160;</div>
<div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;`&lt;stdint.h&gt;` defines types like `int16_t`, `uint32_t`, `int64_t`, etc. You should always use those in preference to `<span class="keywordtype">short</span>`, `<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>` and the like, when you need a guarantee on the size of an integer. Of the C integer types, only `<span class="keywordtype">int</span>` should be used. When appropriate, you are welcome to use standard types like `<span class="keywordtype">size_t</span>` and `ptrdiff_t`.</div>
<div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;</div>
<div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;We use `<span class="keywordtype">int</span>` very often, <span class="keywordflow">for</span> integers we know are not going to be too big, e.g., loop counters. Use plain old `<span class="keywordtype">int</span>` <span class="keywordflow">for</span> such things. You should assume that an `<span class="keywordtype">int</span>` is at least 32 bits, but don<span class="stringliteral">&#39;t assume that it has more than 32 bits. If you need a 64-bit integer type, use `int64_t` or `uint64_t`.</span></div>
<div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;<span class="stringliteral">For integers we know can be &quot;big&quot;, use `int64_t`.</span></div>
<div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;<span class="stringliteral">You should not use the unsigned integer types such as `uint32_t`, unless there is a valid reason such as representing a bit pattern rather than a number, or you need defined overflow modulo 2^N. In particular, do not use unsigned types to say a number will never be negative. Instead, use assertions for this.</span></div>
<div class="line"><a name="l01427"></a><span class="lineno"> 1427</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01428"></a><span class="lineno"> 1428</span>&#160;<span class="stringliteral">If your code is a container that returns a size, be sure to use a type that will accommodate any possible usage of your container. When in doubt, use a larger type rather than a smaller type.</span></div>
<div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01430"></a><span class="lineno"> 1430</span>&#160;<span class="stringliteral">Use care when converting integer types. Integer</span></div>
<div class="line"><a name="l01431"></a><span class="lineno"> 1431</span>&#160;<span class="stringliteral">conversions and promotions can cause non-intuitive</span></div>
<div class="line"><a name="l01432"></a><span class="lineno"> 1432</span>&#160;<span class="stringliteral">behavior.</span></div>
<div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160;<span class="stringliteral">#### On Unsigned Integers</span></div>
<div class="line"><a name="l01435"></a><span class="lineno"> 1435</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01436"></a><span class="lineno"> 1436</span>&#160;<span class="stringliteral">Some people, including some textbook authors, recommend using unsigned types to represent numbers that are never negative. This is intended as a form of self-documentation. However, in C, the advantages of such documentation are outweighed by the real bugs it can introduce. Consider:</span></div>
<div class="line"><a name="l01437"></a><span class="lineno"> 1437</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01438"></a><span class="lineno"> 1438</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l01439"></a><span class="lineno"> 1439</span>&#160;<span class="stringliteral">for (unsigned int i = foo.Length()-1; i &gt;= 0; --i) ...</span></div>
<div class="line"><a name="l01440"></a><span class="lineno"> 1440</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l01441"></a><span class="lineno"> 1441</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01442"></a><span class="lineno"> 1442</span>&#160;<span class="stringliteral">This code will never terminate! Sometimes gcc will notice this bug and warn you, but often it will not. Equally bad bugs can occur when comparing signed and unsigned variables. Basically, C&#39;</span>s type-promotion scheme causes <span class="keywordtype">unsigned</span> types to behave differently than one might expect.</div>
<div class="line"><a name="l01443"></a><span class="lineno"> 1443</span>&#160;</div>
<div class="line"><a name="l01444"></a><span class="lineno"> 1444</span>&#160;So, document that a variable is non-negative <span class="keyword">using</span> assertions. Don<span class="stringliteral">&#39;t use an unsigned type.</span></div>
<div class="line"><a name="l01445"></a><span class="lineno"> 1445</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01446"></a><span class="lineno"> 1446</span>&#160;<span class="stringliteral">### Preprocessor Macros</span></div>
<div class="line"><a name="l01447"></a><span class="lineno"> 1447</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01448"></a><span class="lineno"> 1448</span>&#160;<span class="stringliteral">&gt; Avoid defining macros, especially in headers; prefer inline functions, enums, and `const` variables. Name macros with a project-specific prefix. Do not use macros to define pieces of a C++ API.</span></div>
<div class="line"><a name="l01449"></a><span class="lineno"> 1449</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01450"></a><span class="lineno"> 1450</span>&#160;<span class="stringliteral">Macros mean that the code you see is not the same as the code the compiler sees. This can introduce unexpected behavior, especially since macros have global scope.</span></div>
<div class="line"><a name="l01451"></a><span class="lineno"> 1451</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01452"></a><span class="lineno"> 1452</span>&#160;<span class="stringliteral">The problems introduced by macros are especially severe when they are used to define pieces of a C++ API, and still more so for public APIs. Every error message from the compiler when developers incorrectly use that interface now must explain how the macros formed the interface. Refactoring and analysis tools have a dramatically harder time updating the interface. As a consequence, we specifically disallow using macros in this way. For example, avoid patterns like:</span></div>
<div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l01455"></a><span class="lineno"> 1455</span>&#160;<span class="stringliteral">class WOMBAT_TYPE(Foo) {</span></div>
<div class="line"><a name="l01456"></a><span class="lineno"> 1456</span>&#160;<span class="stringliteral">  // ...</span></div>
<div class="line"><a name="l01457"></a><span class="lineno"> 1457</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01458"></a><span class="lineno"> 1458</span>&#160;<span class="stringliteral"> public:</span></div>
<div class="line"><a name="l01459"></a><span class="lineno"> 1459</span>&#160;<span class="stringliteral">  EXPAND_PUBLIC_WOMBAT_API(Foo)</span></div>
<div class="line"><a name="l01460"></a><span class="lineno"> 1460</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01461"></a><span class="lineno"> 1461</span>&#160;<span class="stringliteral">  EXPAND_WOMBAT_COMPARISONS(Foo, ==, &lt;)</span></div>
<div class="line"><a name="l01462"></a><span class="lineno"> 1462</span>&#160;<span class="stringliteral">};</span></div>
<div class="line"><a name="l01463"></a><span class="lineno"> 1463</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l01464"></a><span class="lineno"> 1464</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01465"></a><span class="lineno"> 1465</span>&#160;<span class="stringliteral">Luckily, macros are not nearly as necessary in C++ as they are in C. Instead of using a macro to inline performance-critical code, use an inline function. Instead of using a macro to store a constant, use a `const` variable. Instead of using a macro to &quot;abbreviate&quot; a long variable name, use a reference. Instead of using a macro to conditionally compile code ... well, don&#39;</span>t <span class="keywordflow">do</span> that at all. It makes testing much more difficult.</div>
<div class="line"><a name="l01466"></a><span class="lineno"> 1466</span>&#160;</div>
<div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160;Macros can <span class="keywordflow">do</span> things these other techniques cannot, and you <span class="keywordflow">do</span> see them in the codebase, especially in the lower-level libraries. And some of their special features (like stringifying, concatenation, and so forth) are not available through the language proper. But before <span class="keyword">using</span> a macro, consider carefully whether there<span class="stringliteral">&#39;s a non-macro way to achieve the same result. If you need to use a macro to define an interface, contact your project leads to request a waiver of this rule.</span></div>
<div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01469"></a><span class="lineno"> 1469</span>&#160;<span class="stringliteral">The following usage pattern will avoid many problems with macros; if you use macros, follow it whenever possible:</span></div>
<div class="line"><a name="l01470"></a><span class="lineno"> 1470</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01471"></a><span class="lineno"> 1471</span>&#160;<span class="stringliteral">* Don&#39;</span>t define macros in a `.h` file.</div>
<div class="line"><a name="l01472"></a><span class="lineno"> 1472</span>&#160;* `#define` macros right before you use them, and `#undef` them right after.</div>
<div class="line"><a name="l01473"></a><span class="lineno"> 1473</span>&#160;* Do not just `#undef` an existing macro before replacing it with your own; instead, pick a name that<span class="stringliteral">&#39;s likely to be unique.</span></div>
<div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;<span class="stringliteral">* Try not to use macros that expand to unbalanced C++ constructs, or at least document that behavior well.</span></div>
<div class="line"><a name="l01475"></a><span class="lineno"> 1475</span>&#160;<span class="stringliteral">* Prefer not using `##` to generate function/class/variable names.</span></div>
<div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;<span class="stringliteral">Exporting macros from headers (i.e. defining them in a header without `#undef`ing them before the end of the header) is extremely strongly discouraged. If you do export a macro from a header, it must have a globally unique name. To achieve this, it must be named with a prefix consisting of your project&#39;</span>s <span class="keyword">namespace </span>name (but upper case).</div>
<div class="line"><a name="l01478"></a><span class="lineno"> 1478</span>&#160;</div>
<div class="line"><a name="l01479"></a><span class="lineno"> 1479</span>&#160;### 0 and nullptr/NULL</div>
<div class="line"><a name="l01480"></a><span class="lineno"> 1480</span>&#160;</div>
<div class="line"><a name="l01481"></a><span class="lineno"> 1481</span>&#160;&gt; Use `0` for integers, `0.0` for reals, `nullptr` (or `NULL`) for pointers, and `&#39;\0&#39;` for chars.</div>
<div class="line"><a name="l01482"></a><span class="lineno"> 1482</span>&#160;</div>
<div class="line"><a name="l01483"></a><span class="lineno"> 1483</span>&#160;Use `0` for integers and `0.0` for reals. This is not controversial.</div>
<div class="line"><a name="l01484"></a><span class="lineno"> 1484</span>&#160;</div>
<div class="line"><a name="l01485"></a><span class="lineno"> 1485</span>&#160;For pointers (address values), there is a choice between `0`, `NULL`, and `nullptr`. For projects that allow C++11 features, use `nullptr`. For C++03 projects, we prefer `NULL` because it looks like a pointer. In fact, some C++ compilers provide special definitions of `NULL` which enable them to give useful warnings, particularly in situations where `sizeof(NULL)` is not equal to `sizeof(0)`.</div>
<div class="line"><a name="l01486"></a><span class="lineno"> 1486</span>&#160;</div>
<div class="line"><a name="l01487"></a><span class="lineno"> 1487</span>&#160;Use `&#39;\0&#39;` for chars. This is the correct type and also makes code more readable.</div>
<div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160;</div>
<div class="line"><a name="l01489"></a><span class="lineno"> 1489</span>&#160;### sizeof</div>
<div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;</div>
<div class="line"><a name="l01491"></a><span class="lineno"> 1491</span>&#160;&gt; Prefer `sizeof(varname)` to `sizeof(type)`.</div>
<div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;</div>
<div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;Use `sizeof(varname)` when you take the size of a particular variable. `sizeof(varname)` will update appropriately if someone changes the variable type either now or later. You may use `sizeof(type)` for code unrelated to any particular variable, such as code that manages an external or internal data format where a variable of an appropriate C++ type is not convenient.</div>
<div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160;</div>
<div class="line"><a name="l01495"></a><span class="lineno"> 1495</span>&#160;**Good code**</div>
<div class="line"><a name="l01496"></a><span class="lineno"> 1496</span>&#160;</div>
<div class="line"><a name="l01497"></a><span class="lineno"> 1497</span>&#160;```c++</div>
<div class="line"><a name="l01498"></a><span class="lineno"> 1498</span>&#160;Struct data;</div>
<div class="line"><a name="l01499"></a><span class="lineno"> 1499</span>&#160;memset(&amp;data, 0, <span class="keyword">sizeof</span>(data));</div>
<div class="line"><a name="l01500"></a><span class="lineno"> 1500</span>&#160;```</div>
<div class="line"><a name="l01501"></a><span class="lineno"> 1501</span>&#160;</div>
<div class="line"><a name="l01502"></a><span class="lineno"> 1502</span>&#160;**Bad code**</div>
<div class="line"><a name="l01503"></a><span class="lineno"> 1503</span>&#160;</div>
<div class="line"><a name="l01504"></a><span class="lineno"> 1504</span>&#160;```c++</div>
<div class="line"><a name="l01505"></a><span class="lineno"> 1505</span>&#160;memset(&amp;data, 0, <span class="keyword">sizeof</span>(Struct));</div>
<div class="line"><a name="l01506"></a><span class="lineno"> 1506</span>&#160;```</div>
<div class="line"><a name="l01507"></a><span class="lineno"> 1507</span>&#160;</div>
<div class="line"><a name="l01508"></a><span class="lineno"> 1508</span>&#160;**Good code**</div>
<div class="line"><a name="l01509"></a><span class="lineno"> 1509</span>&#160;</div>
<div class="line"><a name="l01510"></a><span class="lineno"> 1510</span>&#160;</div>
<div class="line"><a name="l01511"></a><span class="lineno"> 1511</span>&#160;```c++</div>
<div class="line"><a name="l01512"></a><span class="lineno"> 1512</span>&#160;<span class="keywordflow">if</span> (raw_size &lt; <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)) {</div>
<div class="line"><a name="l01513"></a><span class="lineno"> 1513</span>&#160;  LOG(ERROR) &lt;&lt; <span class="stringliteral">&quot;compressed record not big enough for count: &quot;</span> &lt;&lt; raw_size;</div>
<div class="line"><a name="l01514"></a><span class="lineno"> 1514</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l01515"></a><span class="lineno"> 1515</span>&#160;}</div>
<div class="line"><a name="l01516"></a><span class="lineno"> 1516</span>&#160;```</div>
<div class="line"><a name="l01517"></a><span class="lineno"> 1517</span>&#160;</div>
<div class="line"><a name="l01518"></a><span class="lineno"> 1518</span>&#160;<span class="preprocessor">### auto</span></div>
<div class="line"><a name="l01519"></a><span class="lineno"> 1519</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l01520"></a><span class="lineno"> 1520</span>&#160;&gt; Use `<span class="keyword">auto</span>` to avoid type names that are noisy, obvious, or unimportant - cases where the type doesn<span class="stringliteral">&#39;t aid in clarity for the reader. Continue to use manifest type declarations when it helps readability.</span></div>
<div class="line"><a name="l01521"></a><span class="lineno"> 1521</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01522"></a><span class="lineno"> 1522</span>&#160;<span class="stringliteral">**Pros**</span></div>
<div class="line"><a name="l01523"></a><span class="lineno"> 1523</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01524"></a><span class="lineno"> 1524</span>&#160;<span class="stringliteral">* C++ type names can be long and cumbersome, especially when they involve templates or namespaces.</span></div>
<div class="line"><a name="l01525"></a><span class="lineno"> 1525</span>&#160;<span class="stringliteral">* When a C++ type name is repeated within a single declaration or a small code region, the repetition may not be aiding readability.</span></div>
<div class="line"><a name="l01526"></a><span class="lineno"> 1526</span>&#160;<span class="stringliteral">* It is sometimes safer to let the type be specified by the type of the initialization expression, since that avoids the possibility of unintended copies or type conversions.</span></div>
<div class="line"><a name="l01527"></a><span class="lineno"> 1527</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01528"></a><span class="lineno"> 1528</span>&#160;<span class="stringliteral">**Cons**</span></div>
<div class="line"><a name="l01529"></a><span class="lineno"> 1529</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01530"></a><span class="lineno"> 1530</span>&#160;<span class="stringliteral">Sometimes code is clearer when types are manifest, especially when a variable&#39;</span>s initialization depends on things that were declared far away. In expressions like:</div>
<div class="line"><a name="l01531"></a><span class="lineno"> 1531</span>&#160;</div>
<div class="line"><a name="l01532"></a><span class="lineno"> 1532</span>&#160;```c++</div>
<div class="line"><a name="l01533"></a><span class="lineno"> 1533</span>&#160;<span class="keyword">auto</span> foo = x.add_foo();</div>
<div class="line"><a name="l01534"></a><span class="lineno"> 1534</span>&#160;<span class="keyword">auto</span> i = y.Find(key);</div>
<div class="line"><a name="l01535"></a><span class="lineno"> 1535</span>&#160;```</div>
<div class="line"><a name="l01536"></a><span class="lineno"> 1536</span>&#160;</div>
<div class="line"><a name="l01537"></a><span class="lineno"> 1537</span>&#160;it may not be obvious what the resulting types are <span class="keywordflow">if</span> the type of `y` isn<span class="stringliteral">&#39;t very well known, or if `y` was declared many lines earlier.</span></div>
<div class="line"><a name="l01538"></a><span class="lineno"> 1538</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01539"></a><span class="lineno"> 1539</span>&#160;<span class="stringliteral">Programmers have to understand the difference between `auto` and `const auto&amp;` or they&#39;</span>ll <span class="keyword">get</span> copies when they didn<span class="stringliteral">&#39;t mean to.</span></div>
<div class="line"><a name="l01540"></a><span class="lineno"> 1540</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01541"></a><span class="lineno"> 1541</span>&#160;<span class="stringliteral">If an `auto` variable is used as part of an interface, e.g. as a constant in a header, then a programmer might change its type while only intending to change its value, leading to a more radical API change than intended.</span></div>
<div class="line"><a name="l01542"></a><span class="lineno"> 1542</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01543"></a><span class="lineno"> 1543</span>&#160;<span class="stringliteral">**Decision**</span></div>
<div class="line"><a name="l01544"></a><span class="lineno"> 1544</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01545"></a><span class="lineno"> 1545</span>&#160;<span class="stringliteral">`auto` is permitted when it increases readability, particularly as described below. Never initialize an `auto`-typed variable with a braced initializer list.</span></div>
<div class="line"><a name="l01546"></a><span class="lineno"> 1546</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01547"></a><span class="lineno"> 1547</span>&#160;<span class="stringliteral">Specific cases where `auto` is allowed or encouraged:</span></div>
<div class="line"><a name="l01548"></a><span class="lineno"> 1548</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01549"></a><span class="lineno"> 1549</span>&#160;<span class="stringliteral">* (*Encouraged*) For iterators and other long/cluttery type names, particularly when the type is clear from context (calls to `find`, `begin`, or `end` for instance).</span></div>
<div class="line"><a name="l01550"></a><span class="lineno"> 1550</span>&#160;<span class="stringliteral">* (*Allowed*) When the type is clear from local context (in the same expression or within a few lines). Initialization of a pointer or smart pointer with calls to `new` commonly falls into this category, as does use of `auto` in a range-based loop over a container whose type is spelled out nearby.</span></div>
<div class="line"><a name="l01551"></a><span class="lineno"> 1551</span>&#160;<span class="stringliteral">* (*Allowed*) When the type doesn&#39;</span>t matter because it isn<span class="stringliteral">&#39;t being used for anything other than equality comparison.</span></div>
<div class="line"><a name="l01552"></a><span class="lineno"> 1552</span>&#160;<span class="stringliteral">* (*Encouraged*) When iterating over a map with a range-based loop (because it is often assumed that the correct type is `std::pair&lt;KeyType, ValueType&gt;` whereas it is actually `std::pair&lt;const KeyType, ValueType&gt;`). This is particularly well paired with local `key` and `value` aliases for `.first` and `.second` (often const-ref).</span></div>
<div class="line"><a name="l01553"></a><span class="lineno"> 1553</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01554"></a><span class="lineno"> 1554</span>&#160;<span class="stringliteral">    ```c++</span></div>
<div class="line"><a name="l01555"></a><span class="lineno"> 1555</span>&#160;<span class="stringliteral">    for (const auto&amp; item : some_map) {</span></div>
<div class="line"><a name="l01556"></a><span class="lineno"> 1556</span>&#160;<span class="stringliteral">      const KeyType&amp; key = item.first;</span></div>
<div class="line"><a name="l01557"></a><span class="lineno"> 1557</span>&#160;<span class="stringliteral">      const ValType&amp; value = item.second;</span></div>
<div class="line"><a name="l01558"></a><span class="lineno"> 1558</span>&#160;<span class="stringliteral">      // The rest of the loop can now just refer to key and value,</span></div>
<div class="line"><a name="l01559"></a><span class="lineno"> 1559</span>&#160;<span class="stringliteral">      // a reader can see the types in question, and we&#39;</span>ve avoided</div>
<div class="line"><a name="l01560"></a><span class="lineno"> 1560</span>&#160;      <span class="comment">// the too-common case of extra copies in this iteration.</span></div>
<div class="line"><a name="l01561"></a><span class="lineno"> 1561</span>&#160;    }</div>
<div class="line"><a name="l01562"></a><span class="lineno"> 1562</span>&#160;    ```</div>
<div class="line"><a name="l01563"></a><span class="lineno"> 1563</span>&#160;</div>
<div class="line"><a name="l01564"></a><span class="lineno"> 1564</span>&#160;<span class="preprocessor">### Braced Initializer List</span></div>
<div class="line"><a name="l01565"></a><span class="lineno"> 1565</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l01566"></a><span class="lineno"> 1566</span>&#160;&gt; You may use braced initializer lists.</div>
<div class="line"><a name="l01567"></a><span class="lineno"> 1567</span>&#160;</div>
<div class="line"><a name="l01568"></a><span class="lineno"> 1568</span>&#160;In C++03, aggregate types (arrays and structs with no</div>
<div class="line"><a name="l01569"></a><span class="lineno"> 1569</span>&#160;constructor) could be initialized with braced initializer lists.</div>
<div class="line"><a name="l01570"></a><span class="lineno"> 1570</span>&#160;</div>
<div class="line"><a name="l01571"></a><span class="lineno"> 1571</span>&#160;```c++</div>
<div class="line"><a name="l01572"></a><span class="lineno"> 1572</span>&#160;<span class="keyword">struct </span>Point { <span class="keywordtype">int</span> x; <span class="keywordtype">int</span> y; };</div>
<div class="line"><a name="l01573"></a><span class="lineno"> 1573</span>&#160;Point p = {1, 2};</div>
<div class="line"><a name="l01574"></a><span class="lineno"> 1574</span>&#160;```</div>
<div class="line"><a name="l01575"></a><span class="lineno"> 1575</span>&#160;</div>
<div class="line"><a name="l01576"></a><span class="lineno"> 1576</span>&#160;In C++11, <span class="keyword">this</span> syntax was generalized, and any <span class="keywordtype">object</span> type can now be created with a braced initializer list, known as a *braced-init-list* in the C++ grammar. Here are a few examples of its use.</div>
<div class="line"><a name="l01577"></a><span class="lineno"> 1577</span>&#160;</div>
<div class="line"><a name="l01578"></a><span class="lineno"> 1578</span>&#160;```c++</div>
<div class="line"><a name="l01579"></a><span class="lineno"> 1579</span>&#160;<span class="comment">// Vector takes a braced-init-list of elements.</span></div>
<div class="line"><a name="l01580"></a><span class="lineno"> 1580</span>&#160;std::vector&lt;string&gt; v{<span class="stringliteral">&quot;foo&quot;</span>, <span class="stringliteral">&quot;bar&quot;</span>};</div>
<div class="line"><a name="l01581"></a><span class="lineno"> 1581</span>&#160;</div>
<div class="line"><a name="l01582"></a><span class="lineno"> 1582</span>&#160;<span class="comment">// Basically the same, ignoring some small technicalities.</span></div>
<div class="line"><a name="l01583"></a><span class="lineno"> 1583</span>&#160;<span class="comment">// You may choose to use either form.</span></div>
<div class="line"><a name="l01584"></a><span class="lineno"> 1584</span>&#160;std::vector&lt;string&gt; v = {<span class="stringliteral">&quot;foo&quot;</span>, <span class="stringliteral">&quot;bar&quot;</span>};</div>
<div class="line"><a name="l01585"></a><span class="lineno"> 1585</span>&#160;</div>
<div class="line"><a name="l01586"></a><span class="lineno"> 1586</span>&#160;<span class="comment">// Usable with &#39;new&#39; expressions.</span></div>
<div class="line"><a name="l01587"></a><span class="lineno"> 1587</span>&#160;<span class="keyword">auto</span> p = <span class="keyword">new</span> vector&lt;string&gt;{<span class="stringliteral">&quot;foo&quot;</span>, <span class="stringliteral">&quot;bar&quot;</span>};</div>
<div class="line"><a name="l01588"></a><span class="lineno"> 1588</span>&#160;</div>
<div class="line"><a name="l01589"></a><span class="lineno"> 1589</span>&#160;<span class="comment">// A map can take a list of pairs. Nested braced-init-lists work.</span></div>
<div class="line"><a name="l01590"></a><span class="lineno"> 1590</span>&#160;std::map&lt;int, string&gt; m = {{1, <span class="stringliteral">&quot;one&quot;</span>}, {2, <span class="stringliteral">&quot;2&quot;</span>}};</div>
<div class="line"><a name="l01591"></a><span class="lineno"> 1591</span>&#160;</div>
<div class="line"><a name="l01592"></a><span class="lineno"> 1592</span>&#160;<span class="comment">// A braced-init-list can be implicitly converted to a return type.</span></div>
<div class="line"><a name="l01593"></a><span class="lineno"> 1593</span>&#160;std::vector&lt;int&gt; test_function() { <span class="keywordflow">return</span> {1, 2, 3}; }</div>
<div class="line"><a name="l01594"></a><span class="lineno"> 1594</span>&#160;</div>
<div class="line"><a name="l01595"></a><span class="lineno"> 1595</span>&#160;<span class="comment">// Iterate over a braced-init-list.</span></div>
<div class="line"><a name="l01596"></a><span class="lineno"> 1596</span>&#160;<span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : {-1, -2, -3}) {}</div>
<div class="line"><a name="l01597"></a><span class="lineno"> 1597</span>&#160;</div>
<div class="line"><a name="l01598"></a><span class="lineno"> 1598</span>&#160;<span class="comment">// Call a function using a braced-init-list.</span></div>
<div class="line"><a name="l01599"></a><span class="lineno"> 1599</span>&#160;<span class="keywordtype">void</span> TestFunction2(std::vector&lt;int&gt; v) {}</div>
<div class="line"><a name="l01600"></a><span class="lineno"> 1600</span>&#160;TestFunction2({1, 2, 3});</div>
<div class="line"><a name="l01601"></a><span class="lineno"> 1601</span>&#160;```</div>
<div class="line"><a name="l01602"></a><span class="lineno"> 1602</span>&#160;</div>
<div class="line"><a name="l01603"></a><span class="lineno"> 1603</span>&#160;A user-defined type can also define a constructor and/or assignment <span class="keyword">operator</span> that take `std::initializer_list&lt;T&gt;`, which is automatically created from *braced-init-list*:</div>
<div class="line"><a name="l01604"></a><span class="lineno"> 1604</span>&#160;</div>
<div class="line"><a name="l01605"></a><span class="lineno"> 1605</span>&#160;```c++</div>
<div class="line"><a name="l01606"></a><span class="lineno"> 1606</span>&#160;<span class="keyword">class </span>MyType {</div>
<div class="line"><a name="l01607"></a><span class="lineno"> 1607</span>&#160; <span class="keyword">public</span>:</div>
<div class="line"><a name="l01608"></a><span class="lineno"> 1608</span>&#160;  <span class="comment">// std::initializer_list references the underlying init list.</span></div>
<div class="line"><a name="l01609"></a><span class="lineno"> 1609</span>&#160;  <span class="comment">// It should be passed by value.</span></div>
<div class="line"><a name="l01610"></a><span class="lineno"> 1610</span>&#160;  MyType(std::initializer_list&lt;int&gt; init_list) {</div>
<div class="line"><a name="l01611"></a><span class="lineno"> 1611</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : init_list) append(i);</div>
<div class="line"><a name="l01612"></a><span class="lineno"> 1612</span>&#160;  }</div>
<div class="line"><a name="l01613"></a><span class="lineno"> 1613</span>&#160;  MyType&amp; operator=(std::initializer_list&lt;int&gt; init_list) {</div>
<div class="line"><a name="l01614"></a><span class="lineno"> 1614</span>&#160;    clear();</div>
<div class="line"><a name="l01615"></a><span class="lineno"> 1615</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : init_list) append(i);</div>
<div class="line"><a name="l01616"></a><span class="lineno"> 1616</span>&#160;  }</div>
<div class="line"><a name="l01617"></a><span class="lineno"> 1617</span>&#160;};</div>
<div class="line"><a name="l01618"></a><span class="lineno"> 1618</span>&#160;MyType m{2, 3, 5, 7};</div>
<div class="line"><a name="l01619"></a><span class="lineno"> 1619</span>&#160;```</div>
<div class="line"><a name="l01620"></a><span class="lineno"> 1620</span>&#160;</div>
<div class="line"><a name="l01621"></a><span class="lineno"> 1621</span>&#160;Finally, brace initialization can also call ordinary constructors of data types, even <span class="keywordflow">if</span> they <span class="keywordflow">do</span> not have `std::initializer_list&lt;T&gt;` constructors.</div>
<div class="line"><a name="l01622"></a><span class="lineno"> 1622</span>&#160;</div>
<div class="line"><a name="l01623"></a><span class="lineno"> 1623</span>&#160;```c++</div>
<div class="line"><a name="l01624"></a><span class="lineno"> 1624</span>&#160;<span class="keywordtype">double</span> d{1.23};</div>
<div class="line"><a name="l01625"></a><span class="lineno"> 1625</span>&#160;<span class="comment">// Calls ordinary constructor as long as MyOtherType has no</span></div>
<div class="line"><a name="l01626"></a><span class="lineno"> 1626</span>&#160;<span class="comment">// std::initializer_list constructor.</span></div>
<div class="line"><a name="l01627"></a><span class="lineno"> 1627</span>&#160;<span class="keyword">class </span>MyOtherType {</div>
<div class="line"><a name="l01628"></a><span class="lineno"> 1628</span>&#160; <span class="keyword">public</span>:</div>
<div class="line"><a name="l01629"></a><span class="lineno"> 1629</span>&#160;  <span class="keyword">explicit</span> MyOtherType(<span class="keywordtype">string</span>);</div>
<div class="line"><a name="l01630"></a><span class="lineno"> 1630</span>&#160;  MyOtherType(<span class="keywordtype">int</span>, <span class="keywordtype">string</span>);</div>
<div class="line"><a name="l01631"></a><span class="lineno"> 1631</span>&#160;};</div>
<div class="line"><a name="l01632"></a><span class="lineno"> 1632</span>&#160;MyOtherType m = {1, <span class="stringliteral">&quot;b&quot;</span>};</div>
<div class="line"><a name="l01633"></a><span class="lineno"> 1633</span>&#160;<span class="comment">// If the constructor is explicit, you can&#39;t use the &quot;= {}&quot; form.</span></div>
<div class="line"><a name="l01634"></a><span class="lineno"> 1634</span>&#160;MyOtherType m{<span class="stringliteral">&quot;b&quot;</span>};</div>
<div class="line"><a name="l01635"></a><span class="lineno"> 1635</span>&#160;```</div>
<div class="line"><a name="l01636"></a><span class="lineno"> 1636</span>&#160;</div>
<div class="line"><a name="l01637"></a><span class="lineno"> 1637</span>&#160;Never assign a *braced-init-list* to an <span class="keyword">auto</span> local variable. In the single element <span class="keywordflow">case</span>, what <span class="keyword">this</span> means can be confusing.</div>
<div class="line"><a name="l01638"></a><span class="lineno"> 1638</span>&#160;</div>
<div class="line"><a name="l01639"></a><span class="lineno"> 1639</span>&#160;**Bad code**</div>
<div class="line"><a name="l01640"></a><span class="lineno"> 1640</span>&#160;</div>
<div class="line"><a name="l01641"></a><span class="lineno"> 1641</span>&#160;```c++</div>
<div class="line"><a name="l01642"></a><span class="lineno"> 1642</span>&#160;<span class="keyword">auto</span> d = {1.23};        <span class="comment">// d is a std::initializer_list&lt;double&gt;</span></div>
<div class="line"><a name="l01643"></a><span class="lineno"> 1643</span>&#160;```</div>
<div class="line"><a name="l01644"></a><span class="lineno"> 1644</span>&#160;</div>
<div class="line"><a name="l01645"></a><span class="lineno"> 1645</span>&#160;**Good code**</div>
<div class="line"><a name="l01646"></a><span class="lineno"> 1646</span>&#160;</div>
<div class="line"><a name="l01647"></a><span class="lineno"> 1647</span>&#160;```c++</div>
<div class="line"><a name="l01648"></a><span class="lineno"> 1648</span>&#160;<span class="keyword">auto</span> d = <span class="keywordtype">double</span>{1.23};  <span class="comment">// Good -- d is a double, not a std::initializer_list.</span></div>
<div class="line"><a name="l01649"></a><span class="lineno"> 1649</span>&#160;```</div>
<div class="line"><a name="l01650"></a><span class="lineno"> 1650</span>&#160;</div>
<div class="line"><a name="l01651"></a><span class="lineno"> 1651</span>&#160;See [Braced Initializer List Format](#braced-initializer-list-format) <span class="keywordflow">for</span> formatting.</div>
<div class="line"><a name="l01652"></a><span class="lineno"> 1652</span>&#160;</div>
<div class="line"><a name="l01653"></a><span class="lineno"> 1653</span>&#160;### Lambda expressions</div>
<div class="line"><a name="l01654"></a><span class="lineno"> 1654</span>&#160;</div>
<div class="line"><a name="l01655"></a><span class="lineno"> 1655</span>&#160;&gt; Use lambda expressions where appropriate. Prefer <span class="keyword">explicit</span> captures when the lambda will escape the current scope.</div>
<div class="line"><a name="l01656"></a><span class="lineno"> 1656</span>&#160;</div>
<div class="line"><a name="l01657"></a><span class="lineno"> 1657</span>&#160;**Definition**</div>
<div class="line"><a name="l01658"></a><span class="lineno"> 1658</span>&#160;</div>
<div class="line"><a name="l01659"></a><span class="lineno"> 1659</span>&#160;Lambda expressions are a concise way of creating anonymous <span class="keyword">function</span> objects. They<span class="stringliteral">&#39;re often useful when passing functions as arguments. For example:</span></div>
<div class="line"><a name="l01660"></a><span class="lineno"> 1660</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01661"></a><span class="lineno"> 1661</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l01662"></a><span class="lineno"> 1662</span>&#160;<span class="stringliteral">std::sort(v.begin(), v.end(), [](int x, int y) {</span></div>
<div class="line"><a name="l01663"></a><span class="lineno"> 1663</span>&#160;<span class="stringliteral">  return Weight(x) &lt; Weight(y);</span></div>
<div class="line"><a name="l01664"></a><span class="lineno"> 1664</span>&#160;<span class="stringliteral">});</span></div>
<div class="line"><a name="l01665"></a><span class="lineno"> 1665</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l01666"></a><span class="lineno"> 1666</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01667"></a><span class="lineno"> 1667</span>&#160;<span class="stringliteral">They further allow capturing variables from the enclosing scope either explicitly by name, or implicitly using a default capture. Explicit captures require each variable to be listed, as either a value or reference capture:</span></div>
<div class="line"><a name="l01668"></a><span class="lineno"> 1668</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01669"></a><span class="lineno"> 1669</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l01670"></a><span class="lineno"> 1670</span>&#160;<span class="stringliteral">int weight = 3;</span></div>
<div class="line"><a name="l01671"></a><span class="lineno"> 1671</span>&#160;<span class="stringliteral">int sum = 0;</span></div>
<div class="line"><a name="l01672"></a><span class="lineno"> 1672</span>&#160;<span class="stringliteral">// Captures `weight` by value and `sum` by reference.</span></div>
<div class="line"><a name="l01673"></a><span class="lineno"> 1673</span>&#160;<span class="stringliteral">std::for_each(v.begin(), v.end(), [weight, &amp;sum](int x) {</span></div>
<div class="line"><a name="l01674"></a><span class="lineno"> 1674</span>&#160;<span class="stringliteral">  sum += weight * x;</span></div>
<div class="line"><a name="l01675"></a><span class="lineno"> 1675</span>&#160;<span class="stringliteral">});</span></div>
<div class="line"><a name="l01676"></a><span class="lineno"> 1676</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l01677"></a><span class="lineno"> 1677</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01678"></a><span class="lineno"> 1678</span>&#160;<span class="stringliteral">Default captures implicitly capture any variable referenced in the lambda body, including `this` if any members are used:</span></div>
<div class="line"><a name="l01679"></a><span class="lineno"> 1679</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01680"></a><span class="lineno"> 1680</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l01681"></a><span class="lineno"> 1681</span>&#160;<span class="stringliteral">const std::vector&lt;int&gt; lookup_table = ...;</span></div>
<div class="line"><a name="l01682"></a><span class="lineno"> 1682</span>&#160;<span class="stringliteral">std::vector&lt;int&gt; indices = ...;</span></div>
<div class="line"><a name="l01683"></a><span class="lineno"> 1683</span>&#160;<span class="stringliteral">// Captures `lookup_table` by reference, sorts `indices` by the value</span></div>
<div class="line"><a name="l01684"></a><span class="lineno"> 1684</span>&#160;<span class="stringliteral">// of the associated element in `lookup_table`.</span></div>
<div class="line"><a name="l01685"></a><span class="lineno"> 1685</span>&#160;<span class="stringliteral">std::sort(indices.begin(), indices.end(), [&amp;](int a, int b) {</span></div>
<div class="line"><a name="l01686"></a><span class="lineno"> 1686</span>&#160;<span class="stringliteral">  return lookup_table[a] &lt; lookup_table[b];</span></div>
<div class="line"><a name="l01687"></a><span class="lineno"> 1687</span>&#160;<span class="stringliteral">});</span></div>
<div class="line"><a name="l01688"></a><span class="lineno"> 1688</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l01689"></a><span class="lineno"> 1689</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01690"></a><span class="lineno"> 1690</span>&#160;<span class="stringliteral">Lambdas were introduced in C++11 along with a set of utilities for working with function objects, such as the polymorphic wrapper `std::function`.</span></div>
<div class="line"><a name="l01691"></a><span class="lineno"> 1691</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01692"></a><span class="lineno"> 1692</span>&#160;<span class="stringliteral">**Pros**</span></div>
<div class="line"><a name="l01693"></a><span class="lineno"> 1693</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01694"></a><span class="lineno"> 1694</span>&#160;<span class="stringliteral">* Lambdas are much more concise than other ways of defining function objects to be passed to STL algorithms, which can be a readability improvement.</span></div>
<div class="line"><a name="l01695"></a><span class="lineno"> 1695</span>&#160;<span class="stringliteral">* Appropriate use of default captures can remove redundancy and highlight important exceptions from the default.</span></div>
<div class="line"><a name="l01696"></a><span class="lineno"> 1696</span>&#160;<span class="stringliteral">* Lambdas, `std::function`, and `std::bind` can be used in combination as a general purpose callback mechanism; they make it easy to write functions that take bound functions as arguments.</span></div>
<div class="line"><a name="l01697"></a><span class="lineno"> 1697</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01698"></a><span class="lineno"> 1698</span>&#160;<span class="stringliteral">**Cons**</span></div>
<div class="line"><a name="l01699"></a><span class="lineno"> 1699</span>&#160;<span class="stringliteral">* Variable capture in lambdas can be a source of dangling-pointer bugs, particularly if a lambda escapes the current scope.</span></div>
<div class="line"><a name="l01700"></a><span class="lineno"> 1700</span>&#160;<span class="stringliteral">* Default captures by value can be misleading because they do not prevent dangling-pointer bugs. Capturing a pointer by value doesn&#39;</span>t cause a deep copy, so it often has the same lifetime issues as capture by reference. This is especially confusing when capturing <span class="stringliteral">&#39;this&#39;</span> by value, since the use of <span class="stringliteral">&#39;this&#39;</span> is often implicit.</div>
<div class="line"><a name="l01701"></a><span class="lineno"> 1701</span>&#160;* It<span class="stringliteral">&#39;s possible for use of lambdas to get out of hand; very long nested anonymous functions can make code harder to understand.</span></div>
<div class="line"><a name="l01702"></a><span class="lineno"> 1702</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01703"></a><span class="lineno"> 1703</span>&#160;<span class="stringliteral">**Decision**</span></div>
<div class="line"><a name="l01704"></a><span class="lineno"> 1704</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01705"></a><span class="lineno"> 1705</span>&#160;<span class="stringliteral">* Use lambda expressions where appropriate, with formatting as described [below](#formatting-lambda-expressions).</span></div>
<div class="line"><a name="l01706"></a><span class="lineno"> 1706</span>&#160;<span class="stringliteral">* Prefer explicit captures if the lambda may escape the current scope. For example, instead of:</span></div>
<div class="line"><a name="l01707"></a><span class="lineno"> 1707</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01708"></a><span class="lineno"> 1708</span>&#160;<span class="stringliteral">    ```c++</span></div>
<div class="line"><a name="l01709"></a><span class="lineno"> 1709</span>&#160;<span class="stringliteral">    {</span></div>
<div class="line"><a name="l01710"></a><span class="lineno"> 1710</span>&#160;<span class="stringliteral">      Foo foo;</span></div>
<div class="line"><a name="l01711"></a><span class="lineno"> 1711</span>&#160;<span class="stringliteral">      ...</span></div>
<div class="line"><a name="l01712"></a><span class="lineno"> 1712</span>&#160;<span class="stringliteral">      executor-&gt;Schedule([&amp;] { Frobnicate(foo); })</span></div>
<div class="line"><a name="l01713"></a><span class="lineno"> 1713</span>&#160;<span class="stringliteral">      ...</span></div>
<div class="line"><a name="l01714"></a><span class="lineno"> 1714</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l01715"></a><span class="lineno"> 1715</span>&#160;<span class="stringliteral">    // BAD! The fact that the lambda makes use of a reference to `foo` and</span></div>
<div class="line"><a name="l01716"></a><span class="lineno"> 1716</span>&#160;<span class="stringliteral">    // possibly `this` (if `Frobnicate` is a member function) may not be</span></div>
<div class="line"><a name="l01717"></a><span class="lineno"> 1717</span>&#160;<span class="stringliteral">    // apparent on a cursory inspection. If the lambda is invoked after</span></div>
<div class="line"><a name="l01718"></a><span class="lineno"> 1718</span>&#160;<span class="stringliteral">    // the function returns, that would be bad, because both `foo`</span></div>
<div class="line"><a name="l01719"></a><span class="lineno"> 1719</span>&#160;<span class="stringliteral">    // and the enclosing object could have been destroyed.</span></div>
<div class="line"><a name="l01720"></a><span class="lineno"> 1720</span>&#160;<span class="stringliteral">    ```</span></div>
<div class="line"><a name="l01721"></a><span class="lineno"> 1721</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01722"></a><span class="lineno"> 1722</span>&#160;<span class="stringliteral">    prefer to write:</span></div>
<div class="line"><a name="l01723"></a><span class="lineno"> 1723</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01724"></a><span class="lineno"> 1724</span>&#160;<span class="stringliteral">    ```c++</span></div>
<div class="line"><a name="l01725"></a><span class="lineno"> 1725</span>&#160;<span class="stringliteral">    {</span></div>
<div class="line"><a name="l01726"></a><span class="lineno"> 1726</span>&#160;<span class="stringliteral">      Foo foo;</span></div>
<div class="line"><a name="l01727"></a><span class="lineno"> 1727</span>&#160;<span class="stringliteral">      ...</span></div>
<div class="line"><a name="l01728"></a><span class="lineno"> 1728</span>&#160;<span class="stringliteral">      executor-&gt;Schedule([&amp;foo] { Frobnicate(foo); })</span></div>
<div class="line"><a name="l01729"></a><span class="lineno"> 1729</span>&#160;<span class="stringliteral">      ...</span></div>
<div class="line"><a name="l01730"></a><span class="lineno"> 1730</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l01731"></a><span class="lineno"> 1731</span>&#160;<span class="stringliteral">    // BETTER - The compile will fail if `Frobnicate` is a member</span></div>
<div class="line"><a name="l01732"></a><span class="lineno"> 1732</span>&#160;<span class="stringliteral">    // function, and it&#39;</span>s clearer that `foo` is dangerously captured by</div>
<div class="line"><a name="l01733"></a><span class="lineno"> 1733</span>&#160;   <span class="comment">// reference.</span></div>
<div class="line"><a name="l01734"></a><span class="lineno"> 1734</span>&#160;   ```</div>
<div class="line"><a name="l01735"></a><span class="lineno"> 1735</span>&#160;* Use <span class="keywordflow">default</span> capture by reference (`[&amp;]`) only when the lifetime of the lambda is obviously shorter than any potential captures.</div>
<div class="line"><a name="l01736"></a><span class="lineno"> 1736</span>&#160;* Use <span class="keywordflow">default</span> capture by value (`[=]`) only as a means of binding a few variables for a <span class="keywordtype">short</span> lambda, where the set of captured variables is obvious at a glance. Prefer not to write <span class="keywordtype">long</span> or complex lambdas with default capture by value.</div>
<div class="line"><a name="l01737"></a><span class="lineno"> 1737</span>&#160;* Keep unnamed lambdas <span class="keywordtype">short</span>. If a lambda body is more than maybe five lines <span class="keywordtype">long</span>, prefer to give the lambda a name, or to use a named function instead of a lambda.</div>
<div class="line"><a name="l01738"></a><span class="lineno"> 1738</span>&#160;* Specify the return type of the lambda explicitly if that will</div>
<div class="line"><a name="l01739"></a><span class="lineno"> 1739</span>&#160;make it more obvious to readers, as with [auto](<span class="preprocessor">#auto).</span></div>
<div class="line"><a name="l01740"></a><span class="lineno"> 1740</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l01741"></a><span class="lineno"> 1741</span>&#160;<span class="preprocessor">### Template metaprogramming</span></div>
<div class="line"><a name="l01742"></a><span class="lineno"> 1742</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l01743"></a><span class="lineno"> 1743</span>&#160;&gt; Avoid complicated <span class="keyword">template</span> programming.</div>
<div class="line"><a name="l01744"></a><span class="lineno"> 1744</span>&#160;</div>
<div class="line"><a name="l01745"></a><span class="lineno"> 1745</span>&#160;**Definition**</div>
<div class="line"><a name="l01746"></a><span class="lineno"> 1746</span>&#160;</div>
<div class="line"><a name="l01747"></a><span class="lineno"> 1747</span>&#160;Template metaprogramming refers to a family of techniques that</div>
<div class="line"><a name="l01748"></a><span class="lineno"> 1748</span>&#160;exploit the fact that the C++ <span class="keyword">template</span> instantiation mechanism is</div>
<div class="line"><a name="l01749"></a><span class="lineno"> 1749</span>&#160;Turing complete and can be used to perform arbitrary compile-time</div>
<div class="line"><a name="l01750"></a><span class="lineno"> 1750</span>&#160;computation in the type domain.</div>
<div class="line"><a name="l01751"></a><span class="lineno"> 1751</span>&#160;</div>
<div class="line"><a name="l01752"></a><span class="lineno"> 1752</span>&#160;**Pros**</div>
<div class="line"><a name="l01753"></a><span class="lineno"> 1753</span>&#160;</div>
<div class="line"><a name="l01754"></a><span class="lineno"> 1754</span>&#160;Template metaprogramming allows extremely flexible interfaces that are type safe and high performance. Facilities like &lt;a href=<span class="stringliteral">&quot;https://code.google.com/p/googletest/&quot;</span>&gt;Google Test&lt;/a&gt;, `std::tuple`, `std::function`, and Boost.Spirit would be impossible without it.</div>
<div class="line"><a name="l01755"></a><span class="lineno"> 1755</span>&#160;</div>
<div class="line"><a name="l01756"></a><span class="lineno"> 1756</span>&#160;**Cons**</div>
<div class="line"><a name="l01757"></a><span class="lineno"> 1757</span>&#160;</div>
<div class="line"><a name="l01758"></a><span class="lineno"> 1758</span>&#160;The techniques used in <span class="keyword">template</span> metaprogramming are often obscure to anyone but language experts. Code that uses templates in complicated ways is often unreadable, and is hard to debug or maintain.</div>
<div class="line"><a name="l01759"></a><span class="lineno"> 1759</span>&#160;</div>
<div class="line"><a name="l01760"></a><span class="lineno"> 1760</span>&#160;Template metaprogramming often leads to extremely poor compiler time error messages: even <span class="keywordflow">if</span> an <span class="keyword">interface </span>is simple, the complicated implementation details become visible when the user does something wrong.</div>
<div class="line"><a name="l01761"></a><span class="lineno"> 1761</span>&#160;</div>
<div class="line"><a name="l01762"></a><span class="lineno"> 1762</span>&#160;Template metaprogramming interferes with large scale refactoring by making the job of refactoring tools harder. First, the <span class="keyword">template</span> code is expanded in multiple contexts, and it<span class="stringliteral">&#39;s hard to verify that the transformation makes sense in all of them. Second, some refactoring tools work with an AST that only represents the structure of the code after template expansion. It can be difficult to automatically work back to the original source construct that needs to be rewritten.</span></div>
<div class="line"><a name="l01763"></a><span class="lineno"> 1763</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01764"></a><span class="lineno"> 1764</span>&#160;<span class="stringliteral">**Decision**</span></div>
<div class="line"><a name="l01765"></a><span class="lineno"> 1765</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01766"></a><span class="lineno"> 1766</span>&#160;<span class="stringliteral">Template metaprogramming sometimes allows cleaner and easier-to-use interfaces than would be possible without it, but it&#39;</span>s also often a temptation to be overly clever. It<span class="stringliteral">&#39;s best used in a small number of low level components where the extra maintenance burden is spread out over a large number of uses.</span></div>
<div class="line"><a name="l01767"></a><span class="lineno"> 1767</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01768"></a><span class="lineno"> 1768</span>&#160;<span class="stringliteral">Think twice before using template metaprogramming or other complicated template techniques; think about whether the average member of your team will be able to understand your code well enough to maintain it after you switch to another project, or whether a non-C++ programmer or someone casually browsing the code base will be able to understand the error messages or trace the flow of a function they want to call. If you&#39;</span>re <span class="keyword">using</span> recursive <span class="keyword">template</span> instantiations or type lists or metafunctions or expression templates, or relying on SFINAE or on the `<span class="keyword">sizeof</span>` trick <span class="keywordflow">for</span> detecting <span class="keyword">function</span> overload resolution, then there<span class="stringliteral">&#39;s a good chance you&#39;</span>ve gone too far.</div>
<div class="line"><a name="l01769"></a><span class="lineno"> 1769</span>&#160;</div>
<div class="line"><a name="l01770"></a><span class="lineno"> 1770</span>&#160;If you use <span class="keyword">template</span> metaprogramming, you should expect to put considerable effort into minimizing and isolating the complexity. You should hide metaprogramming as an implementation detail whenever possible, so that user-facing headers are readable, and you should make sure that tricky code is especially well commented. You should carefully document how the code is used, and you should say something about what the <span class="stringliteral">&quot;generated&quot;</span> code looks like. Pay extra attention to the error messages that the compiler emits when users make mistakes. The error messages are part of your user interface, and your code should be tweaked as necessary so that the error messages are understandable and actionable from a user point of view.</div>
<div class="line"><a name="l01771"></a><span class="lineno"> 1771</span>&#160;</div>
<div class="line"><a name="l01772"></a><span class="lineno"> 1772</span>&#160;</div>
<div class="line"><a name="l01773"></a><span class="lineno"> 1773</span>&#160;### C++11</div>
<div class="line"><a name="l01774"></a><span class="lineno"> 1774</span>&#160;</div>
<div class="line"><a name="l01775"></a><span class="lineno"> 1775</span>&#160;&gt; Use libraries and language extensions from C++11 when appropriate. Consider portability to other environments before <span class="keyword">using</span> C++11 features in your project.</div>
<div class="line"><a name="l01776"></a><span class="lineno"> 1776</span>&#160;</div>
<div class="line"><a name="l01777"></a><span class="lineno"> 1777</span>&#160;**Definition**</div>
<div class="line"><a name="l01778"></a><span class="lineno"> 1778</span>&#160;</div>
<div class="line"><a name="l01779"></a><span class="lineno"> 1779</span>&#160;C++11 contains [significant changes][wikipedia:c++11] significant changes both to the language and libraries.</div>
<div class="line"><a name="l01780"></a><span class="lineno"> 1780</span>&#160;</div>
<div class="line"><a name="l01781"></a><span class="lineno"> 1781</span>&#160; [wikipedia:c++11]: https:<span class="comment">//en.wikipedia.org/wiki/C%2B%2B11</span></div>
<div class="line"><a name="l01782"></a><span class="lineno"> 1782</span>&#160;</div>
<div class="line"><a name="l01783"></a><span class="lineno"> 1783</span>&#160;**Pros**</div>
<div class="line"><a name="l01784"></a><span class="lineno"> 1784</span>&#160;</div>
<div class="line"><a name="l01785"></a><span class="lineno"> 1785</span>&#160;C++11 was the official standard until august 2014, and is supported by most C++ compilers. It standardizes some common C++ extensions that we use already, allows shorthands <span class="keywordflow">for</span> some operations, and has some performance and safety improvements.</div>
<div class="line"><a name="l01786"></a><span class="lineno"> 1786</span>&#160;</div>
<div class="line"><a name="l01787"></a><span class="lineno"> 1787</span>&#160;**Cons**</div>
<div class="line"><a name="l01788"></a><span class="lineno"> 1788</span>&#160;</div>
<div class="line"><a name="l01789"></a><span class="lineno"> 1789</span>&#160;The C++11 standard is substantially more complex than its predecessor (1,300 pages versus 800 pages), and is unfamiliar to many developers. The <span class="keywordtype">long</span>-term effects of some features on code readability and maintenance are unknown. We cannot predict when its various features will be implemented uniformly by tools that may be of interest, particularly in the <span class="keywordflow">case</span> of projects that are forced to use older versions of tools.</div>
<div class="line"><a name="l01790"></a><span class="lineno"> 1790</span>&#160;</div>
<div class="line"><a name="l01791"></a><span class="lineno"> 1791</span>&#160;Some C++11 extensions encourage coding practices that hamper readability - <span class="keywordflow">for</span> example by removing checked redundancy (such as type names) that may be helpful to readers, or by encouraging <span class="keyword">template</span> metaprogramming. Other extensions duplicate functionality available through existing mechanisms, which may lead to confusion and conversion costs.</div>
<div class="line"><a name="l01792"></a><span class="lineno"> 1792</span>&#160;</div>
<div class="line"><a name="l01793"></a><span class="lineno"> 1793</span>&#160;**Decision**</div>
<div class="line"><a name="l01794"></a><span class="lineno"> 1794</span>&#160;</div>
<div class="line"><a name="l01795"></a><span class="lineno"> 1795</span>&#160;C++11 features may be used unless specified otherwise. In addition to what<span class="stringliteral">&#39;s described in the rest of the style guide, the following C++11 features may not be used:</span></div>
<div class="line"><a name="l01796"></a><span class="lineno"> 1796</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01797"></a><span class="lineno"> 1797</span>&#160;<span class="stringliteral">* Compile-time rational numbers (`&lt;ratio&gt;`), because of concerns that it&#39;</span>s tied to a more <span class="keyword">template</span>-heavy <span class="keyword">interface </span>style.</div>
<div class="line"><a name="l01798"></a><span class="lineno"> 1798</span>&#160;* The `&lt;cfenv&gt;` and `&lt;fenv.h&gt;` headers, because many compilers <span class="keywordflow">do</span> not support those features reliably.</div>
<div class="line"><a name="l01799"></a><span class="lineno"> 1799</span>&#160;* Ref-qualifiers on member functions, such as `<span class="keywordtype">void</span> X::Foo() &amp;` or `<span class="keywordtype">void</span> X::Foo() &amp;&amp;`, because of concerns that they<span class="stringliteral">&#39;re an overly obscure feature.</span></div>
<div class="line"><a name="l01800"></a><span class="lineno"> 1800</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01801"></a><span class="lineno"> 1801</span>&#160;<span class="stringliteral">### Nonstandard Extensions</span></div>
<div class="line"><a name="l01802"></a><span class="lineno"> 1802</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01803"></a><span class="lineno"> 1803</span>&#160;<span class="stringliteral">&gt; GCC Extensions to C++ may be used where they improve readability, performance or compiled code size.</span></div>
<div class="line"><a name="l01804"></a><span class="lineno"> 1804</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01805"></a><span class="lineno"> 1805</span>&#160;<span class="stringliteral">&lt;!-- TODO: Reword the stuff below to match the summary. --&gt;</span></div>
<div class="line"><a name="l01806"></a><span class="lineno"> 1806</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01807"></a><span class="lineno"> 1807</span>&#160;<span class="stringliteral">**Definition**</span></div>
<div class="line"><a name="l01808"></a><span class="lineno"> 1808</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01809"></a><span class="lineno"> 1809</span>&#160;<span class="stringliteral">Compilers support various extensions that are not part of standard C++. Such extensions include GCC&#39;</span>s `__attribute__`, intrinsic functions such as `__builtin_prefetch`, designated initializers (e.g. `Foo f = {.field = 3}`), <span class="keyword">inline</span> assembly, `__COUNTER__`, `__PRETTY_FUNCTION__`, compound statement expressions (e.g. `foo = ({ <span class="keywordtype">int</span> x; Bar(&amp;x); x })`, variable-length arrays and `alloca()`, and the `a?:b` syntax.</div>
<div class="line"><a name="l01810"></a><span class="lineno"> 1810</span>&#160;</div>
<div class="line"><a name="l01811"></a><span class="lineno"> 1811</span>&#160;**Pros**</div>
<div class="line"><a name="l01812"></a><span class="lineno"> 1812</span>&#160;</div>
<div class="line"><a name="l01813"></a><span class="lineno"> 1813</span>&#160;* Nonstandard extensions may provide useful features that <span class="keywordflow">do</span> not exist in standard C++. For example, some people think that designated initializers are more readable than standard C++ features like constructors.</div>
<div class="line"><a name="l01814"></a><span class="lineno"> 1814</span>&#160;* Important performance guidance to the compiler can only be specified <span class="keyword">using</span> extensions.</div>
<div class="line"><a name="l01815"></a><span class="lineno"> 1815</span>&#160;</div>
<div class="line"><a name="l01816"></a><span class="lineno"> 1816</span>&#160;**Cons**</div>
<div class="line"><a name="l01817"></a><span class="lineno"> 1817</span>&#160;</div>
<div class="line"><a name="l01818"></a><span class="lineno"> 1818</span>&#160;* Nonstandard extensions <span class="keywordflow">do</span> not work in all compilers. Use of nonstandard extensions reduces portability of code.</div>
<div class="line"><a name="l01819"></a><span class="lineno"> 1819</span>&#160;* Even <span class="keywordflow">if</span> they are supported in all targeted compilers, the extensions are often not well-specified, and there may be subtle behavior differences between compilers.</div>
<div class="line"><a name="l01820"></a><span class="lineno"> 1820</span>&#160;* Nonstandard extensions add to the language features that a reader must know to understand the code.</div>
<div class="line"><a name="l01821"></a><span class="lineno"> 1821</span>&#160;</div>
<div class="line"><a name="l01822"></a><span class="lineno"> 1822</span>&#160;**Decision**</div>
<div class="line"><a name="l01823"></a><span class="lineno"> 1823</span>&#160;</div>
<div class="line"><a name="l01824"></a><span class="lineno"> 1824</span>&#160;Use GCC extensions where necessary.</div>
<div class="line"><a name="l01825"></a><span class="lineno"> 1825</span>&#160;</div>
<div class="line"><a name="l01826"></a><span class="lineno"> 1826</span>&#160;### Aliases</div>
<div class="line"><a name="l01827"></a><span class="lineno"> 1827</span>&#160;</div>
<div class="line"><a name="l01828"></a><span class="lineno"> 1828</span>&#160;&gt; Public aliases are <span class="keywordflow">for</span> the benefit of an API<span class="stringliteral">&#39;s user, and should be clearly documented.</span></div>
<div class="line"><a name="l01829"></a><span class="lineno"> 1829</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01830"></a><span class="lineno"> 1830</span>&#160;<span class="stringliteral">**Definition**</span></div>
<div class="line"><a name="l01831"></a><span class="lineno"> 1831</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01832"></a><span class="lineno"> 1832</span>&#160;<span class="stringliteral">There are several ways to create names that are aliases of other entities:</span></div>
<div class="line"><a name="l01833"></a><span class="lineno"> 1833</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01834"></a><span class="lineno"> 1834</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l01835"></a><span class="lineno"> 1835</span>&#160;<span class="stringliteral">typedef Foo Bar;</span></div>
<div class="line"><a name="l01836"></a><span class="lineno"> 1836</span>&#160;<span class="stringliteral">using Bar = Foo;</span></div>
<div class="line"><a name="l01837"></a><span class="lineno"> 1837</span>&#160;<span class="stringliteral">using other_namespace::Foo;</span></div>
<div class="line"><a name="l01838"></a><span class="lineno"> 1838</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l01839"></a><span class="lineno"> 1839</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01840"></a><span class="lineno"> 1840</span>&#160;<span class="stringliteral">Like other declarations, aliases declared in a header file are part of that header&#39;</span>s <span class="keyword">public</span> API unless they<span class="stringliteral">&#39;re in a function definition, in the private portion of a class, or in an explicitly-marked internal namespace. Aliases in such areas or in .cc files are implementation details (because client code can&#39;</span>t refer to them), and are not restricted by <span class="keyword">this</span> rule.</div>
<div class="line"><a name="l01841"></a><span class="lineno"> 1841</span>&#160;</div>
<div class="line"><a name="l01842"></a><span class="lineno"> 1842</span>&#160;**Pros**</div>
<div class="line"><a name="l01843"></a><span class="lineno"> 1843</span>&#160;</div>
<div class="line"><a name="l01844"></a><span class="lineno"> 1844</span>&#160;* Aliases can improve readability by simplifying a <span class="keywordtype">long</span> or complicated name.</div>
<div class="line"><a name="l01845"></a><span class="lineno"> 1845</span>&#160;* Aliases can reduce duplication by naming in one place a type used repeatedly in an API, which *might* make it easier to change the type later.</div>
<div class="line"><a name="l01846"></a><span class="lineno"> 1846</span>&#160;</div>
<div class="line"><a name="l01847"></a><span class="lineno"> 1847</span>&#160;**Cons**</div>
<div class="line"><a name="l01848"></a><span class="lineno"> 1848</span>&#160;* When placed in a header where client code can refer to them, aliases increase the number of entities in that header<span class="stringliteral">&#39;s API, increasing its complexity.</span></div>
<div class="line"><a name="l01849"></a><span class="lineno"> 1849</span>&#160;<span class="stringliteral">* Clients can easily rely on unintended details of public aliases, making changes difficult.</span></div>
<div class="line"><a name="l01850"></a><span class="lineno"> 1850</span>&#160;<span class="stringliteral">* It can be tempting to create a public alias that is only intended for use in the implementation, without considering its impact on the API, or on maintainability.</span></div>
<div class="line"><a name="l01851"></a><span class="lineno"> 1851</span>&#160;<span class="stringliteral">* Aliases can create risk of name collisions</span></div>
<div class="line"><a name="l01852"></a><span class="lineno"> 1852</span>&#160;<span class="stringliteral">* Aliases can reduce readability by giving a familiar construct an unfamiliar name</span></div>
<div class="line"><a name="l01853"></a><span class="lineno"> 1853</span>&#160;<span class="stringliteral">* Type aliases can create an unclear API contract: it is unclear whether the alias is guaranteed to be identical to the type it aliases, to have the same API, or only to be usable in specified narrow ways</span></div>
<div class="line"><a name="l01854"></a><span class="lineno"> 1854</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01855"></a><span class="lineno"> 1855</span>&#160;<span class="stringliteral">**Decision**</span></div>
<div class="line"><a name="l01856"></a><span class="lineno"> 1856</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01857"></a><span class="lineno"> 1857</span>&#160;<span class="stringliteral">Don&#39;</span>t put an alias in your <span class="keyword">public</span> API just to save typing in the implementation; <span class="keywordflow">do</span> so only <span class="keywordflow">if</span> you intend it to be used by your clients.</div>
<div class="line"><a name="l01858"></a><span class="lineno"> 1858</span>&#160;</div>
<div class="line"><a name="l01859"></a><span class="lineno"> 1859</span>&#160;When defining a <span class="keyword">public</span> alias, document the intent of the <span class="keyword">new</span> name, including whether it is guaranteed to always be the same as the type it<span class="stringliteral">&#39;s currently aliased to, or whether a more limited compatibility is intended. This lets the user know whether they can treat the types as substitutable or whether more specific rules must be followed, and can help the implementation retain some degree of freedom to change the alias.</span></div>
<div class="line"><a name="l01860"></a><span class="lineno"> 1860</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l01861"></a><span class="lineno"> 1861</span>&#160;<span class="stringliteral">Don&#39;</span>t put <span class="keyword">namespace </span>aliases in your public API. (See also &lt;a href=<span class="stringliteral">&quot;#namespaces&quot;</span>&gt;Namespaces&lt;/a&gt;).</div>
<div class="line"><a name="l01862"></a><span class="lineno"> 1862</span>&#160;</div>
<div class="line"><a name="l01863"></a><span class="lineno"> 1863</span>&#160;For example, these aliases document how they are intended to be used in client code:</div>
<div class="line"><a name="l01864"></a><span class="lineno"> 1864</span>&#160;</div>
<div class="line"><a name="l01865"></a><span class="lineno"> 1865</span>&#160;```c++</div>
<div class="line"><a name="l01866"></a><span class="lineno"> 1866</span>&#160;<span class="keyword">namespace</span> a {</div>
<div class="line"><a name="l01867"></a><span class="lineno"> 1867</span>&#160;<span class="comment">// Used to store field measurements. DataPoint may change from Bar* to some internal type.</span></div>
<div class="line"><a name="l01868"></a><span class="lineno"> 1868</span>&#160;<span class="comment">// Client code should treat it as an opaque pointer.</span></div>
<div class="line"><a name="l01869"></a><span class="lineno"> 1869</span>&#160;<span class="keyword">using</span> DataPoint = foo::bar::Bar*;</div>
<div class="line"><a name="l01870"></a><span class="lineno"> 1870</span>&#160;</div>
<div class="line"><a name="l01871"></a><span class="lineno"> 1871</span>&#160;<span class="comment">// A set of measurements. Just an alias for user convenience.</span></div>
<div class="line"><a name="l01872"></a><span class="lineno"> 1872</span>&#160;<span class="keyword">using</span> TimeSeries = std::unordered_set&lt;DataPoint, std::hash&lt;DataPoint&gt;, DataPointComparator&gt;;</div>
<div class="line"><a name="l01873"></a><span class="lineno"> 1873</span>&#160;}  <span class="comment">// namespace a</span></div>
<div class="line"><a name="l01874"></a><span class="lineno"> 1874</span>&#160;```</div>
<div class="line"><a name="l01875"></a><span class="lineno"> 1875</span>&#160;</div>
<div class="line"><a name="l01876"></a><span class="lineno"> 1876</span>&#160;These aliases don<span class="stringliteral">&#39;t document intended use, and half of them aren&#39;</span>t meant <span class="keywordflow">for</span> client use:</div>
<div class="line"><a name="l01877"></a><span class="lineno"> 1877</span>&#160;</div>
<div class="line"><a name="l01878"></a><span class="lineno"> 1878</span>&#160;```c++</div>
<div class="line"><a name="l01879"></a><span class="lineno"> 1879</span>&#160;<span class="keyword">namespace </span>a {</div>
<div class="line"><a name="l01880"></a><span class="lineno"> 1880</span>&#160;<span class="comment">// Bad: none of these say how they should be used.</span></div>
<div class="line"><a name="l01881"></a><span class="lineno"> 1881</span>&#160;<span class="keyword">using</span> DataPoint = foo::bar::Bar*;</div>
<div class="line"><a name="l01882"></a><span class="lineno"> 1882</span>&#160;<span class="keyword">using</span> std::unordered_set;  <span class="comment">// Bad: just for local convenience</span></div>
<div class="line"><a name="l01883"></a><span class="lineno"> 1883</span>&#160;<span class="keyword">using</span> std::hash;           <span class="comment">// Bad: just for local convenience</span></div>
<div class="line"><a name="l01884"></a><span class="lineno"> 1884</span>&#160;<span class="keyword">typedef</span> unordered_set&lt;DataPoint, hash&lt;DataPoint&gt;, DataPointComparator&gt; TimeSeries;</div>
<div class="line"><a name="l01885"></a><span class="lineno"> 1885</span>&#160;}  <span class="comment">// namespace a</span></div>
<div class="line"><a name="l01886"></a><span class="lineno"> 1886</span>&#160;```</div>
<div class="line"><a name="l01887"></a><span class="lineno"> 1887</span>&#160;</div>
<div class="line"><a name="l01888"></a><span class="lineno"> 1888</span>&#160;However, local convenience aliases are fine in <span class="keyword">function</span> definitions, <span class="keyword">private</span> sections of classes, explicitly marked <span class="keyword">internal</span> namespaces, and in `.cpp` files:</div>
<div class="line"><a name="l01889"></a><span class="lineno"> 1889</span>&#160;</div>
<div class="line"><a name="l01890"></a><span class="lineno"> 1890</span>&#160;</div>
<div class="line"><a name="l01891"></a><span class="lineno"> 1891</span>&#160;```c++</div>
<div class="line"><a name="l01892"></a><span class="lineno"> 1892</span>&#160;<span class="comment">// In a .cpp file</span></div>
<div class="line"><a name="l01893"></a><span class="lineno"> 1893</span>&#160;<span class="keyword">using</span> std::unordered_set;</div>
<div class="line"><a name="l01894"></a><span class="lineno"> 1894</span>&#160;```</div>
<div class="line"><a name="l01895"></a><span class="lineno"> 1895</span>&#160;</div>
<div class="line"><a name="l01896"></a><span class="lineno"> 1896</span>&#160;<span class="preprocessor">## Naming</span></div>
<div class="line"><a name="l01897"></a><span class="lineno"> 1897</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l01898"></a><span class="lineno"> 1898</span>&#160;The most important consistency rules are those that govern naming. The style of a name immediately informs us what sort of thing the named entity is: a type, a variable, a <span class="keyword">function</span>, a constant, a macro, etc., without requiring us to search <span class="keywordflow">for</span> the declaration of that entity. The pattern-matching engine in our brains relies a great deal on these naming rules.</div>
<div class="line"><a name="l01899"></a><span class="lineno"> 1899</span>&#160;</div>
<div class="line"><a name="l01900"></a><span class="lineno"> 1900</span>&#160;Naming rules are pretty arbitrary, but we feel that consistency is more important than individual preferences in <span class="keyword">this</span> area, so regardless of whether you find them sensible or not, the rules are the rules.</div>
<div class="line"><a name="l01901"></a><span class="lineno"> 1901</span>&#160;</div>
<div class="line"><a name="l01902"></a><span class="lineno"> 1902</span>&#160;### General Naming Rules</div>
<div class="line"><a name="l01903"></a><span class="lineno"> 1903</span>&#160;</div>
<div class="line"><a name="l01904"></a><span class="lineno"> 1904</span>&#160;&gt; Names should be descriptive; avoid abbreviation.</div>
<div class="line"><a name="l01905"></a><span class="lineno"> 1905</span>&#160;</div>
<div class="line"><a name="l01906"></a><span class="lineno"> 1906</span>&#160;Give as descriptive a name as possible, within reason. Do not worry about saving horizontal space as it is far more important to make your code immediately understandable by a <span class="keyword">new</span> reader. Do not use abbreviations that are ambiguous or unfamiliar to readers outside your project, and <span class="keywordflow">do</span> not abbreviate by deleting letters within a word.</div>
<div class="line"><a name="l01907"></a><span class="lineno"> 1907</span>&#160;</div>
<div class="line"><a name="l01908"></a><span class="lineno"> 1908</span>&#160;```c++</div>
<div class="line"><a name="l01909"></a><span class="lineno"> 1909</span>&#160;<span class="keywordtype">int</span> price_count_reader;    <span class="comment">// No abbreviation.</span></div>
<div class="line"><a name="l01910"></a><span class="lineno"> 1910</span>&#160;<span class="keywordtype">int</span> num_errors;            <span class="comment">// &quot;num&quot; is a widespread convention.</span></div>
<div class="line"><a name="l01911"></a><span class="lineno"> 1911</span>&#160;<span class="keywordtype">int</span> num_dns_connections;   <span class="comment">// Most people know what &quot;DNS&quot; stands for.</span></div>
<div class="line"><a name="l01912"></a><span class="lineno"> 1912</span>&#160;```</div>
<div class="line"><a name="l01913"></a><span class="lineno"> 1913</span>&#160;</div>
<div class="line"><a name="l01914"></a><span class="lineno"> 1914</span>&#160;**Bad code**</div>
<div class="line"><a name="l01915"></a><span class="lineno"> 1915</span>&#160;</div>
<div class="line"><a name="l01916"></a><span class="lineno"> 1916</span>&#160;```c++</div>
<div class="line"><a name="l01917"></a><span class="lineno"> 1917</span>&#160;<span class="keywordtype">int</span> n;                     <span class="comment">// Meaningless.</span></div>
<div class="line"><a name="l01918"></a><span class="lineno"> 1918</span>&#160;<span class="keywordtype">int</span> nerr;                  <span class="comment">// Ambiguous abbreviation.</span></div>
<div class="line"><a name="l01919"></a><span class="lineno"> 1919</span>&#160;<span class="keywordtype">int</span> n_comp_conns;          <span class="comment">// Ambiguous abbreviation.</span></div>
<div class="line"><a name="l01920"></a><span class="lineno"> 1920</span>&#160;<span class="keywordtype">int</span> wgc_connections;       <span class="comment">// Only your group knows what this stands for.</span></div>
<div class="line"><a name="l01921"></a><span class="lineno"> 1921</span>&#160;<span class="keywordtype">int</span> pc_reader;             <span class="comment">// Lots of things can be abbreviated &quot;pc&quot;.</span></div>
<div class="line"><a name="l01922"></a><span class="lineno"> 1922</span>&#160;<span class="keywordtype">int</span> cstmr_id;              <span class="comment">// Deletes internal letters.</span></div>
<div class="line"><a name="l01923"></a><span class="lineno"> 1923</span>&#160;```</div>
<div class="line"><a name="l01924"></a><span class="lineno"> 1924</span>&#160;</div>
<div class="line"><a name="l01925"></a><span class="lineno"> 1925</span>&#160;Note that certain universally-known abbreviations are OK, such as `i` <span class="keywordflow">for</span> an iteration variable and `T` <span class="keywordflow">for</span> a <span class="keyword">template</span> parameter.</div>
<div class="line"><a name="l01926"></a><span class="lineno"> 1926</span>&#160;</div>
<div class="line"><a name="l01927"></a><span class="lineno"> 1927</span>&#160;Template parameters should follow the naming style <span class="keywordflow">for</span> their category: type <span class="keyword">template</span> parameters should follow the rules <span class="keywordflow">for</span> [type names](#type-names), and non-type <span class="keyword">template</span> parameters should follow the rules <span class="keywordflow">for</span> [variable names](#variable-names).</div>
<div class="line"><a name="l01928"></a><span class="lineno"> 1928</span>&#160;</div>
<div class="line"><a name="l01929"></a><span class="lineno"> 1929</span>&#160;### File Names</div>
<div class="line"><a name="l01930"></a><span class="lineno"> 1930</span>&#160;</div>
<div class="line"><a name="l01931"></a><span class="lineno"> 1931</span>&#160;&gt; Filenames should be all lowercase and can include underscores (`_`) or dashes (`-`). Follow the convention that your project uses. If there is no consistent local pattern to follow, prefer &quot;_&quot;.</div>
<div class="line"><a name="l01932"></a><span class="lineno"> 1932</span>&#160;</div>
<div class="line"><a name="l01933"></a><span class="lineno"> 1933</span>&#160;Examples of acceptable file names:</div>
<div class="line"><a name="l01934"></a><span class="lineno"> 1934</span>&#160;</div>
<div class="line"><a name="l01935"></a><span class="lineno"> 1935</span>&#160;* `my_useful_class.cpp`</div>
<div class="line"><a name="l01936"></a><span class="lineno"> 1936</span>&#160;* `my-useful-class.cpp`</div>
<div class="line"><a name="l01937"></a><span class="lineno"> 1937</span>&#160;* `myusefullclass.cpp`</div>
<div class="line"><a name="l01938"></a><span class="lineno"> 1938</span>&#160;* `myusefulclass_test.cpp`</div>
<div class="line"><a name="l01939"></a><span class="lineno"> 1939</span>&#160;</div>
<div class="line"><a name="l01940"></a><span class="lineno"> 1940</span>&#160;C++ files should end in `.cpp` and header files should end in `.h`. Files that rely on being textually included at specific points should end in `.inc` (see also the section on [self-contained headers](<span class="preprocessor">#self-contained-headers)).</span></div>
<div class="line"><a name="l01941"></a><span class="lineno"> 1941</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l01942"></a><span class="lineno"> 1942</span>&#160;Do not use filenames that already exist in `/usr/include`, such as `db.h`.</div>
<div class="line"><a name="l01943"></a><span class="lineno"> 1943</span>&#160;</div>
<div class="line"><a name="l01944"></a><span class="lineno"> 1944</span>&#160;In general, make your filenames very specific. For example, use `http_server_logs.h` rather than `logs.h`. A very common <span class="keywordflow">case</span> is to have a pair of files called, e.g., `foo_bar.h` and `foo_bar.cpp`, defining a <span class="keyword">class </span>called `FooBar`.</div>
<div class="line"><a name="l01945"></a><span class="lineno"> 1945</span>&#160;</div>
<div class="line"><a name="l01946"></a><span class="lineno"> 1946</span>&#160;Inline functions must be in a `.h` file. If your inline functions are very short, they should go directly into your `.h` file.</div>
<div class="line"><a name="l01947"></a><span class="lineno"> 1947</span>&#160;</div>
<div class="line"><a name="l01948"></a><span class="lineno"> 1948</span>&#160;### Type Names</div>
<div class="line"><a name="l01949"></a><span class="lineno"> 1949</span>&#160;</div>
<div class="line"><a name="l01950"></a><span class="lineno"> 1950</span>&#160;&gt; Type names start with a capital letter and have a capital letter for each new word, with no underscores: `MyExcitingClass`, `MyExcitingEnum`.</div>
<div class="line"><a name="l01951"></a><span class="lineno"> 1951</span>&#160;</div>
<div class="line"><a name="l01952"></a><span class="lineno"> 1952</span>&#160;</div>
<div class="line"><a name="l01953"></a><span class="lineno"> 1953</span>&#160;The names of all types - classes, structs, type aliases, enums, and type template parameters - have the same naming convention. Type names should start with a capital letter and have a capital letter for each new word. No underscores. For example:</div>
<div class="line"><a name="l01954"></a><span class="lineno"> 1954</span>&#160;</div>
<div class="line"><a name="l01955"></a><span class="lineno"> 1955</span>&#160;```c++</div>
<div class="line"><a name="l01956"></a><span class="lineno"> 1956</span>&#160;<span class="comment">// classes and structs</span></div>
<div class="line"><a name="l01957"></a><span class="lineno"> 1957</span>&#160;class UrlTable { ...</div>
<div class="line"><a name="l01958"></a><span class="lineno"> 1958</span>&#160;class UrlTableTester { ...</div>
<div class="line"><a name="l01959"></a><span class="lineno"> 1959</span>&#160;struct UrlTableProperties { ...</div>
<div class="line"><a name="l01960"></a><span class="lineno"> 1960</span>&#160;</div>
<div class="line"><a name="l01961"></a><span class="lineno"> 1961</span>&#160;<span class="comment">// typedefs</span></div>
<div class="line"><a name="l01962"></a><span class="lineno"> 1962</span>&#160;typedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;</div>
<div class="line"><a name="l01963"></a><span class="lineno"> 1963</span>&#160;</div>
<div class="line"><a name="l01964"></a><span class="lineno"> 1964</span>&#160;<span class="comment">// using aliases</span></div>
<div class="line"><a name="l01965"></a><span class="lineno"> 1965</span>&#160;<span class="keyword">using</span> PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;;</div>
<div class="line"><a name="l01966"></a><span class="lineno"> 1966</span>&#160;</div>
<div class="line"><a name="l01967"></a><span class="lineno"> 1967</span>&#160;<span class="comment">// enums</span></div>
<div class="line"><a name="l01968"></a><span class="lineno"> 1968</span>&#160;<span class="keyword">enum</span> UrlTableErrors { ...</div>
<div class="line"><a name="l01969"></a><span class="lineno"> 1969</span>&#160;```</div>
<div class="line"><a name="l01970"></a><span class="lineno"> 1970</span>&#160;</div>
<div class="line"><a name="l01971"></a><span class="lineno"> 1971</span>&#160;<span class="preprocessor">### Variable Names</span></div>
<div class="line"><a name="l01972"></a><span class="lineno"> 1972</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l01973"></a><span class="lineno"> 1973</span>&#160;&gt; The names of variables (including <span class="keyword">function</span> parameters) and data members are all lowercase, with underscores between words. Data members of classes (but not structs) additionally have trailing underscores. For instance: `a_local_variable`, `a_struct_data_member`, `a_class_data_member_`.</div>
<div class="line"><a name="l01974"></a><span class="lineno"> 1974</span>&#160;</div>
<div class="line"><a name="l01975"></a><span class="lineno"> 1975</span>&#160;#### Common Variable Names</div>
<div class="line"><a name="l01976"></a><span class="lineno"> 1976</span>&#160;</div>
<div class="line"><a name="l01977"></a><span class="lineno"> 1977</span>&#160;For example:</div>
<div class="line"><a name="l01978"></a><span class="lineno"> 1978</span>&#160;</div>
<div class="line"><a name="l01979"></a><span class="lineno"> 1979</span>&#160;```c++</div>
<div class="line"><a name="l01980"></a><span class="lineno"> 1980</span>&#160;<span class="keywordtype">string</span> table_name;  <span class="comment">// OK - uses underscore.</span></div>
<div class="line"><a name="l01981"></a><span class="lineno"> 1981</span>&#160;<span class="keywordtype">string</span> tablename;   <span class="comment">// OK - all lowercase.</span></div>
<div class="line"><a name="l01982"></a><span class="lineno"> 1982</span>&#160;<span class="keywordtype">string</span> tableName;   <span class="comment">// Bad - mixed case.</span></div>
<div class="line"><a name="l01983"></a><span class="lineno"> 1983</span>&#160;```</div>
<div class="line"><a name="l01984"></a><span class="lineno"> 1984</span>&#160;</div>
<div class="line"><a name="l01985"></a><span class="lineno"> 1985</span>&#160;<span class="preprocessor">#### Class Data Members</span></div>
<div class="line"><a name="l01986"></a><span class="lineno"> 1986</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l01987"></a><span class="lineno"> 1987</span>&#160;Data members of classes, both <span class="keyword">static</span> and non-<span class="keyword">static</span>, are named like ordinary nonmember variables, but with a trailing underscore.</div>
<div class="line"><a name="l01988"></a><span class="lineno"> 1988</span>&#160;</div>
<div class="line"><a name="l01989"></a><span class="lineno"> 1989</span>&#160;```c++</div>
<div class="line"><a name="l01990"></a><span class="lineno"> 1990</span>&#160;<span class="keyword">class </span>TableInfo {</div>
<div class="line"><a name="l01991"></a><span class="lineno"> 1991</span>&#160;  ...</div>
<div class="line"><a name="l01992"></a><span class="lineno"> 1992</span>&#160; <span class="keyword">private</span>:</div>
<div class="line"><a name="l01993"></a><span class="lineno"> 1993</span>&#160;  <span class="keywordtype">string</span> table_name_;  <span class="comment">// OK - underscore at end.</span></div>
<div class="line"><a name="l01994"></a><span class="lineno"> 1994</span>&#160;  <span class="keywordtype">string</span> tablename_;   <span class="comment">// OK.</span></div>
<div class="line"><a name="l01995"></a><span class="lineno"> 1995</span>&#160;  <span class="keyword">static</span> Pool&lt;TableInfo&gt;* pool_;  <span class="comment">// OK.</span></div>
<div class="line"><a name="l01996"></a><span class="lineno"> 1996</span>&#160;};</div>
<div class="line"><a name="l01997"></a><span class="lineno"> 1997</span>&#160;```</div>
<div class="line"><a name="l01998"></a><span class="lineno"> 1998</span>&#160;</div>
<div class="line"><a name="l01999"></a><span class="lineno"> 1999</span>&#160;<span class="preprocessor">#### Struct Data Members</span></div>
<div class="line"><a name="l02000"></a><span class="lineno"> 2000</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l02001"></a><span class="lineno"> 2001</span>&#160;Data members of structs, both <span class="keyword">static</span> and non-<span class="keyword">static</span>, are named like ordinary nonmember variables. They <span class="keywordflow">do</span> not have the trailing underscores that data members in classes have.</div>
<div class="line"><a name="l02002"></a><span class="lineno"> 2002</span>&#160;</div>
<div class="line"><a name="l02003"></a><span class="lineno"> 2003</span>&#160;```c++</div>
<div class="line"><a name="l02004"></a><span class="lineno"> 2004</span>&#160;<span class="keyword">struct </span>UrlTableProperties {</div>
<div class="line"><a name="l02005"></a><span class="lineno"> 2005</span>&#160;  <span class="keywordtype">string</span> name;</div>
<div class="line"><a name="l02006"></a><span class="lineno"> 2006</span>&#160;  <span class="keywordtype">int</span> num_entries;</div>
<div class="line"><a name="l02007"></a><span class="lineno"> 2007</span>&#160;  <span class="keyword">static</span> Pool&lt;UrlTableProperties&gt;* pool;</div>
<div class="line"><a name="l02008"></a><span class="lineno"> 2008</span>&#160;};</div>
<div class="line"><a name="l02009"></a><span class="lineno"> 2009</span>&#160;```</div>
<div class="line"><a name="l02010"></a><span class="lineno"> 2010</span>&#160;</div>
<div class="line"><a name="l02011"></a><span class="lineno"> 2011</span>&#160;See [Structs vs. Classes](#structs-vs-classes) <span class="keywordflow">for</span> a discussion of when to use a <span class="keyword">struct</span> versus a <span class="keyword">class</span>.</div>
<div class="line"><a name="l02012"></a><span class="lineno"> 2012</span>&#160;</div>
<div class="line"><a name="l02013"></a><span class="lineno"> 2013</span>&#160;### Constant Names</div>
<div class="line"><a name="l02014"></a><span class="lineno"> 2014</span>&#160;</div>
<div class="line"><a name="l02015"></a><span class="lineno"> 2015</span>&#160;&gt; Variables declared constexpr or <span class="keyword">const</span>, and whose value is fixed <span class="keywordflow">for</span> the duration of the program, are named with a leading <span class="stringliteral">&quot;k&quot;</span> followed by mixed <span class="keywordflow">case</span>. For example:</div>
<div class="line"><a name="l02016"></a><span class="lineno"> 2016</span>&#160;</div>
<div class="line"><a name="l02017"></a><span class="lineno"> 2017</span>&#160;```c++</div>
<div class="line"><a name="l02018"></a><span class="lineno"> 2018</span>&#160;<span class="keyword">const</span> <span class="keywordtype">int</span> kDaysInAWeek = 7;</div>
<div class="line"><a name="l02019"></a><span class="lineno"> 2019</span>&#160;```</div>
<div class="line"><a name="l02020"></a><span class="lineno"> 2020</span>&#160;</div>
<div class="line"><a name="l02021"></a><span class="lineno"> 2021</span>&#160;All such variables with <span class="keyword">static</span> storage duration (i.e. statics and globals, see [Storage Duration][cppref:storage-duration] <span class="keywordflow">for</span> details) should be named <span class="keyword">this</span> way. This convention is optional <span class="keywordflow">for</span> variables of other storage classes, e.g. automatic variables, otherwise the usual variable naming rules apply.</div>
<div class="line"><a name="l02022"></a><span class="lineno"> 2022</span>&#160;</div>
<div class="line"><a name="l02023"></a><span class="lineno"> 2023</span>&#160;### Function Names</div>
<div class="line"><a name="l02024"></a><span class="lineno"> 2024</span>&#160;</div>
<div class="line"><a name="l02025"></a><span class="lineno"> 2025</span>&#160;&gt; Regular functions have mixed <span class="keywordflow">case</span>; accessors and mutators may be named like variables.</div>
<div class="line"><a name="l02026"></a><span class="lineno"> 2026</span>&#160;</div>
<div class="line"><a name="l02027"></a><span class="lineno"> 2027</span>&#160;Ordinarily, functions should start with a lower-<span class="keywordflow">case</span> letter and have a capital letter <span class="keywordflow">for each</span> <span class="keyword">new</span> word (a.k.a. <span class="stringliteral">&quot;[Camel Case][wikipedia:camel-case]&quot;</span> or <span class="stringliteral">&quot;Pascal case&quot;</span>). Such names should not have underscores. Prefer to capitalize acronyms as single words (i.e. `startRpc()`, not `startRPC()`).</div>
<div class="line"><a name="l02028"></a><span class="lineno"> 2028</span>&#160;</div>
<div class="line"><a name="l02029"></a><span class="lineno"> 2029</span>&#160; [wikipedia:camel-<span class="keywordflow">case</span>]: https:<span class="comment">//en.wikipedia.org/wiki/Camel_case</span></div>
<div class="line"><a name="l02030"></a><span class="lineno"> 2030</span>&#160;</div>
<div class="line"><a name="l02031"></a><span class="lineno"> 2031</span>&#160;```c++</div>
<div class="line"><a name="l02032"></a><span class="lineno"> 2032</span>&#160;addTableEntry()</div>
<div class="line"><a name="l02033"></a><span class="lineno"> 2033</span>&#160;deleteUrl()</div>
<div class="line"><a name="l02034"></a><span class="lineno"> 2034</span>&#160;openFileOrDie()</div>
<div class="line"><a name="l02035"></a><span class="lineno"> 2035</span>&#160;```</div>
<div class="line"><a name="l02036"></a><span class="lineno"> 2036</span>&#160;</div>
<div class="line"><a name="l02037"></a><span class="lineno"> 2037</span>&#160;(The same naming rule applies to class- and namespace-scope constants that are exposed as part of an API and that are intended to look like functions, because the fact that they&#39;re objects rather than functions is an unimportant implementation detail.)</div>
<div class="line"><a name="l02038"></a><span class="lineno"> 2038</span>&#160;</div>
<div class="line"><a name="l02039"></a><span class="lineno"> 2039</span>&#160;Accessors and mutators (get and set functions) may be named like variables. These often correspond to actual member variables, but this is not required. For example, `<span class="keywordtype">int</span> count()` and `<span class="keywordtype">void</span> set_count(<span class="keywordtype">int</span> count)`.</div>
<div class="line"><a name="l02040"></a><span class="lineno"> 2040</span>&#160;</div>
<div class="line"><a name="l02041"></a><span class="lineno"> 2041</span>&#160;<span class="preprocessor">### Namespace Names</span></div>
<div class="line"><a name="l02042"></a><span class="lineno"> 2042</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l02043"></a><span class="lineno"> 2043</span>&#160;&gt; Namespace names are all lower-<span class="keywordflow">case</span>. Top-level <span class="keyword">namespace </span>names are based on the project name . Avoid collisions between nested namespaces and well-known top-level namespaces.</div>
<div class="line"><a name="l02044"></a><span class="lineno"> 2044</span>&#160;</div>
<div class="line"><a name="l02045"></a><span class="lineno"> 2045</span>&#160;The name of a top-level namespace should usually be the name of the project or team whose code is contained in that namespace. The code in that namespace should usually be in a directory whose basename matches the namespace name (or subdirectories thereof).</div>
<div class="line"><a name="l02046"></a><span class="lineno"> 2046</span>&#160;</div>
<div class="line"><a name="l02047"></a><span class="lineno"> 2047</span>&#160;Keep in mind that the [rule against abbreviated names](#general-naming-rules) applies to namespaces just as much as variable names. Code inside the namespace seldom needs to mention the namespace name, so there&#39;s usually no particular need for abbreviation anyway.</div>
<div class="line"><a name="l02048"></a><span class="lineno"> 2048</span>&#160;</div>
<div class="line"><a name="l02049"></a><span class="lineno"> 2049</span>&#160;Avoid nested namespaces that match well-known top-level namespaces. Collisions between namespace names can lead to surprising build breaks because of name lookup rules. In particular, do not create any nested `std` namespaces. Prefer unique project identifiers (`websearch::index`, `websearch::index_util`) over collision-prone names like `websearch::util`.</div>
<div class="line"><a name="l02050"></a><span class="lineno"> 2050</span>&#160;</div>
<div class="line"><a name="l02051"></a><span class="lineno"> 2051</span>&#160;For `internal` namespaces, be wary of other code being added to the same `internal` namespace causing a collision (internal helpers within a team tend to be related and may lead to collisions). In such a situation, using the filename to make a unique internal name is helpful (`websearch::index::frobber_internal` for use in `frobber.h`)</div>
<div class="line"><a name="l02052"></a><span class="lineno"> 2052</span>&#160;</div>
<div class="line"><a name="l02053"></a><span class="lineno"> 2053</span>&#160;<span class="preprocessor">### Enumerator Names</span></div>
<div class="line"><a name="l02054"></a><span class="lineno"> 2054</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l02055"></a><span class="lineno"> 2055</span>&#160;&gt; Enumerators (for both scoped and unscoped enums) should be named *either* like [constants](#constant-names) or like [macros](#macro-names): either `kEnumName` or `ENUM_NAME`.</div>
<div class="line"><a name="l02056"></a><span class="lineno"> 2056</span>&#160;</div>
<div class="line"><a name="l02057"></a><span class="lineno"> 2057</span>&#160;Preferably, the individual enumerators should be named like [constants](#constant-names). However, it is also acceptable to name them like [macros](#macro-names). The enumeration name, `UrlTableErrors` (and `AlternateUrlTableErrors`), is a type, and therefore mixed case.</div>
<div class="line"><a name="l02058"></a><span class="lineno"> 2058</span>&#160;</div>
<div class="line"><a name="l02059"></a><span class="lineno"> 2059</span>&#160;```c++</div>
<div class="line"><a name="l02060"></a><span class="lineno"> 2060</span>&#160;enum UrlTableErrors {</div>
<div class="line"><a name="l02061"></a><span class="lineno"> 2061</span>&#160;  kOK = 0,</div>
<div class="line"><a name="l02062"></a><span class="lineno"> 2062</span>&#160;  kErrorOutOfMemory,</div>
<div class="line"><a name="l02063"></a><span class="lineno"> 2063</span>&#160;  kErrorMalformedInput,</div>
<div class="line"><a name="l02064"></a><span class="lineno"> 2064</span>&#160;};</div>
<div class="line"><a name="l02065"></a><span class="lineno"> 2065</span>&#160;<span class="keyword">enum</span> AlternateUrlTableErrors {</div>
<div class="line"><a name="l02066"></a><span class="lineno"> 2066</span>&#160;  OK = 0,</div>
<div class="line"><a name="l02067"></a><span class="lineno"> 2067</span>&#160;  OUT_OF_MEMORY = 1,</div>
<div class="line"><a name="l02068"></a><span class="lineno"> 2068</span>&#160;  MALFORMED_INPUT = 2,</div>
<div class="line"><a name="l02069"></a><span class="lineno"> 2069</span>&#160;};</div>
<div class="line"><a name="l02070"></a><span class="lineno"> 2070</span>&#160;```</div>
<div class="line"><a name="l02071"></a><span class="lineno"> 2071</span>&#160;</div>
<div class="line"><a name="l02072"></a><span class="lineno"> 2072</span>&#160;<span class="preprocessor">### Macro Names</span></div>
<div class="line"><a name="l02073"></a><span class="lineno"> 2073</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l02074"></a><span class="lineno"> 2074</span>&#160;&gt; You<span class="stringliteral">&#39;re not really going to [define a macro](#preprocessor-macros, are you? If you do, they&#39;</span>re like <span class="keyword">this</span>: `MY_MACRO_THAT_SCARES_SMALL_CHILDREN`.</div>
<div class="line"><a name="l02075"></a><span class="lineno"> 2075</span>&#160;</div>
<div class="line"><a name="l02076"></a><span class="lineno"> 2076</span>&#160;Please see the [description of macros](#preprocessor-macros); in general macros should *not* be used. However, <span class="keywordflow">if</span> they are absolutely needed, then they should be named with all capitals and underscores.</div>
<div class="line"><a name="l02077"></a><span class="lineno"> 2077</span>&#160;</div>
<div class="line"><a name="l02078"></a><span class="lineno"> 2078</span>&#160;```c++</div>
<div class="line"><a name="l02079"></a><span class="lineno"> 2079</span>&#160;<span class="preprocessor">#define ROUND(x) ...</span></div>
<div class="line"><a name="l02080"></a><span class="lineno"> 2080</span>&#160;<span class="preprocessor"></span><span class="preprocessor">#define PI_ROUNDED 3.0</span></div>
<div class="line"><a name="l02081"></a><span class="lineno"> 2081</span>&#160;<span class="preprocessor"></span>```</div>
<div class="line"><a name="l02082"></a><span class="lineno"> 2082</span>&#160;</div>
<div class="line"><a name="l02083"></a><span class="lineno"> 2083</span>&#160;<span class="preprocessor">### Exceptions to Naming Rules</span></div>
<div class="line"><a name="l02084"></a><span class="lineno"> 2084</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l02085"></a><span class="lineno"> 2085</span>&#160;&gt; If you are naming something that is analogous to an existing C or C++ entity then you can follow the existing naming convention scheme.</div>
<div class="line"><a name="l02086"></a><span class="lineno"> 2086</span>&#160;</div>
<div class="line"><a name="l02087"></a><span class="lineno"> 2087</span>&#160;&lt;dl&gt;</div>
<div class="line"><a name="l02088"></a><span class="lineno"> 2088</span>&#160;  &lt;dt&gt;&lt;code&gt;bigopen()&lt;/code&gt;&lt;/dt&gt;</div>
<div class="line"><a name="l02089"></a><span class="lineno"> 2089</span>&#160;  &lt;dd&gt;<span class="keyword">function</span> name, follows form of &lt;code&gt;open()&lt;/code&gt;&lt;/dd&gt;</div>
<div class="line"><a name="l02090"></a><span class="lineno"> 2090</span>&#160;</div>
<div class="line"><a name="l02091"></a><span class="lineno"> 2091</span>&#160;  &lt;dt&gt;&lt;code&gt;uint&lt;/code&gt;&lt;/dt&gt;</div>
<div class="line"><a name="l02092"></a><span class="lineno"> 2092</span>&#160;  &lt;dd&gt;&lt;code&gt;<span class="keyword">typedef</span>&lt;/code&gt;&lt;/dd&gt;</div>
<div class="line"><a name="l02093"></a><span class="lineno"> 2093</span>&#160;</div>
<div class="line"><a name="l02094"></a><span class="lineno"> 2094</span>&#160;  &lt;dt&gt;&lt;code&gt;bigpos&lt;/code&gt;&lt;/dt&gt; &lt;dd&gt;&lt;code&gt;<span class="keyword">struct</span>&lt;/code&gt; or &lt;code&gt;<span class="keyword">class</span>&lt;/code&gt;, follows form of &lt;code&gt;pos&lt;/code&gt;&lt;/dd&gt;</div>
<div class="line"><a name="l02095"></a><span class="lineno"> 2095</span>&#160;</div>
<div class="line"><a name="l02096"></a><span class="lineno"> 2096</span>&#160;  &lt;dt&gt;&lt;code&gt;sparse_hash_map&lt;/code&gt;&lt;/dt&gt;</div>
<div class="line"><a name="l02097"></a><span class="lineno"> 2097</span>&#160;  &lt;dd&gt;STL-like entity; follows STL naming conventions&lt;/dd&gt;</div>
<div class="line"><a name="l02098"></a><span class="lineno"> 2098</span>&#160;</div>
<div class="line"><a name="l02099"></a><span class="lineno"> 2099</span>&#160;  &lt;dt&gt;&lt;code&gt;LONGLONG_MAX&lt;/code&gt;&lt;/dt&gt;</div>
<div class="line"><a name="l02100"></a><span class="lineno"> 2100</span>&#160;  &lt;dd&gt;a constant, as in &lt;code&gt;INT_MAX&lt;/code&gt;&lt;/dd&gt;</div>
<div class="line"><a name="l02101"></a><span class="lineno"> 2101</span>&#160;&lt;/dl&gt;</div>
<div class="line"><a name="l02102"></a><span class="lineno"> 2102</span>&#160;</div>
<div class="line"><a name="l02103"></a><span class="lineno"> 2103</span>&#160;<span class="preprocessor">## Comments</span></div>
<div class="line"><a name="l02104"></a><span class="lineno"> 2104</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l02105"></a><span class="lineno"> 2105</span>&#160;Though a pain to write, comments are absolutely vital to keeping our code readable. The following rules describe what you should comment and where. But remember: <span class="keywordflow">while</span> comments are very important, the best code is <span class="keyword">self</span>-documenting. Giving sensible names to types and variables is much better than <span class="keyword">using</span> obscure names that you must then explain through comments.</div>
<div class="line"><a name="l02106"></a><span class="lineno"> 2106</span>&#160;</div>
<div class="line"><a name="l02107"></a><span class="lineno"> 2107</span>&#160;When writing your comments, write <span class="keywordflow">for</span> your audience: the next contributor who will need to understand your code. Be generous - the next one may be you!</div>
<div class="line"><a name="l02108"></a><span class="lineno"> 2108</span>&#160;</div>
<div class="line"><a name="l02109"></a><span class="lineno"> 2109</span>&#160;<span class="preprocessor">### Comment Style</span></div>
<div class="line"><a name="l02110"></a><span class="lineno"> 2110</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l02111"></a><span class="lineno"> 2111</span>&#160;&gt; Use either the `<span class="comment">//` or `/* */` syntax, as long as you are consistent.</span></div>
<div class="line"><a name="l02112"></a><span class="lineno"> 2112</span>&#160;</div>
<div class="line"><a name="l02113"></a><span class="lineno"> 2113</span>&#160;You can use either the `<span class="comment">//` or the `/* */` syntax; however, `//` is *much* more common. Be consistent with how you comment and what style you use where.</span></div>
<div class="line"><a name="l02114"></a><span class="lineno"> 2114</span>&#160;</div>
<div class="line"><a name="l02115"></a><span class="lineno"> 2115</span>&#160;<span class="preprocessor">### File Comments</span></div>
<div class="line"><a name="l02116"></a><span class="lineno"> 2116</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l02117"></a><span class="lineno"> 2117</span>&#160;&gt; Start each file with license boilerplate.</div>
<div class="line"><a name="l02118"></a><span class="lineno"> 2118</span>&#160;</div>
<div class="line"><a name="l02119"></a><span class="lineno"> 2119</span>&#160;File comments describe the contents of a file. If a file declares, implements, or tests exactly one abstraction that is documented by a comment at the point of declaration, file comments are not required. All other files must have file comments.</div>
<div class="line"><a name="l02120"></a><span class="lineno"> 2120</span>&#160;</div>
<div class="line"><a name="l02121"></a><span class="lineno"> 2121</span>&#160;#### Legal Notice and Author Line</div>
<div class="line"><a name="l02122"></a><span class="lineno"> 2122</span>&#160;</div>
<div class="line"><a name="l02123"></a><span class="lineno"> 2123</span>&#160;Every file should contain license boilerplate. Choose the appropriate boilerplate <span class="keywordflow">for</span> the license used by the project (<span class="keywordflow">for</span> example, Apache 2.0, BSD, LGPL, GPL).</div>
<div class="line"><a name="l02124"></a><span class="lineno"> 2124</span>&#160;</div>
<div class="line"><a name="l02125"></a><span class="lineno"> 2125</span>&#160;If you make significant changes to a file with an author line, consider deleting the author line.</div>
<div class="line"><a name="l02126"></a><span class="lineno"> 2126</span>&#160;</div>
<div class="line"><a name="l02127"></a><span class="lineno"> 2127</span>&#160;#### File Contents</div>
<div class="line"><a name="l02128"></a><span class="lineno"> 2128</span>&#160;</div>
<div class="line"><a name="l02129"></a><span class="lineno"> 2129</span>&#160;If a `.h` declares multiple abstractions, the file-level comment should broadly describe the contents of the file, and how the abstractions are related. A 1 or 2 sentence file-level comment may be sufficient. The detailed documentation about individual abstractions belongs with those abstractions, not at the file level.</div>
<div class="line"><a name="l02130"></a><span class="lineno"> 2130</span>&#160;</div>
<div class="line"><a name="l02131"></a><span class="lineno"> 2131</span>&#160;Do not duplicate comments in both the `.h` and the `.cpp`. Duplicated comments diverge.</div>
<div class="line"><a name="l02132"></a><span class="lineno"> 2132</span>&#160;</div>
<div class="line"><a name="l02133"></a><span class="lineno"> 2133</span>&#160;### Class Comments</div>
<div class="line"><a name="l02134"></a><span class="lineno"> 2134</span>&#160;</div>
<div class="line"><a name="l02135"></a><span class="lineno"> 2135</span>&#160;&gt; Every non-obvious <span class="keyword">class </span>declaration should have an accompanying comment that describes what it is for and how it should be used.</div>
<div class="line"><a name="l02136"></a><span class="lineno"> 2136</span>&#160;</div>
<div class="line"><a name="l02137"></a><span class="lineno"> 2137</span>&#160;```c++</div>
<div class="line"><a name="l02138"></a><span class="lineno"> 2138</span>&#160;<span class="comment">// Iterates over the contents of a GargantuanTable.</span></div>
<div class="line"><a name="l02139"></a><span class="lineno"> 2139</span>&#160;<span class="comment">// Example:</span></div>
<div class="line"><a name="l02140"></a><span class="lineno"> 2140</span>&#160;<span class="comment">//    GargantuanTableIterator* iter = table-&gt;NewIterator();</span></div>
<div class="line"><a name="l02141"></a><span class="lineno"> 2141</span>&#160;<span class="comment">//    for (iter-&gt;Seek(&quot;foo&quot;); !iter-&gt;done(); iter-&gt;Next()) {</span></div>
<div class="line"><a name="l02142"></a><span class="lineno"> 2142</span>&#160;<span class="comment">//      process(iter-&gt;key(), iter-&gt;value());</span></div>
<div class="line"><a name="l02143"></a><span class="lineno"> 2143</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l02144"></a><span class="lineno"> 2144</span>&#160;<span class="comment">//    delete iter;</span></div>
<div class="line"><a name="l02145"></a><span class="lineno"> 2145</span>&#160;class GargantuanTableIterator {</div>
<div class="line"><a name="l02146"></a><span class="lineno"> 2146</span>&#160;  ...</div>
<div class="line"><a name="l02147"></a><span class="lineno"> 2147</span>&#160;};</div>
<div class="line"><a name="l02148"></a><span class="lineno"> 2148</span>&#160;```</div>
<div class="line"><a name="l02149"></a><span class="lineno"> 2149</span>&#160;</div>
<div class="line"><a name="l02150"></a><span class="lineno"> 2150</span>&#160;The <span class="keyword">class </span>comment should provide the reader with enough information to know how and when to use the class, as well as any additional considerations necessary to correctly use the class. Document the synchronization assumptions the class makes, if any. If an instance of the class can be accessed by multiple threads, take extra care to document the rules and invariants surrounding multithreaded use.</div>
<div class="line"><a name="l02151"></a><span class="lineno"> 2151</span>&#160;</div>
<div class="line"><a name="l02152"></a><span class="lineno"> 2152</span>&#160;The class comment is often a good place for a small example code snippet demonstrating a simple and focused usage of the class.</div>
<div class="line"><a name="l02153"></a><span class="lineno"> 2153</span>&#160;</div>
<div class="line"><a name="l02154"></a><span class="lineno"> 2154</span>&#160;When sufficiently separated (e.g. `.h` and `.cpp` files), comments describing the use of the class should go together with its interface definition; comments about the <span class="keyword">class </span>operation and implementation should accompany the implementation of the class&#39;s methods.</div>
<div class="line"><a name="l02155"></a><span class="lineno"> 2155</span>&#160;</div>
<div class="line"><a name="l02156"></a><span class="lineno"> 2156</span>&#160;### Function Comments</div>
<div class="line"><a name="l02157"></a><span class="lineno"> 2157</span>&#160;</div>
<div class="line"><a name="l02158"></a><span class="lineno"> 2158</span>&#160;&gt; Declaration comments describe use of the function (when it is non-obvious); comments at the definition of a <span class="keyword">function</span> describe operation.</div>
<div class="line"><a name="l02159"></a><span class="lineno"> 2159</span>&#160;</div>
<div class="line"><a name="l02160"></a><span class="lineno"> 2160</span>&#160;#### Function Declarations</div>
<div class="line"><a name="l02161"></a><span class="lineno"> 2161</span>&#160;</div>
<div class="line"><a name="l02162"></a><span class="lineno"> 2162</span>&#160;Almost every <span class="keyword">function</span> declaration should have comments immediately preceding it that describe what the <span class="keyword">function</span> does and how to use it. These comments may be omitted only <span class="keywordflow">if</span> the <span class="keyword">function</span> is simple and obvious (e.g. simple accessors <span class="keywordflow">for</span> obvious properties of the <span class="keyword">class</span>). These comments should be descriptive (<span class="stringliteral">&quot;Opens the file&quot;</span>) rather than imperative (&quot;Open the file&quot;); the comment describes the function, it does not tell the function what to do. In general, these comments do not describe how the function performs its task. Instead, that should be left to comments in the function definition.</div>
<div class="line"><a name="l02163"></a><span class="lineno"> 2163</span>&#160;</div>
<div class="line"><a name="l02164"></a><span class="lineno"> 2164</span>&#160;Types of things to mention in comments at the function declaration:</div>
<div class="line"><a name="l02165"></a><span class="lineno"> 2165</span>&#160;</div>
<div class="line"><a name="l02166"></a><span class="lineno"> 2166</span>&#160;* What the inputs and outputs are.</div>
<div class="line"><a name="l02167"></a><span class="lineno"> 2167</span>&#160;* For class member functions: whether the <span class="keywordtype">object</span> remembers reference arguments beyond the duration of the method call, and whether it will free them or not.</div>
<div class="line"><a name="l02168"></a><span class="lineno"> 2168</span>&#160;* If the function allocates memory that the caller must free.</div>
<div class="line"><a name="l02169"></a><span class="lineno"> 2169</span>&#160;* Whether any of the arguments can be a null pointer.</div>
<div class="line"><a name="l02170"></a><span class="lineno"> 2170</span>&#160;* If there are any performance implications of how a function is used.</div>
<div class="line"><a name="l02171"></a><span class="lineno"> 2171</span>&#160;* If the function is re-entrant. What are its synchronization assumptions?</div>
<div class="line"><a name="l02172"></a><span class="lineno"> 2172</span>&#160;</div>
<div class="line"><a name="l02173"></a><span class="lineno"> 2173</span>&#160;Here is an example:</div>
<div class="line"><a name="l02174"></a><span class="lineno"> 2174</span>&#160;</div>
<div class="line"><a name="l02175"></a><span class="lineno"> 2175</span>&#160;```c++</div>
<div class="line"><a name="l02176"></a><span class="lineno"> 2176</span>&#160;<span class="comment">// Returns an iterator for this table.  It is the client&#39;s</span></div>
<div class="line"><a name="l02177"></a><span class="lineno"> 2177</span>&#160;<span class="comment">// responsibility to delete the iterator when it is done with it,</span></div>
<div class="line"><a name="l02178"></a><span class="lineno"> 2178</span>&#160;<span class="comment">// and it must not use the iterator once the GargantuanTable object</span></div>
<div class="line"><a name="l02179"></a><span class="lineno"> 2179</span>&#160;<span class="comment">// on which the iterator was created has been deleted.</span></div>
<div class="line"><a name="l02180"></a><span class="lineno"> 2180</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l02181"></a><span class="lineno"> 2181</span>&#160;<span class="comment">// The iterator is initially positioned at the beginning of the table.</span></div>
<div class="line"><a name="l02182"></a><span class="lineno"> 2182</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l02183"></a><span class="lineno"> 2183</span>&#160;<span class="comment">// This method is equivalent to:</span></div>
<div class="line"><a name="l02184"></a><span class="lineno"> 2184</span>&#160;<span class="comment">//    Iterator* iter = table-&gt;NewIterator();</span></div>
<div class="line"><a name="l02185"></a><span class="lineno"> 2185</span>&#160;<span class="comment">//    iter-&gt;Seek(&quot;&quot;);</span></div>
<div class="line"><a name="l02186"></a><span class="lineno"> 2186</span>&#160;<span class="comment">//    return iter;</span></div>
<div class="line"><a name="l02187"></a><span class="lineno"> 2187</span>&#160;<span class="comment">// If you are going to immediately seek to another place in the</span></div>
<div class="line"><a name="l02188"></a><span class="lineno"> 2188</span>&#160;<span class="comment">// returned iterator, it will be faster to use NewIterator()</span></div>
<div class="line"><a name="l02189"></a><span class="lineno"> 2189</span>&#160;<span class="comment">// and avoid the extra seek.</span></div>
<div class="line"><a name="l02190"></a><span class="lineno"> 2190</span>&#160;Iterator* GetIterator() const;</div>
<div class="line"><a name="l02191"></a><span class="lineno"> 2191</span>&#160;```</div>
<div class="line"><a name="l02192"></a><span class="lineno"> 2192</span>&#160;</div>
<div class="line"><a name="l02193"></a><span class="lineno"> 2193</span>&#160;However, do not be unnecessarily verbose or state the completely obvious. Notice below that it is not necessary to say &quot;returns false otherwise&quot; because this is implied.</div>
<div class="line"><a name="l02194"></a><span class="lineno"> 2194</span>&#160;</div>
<div class="line"><a name="l02195"></a><span class="lineno"> 2195</span>&#160;```c++</div>
<div class="line"><a name="l02196"></a><span class="lineno"> 2196</span>&#160;<span class="comment">// Returns true if the table cannot hold any more entries.</span></div>
<div class="line"><a name="l02197"></a><span class="lineno"> 2197</span>&#160;<span class="keywordtype">bool</span> IsTableFull();</div>
<div class="line"><a name="l02198"></a><span class="lineno"> 2198</span>&#160;```</div>
<div class="line"><a name="l02199"></a><span class="lineno"> 2199</span>&#160;</div>
<div class="line"><a name="l02200"></a><span class="lineno"> 2200</span>&#160;When documenting function overrides, focus on the specifics of the override itself, rather than repeating the comment from the overridden function. In many of these cases, the override needs no additional documentation and thus no comment is required.</div>
<div class="line"><a name="l02201"></a><span class="lineno"> 2201</span>&#160;</div>
<div class="line"><a name="l02202"></a><span class="lineno"> 2202</span>&#160;When commenting constructors and destructors, remember that the person reading your code knows what constructors and destructors are for, so comments that just say something like &quot;destroys this <span class="keywordtype">object</span>&quot; are not useful. Document what constructors do with their arguments (for example, if they take ownership of pointers), and what cleanup the destructor does. If this is trivial, just skip the comment. It is quite common for destructors not to have a header comment.</div>
<div class="line"><a name="l02203"></a><span class="lineno"> 2203</span>&#160;</div>
<div class="line"><a name="l02204"></a><span class="lineno"> 2204</span>&#160;<span class="preprocessor">#### Function Definitions</span></div>
<div class="line"><a name="l02205"></a><span class="lineno"> 2205</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l02206"></a><span class="lineno"> 2206</span>&#160;If there is anything tricky about how a <span class="keyword">function</span> does its job, the <span class="keyword">function</span> definition should have an explanatory comment. For example, in the definition comment you might describe any coding tricks you use, give an overview of the steps you go through, or explain why you chose to implement the <span class="keyword">function</span> in the way you did rather than <span class="keyword">using</span> a viable alternative. For instance, you might mention why it must acquire a lock <span class="keywordflow">for</span> the first half of the <span class="keyword">function</span> but why it is not needed <span class="keywordflow">for</span> the second half.</div>
<div class="line"><a name="l02207"></a><span class="lineno"> 2207</span>&#160;</div>
<div class="line"><a name="l02208"></a><span class="lineno"> 2208</span>&#160;Note you should *not* just repeat the comments given with the <span class="keyword">function</span> declaration, in the `.h` file or wherever. It<span class="stringliteral">&#39;s okay to recapitulate briefly what the function does, but the focus of the comments should be on how it does it.</span></div>
<div class="line"><a name="l02209"></a><span class="lineno"> 2209</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02210"></a><span class="lineno"> 2210</span>&#160;<span class="stringliteral">### Variable Comments</span></div>
<div class="line"><a name="l02211"></a><span class="lineno"> 2211</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02212"></a><span class="lineno"> 2212</span>&#160;<span class="stringliteral">&gt; In general the actual name of the variable should be descriptive enough to give a good idea of what the variable is used for. In certain cases, more comments are required.</span></div>
<div class="line"><a name="l02213"></a><span class="lineno"> 2213</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02214"></a><span class="lineno"> 2214</span>&#160;<span class="stringliteral">#### Class Data Member Comments</span></div>
<div class="line"><a name="l02215"></a><span class="lineno"> 2215</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02216"></a><span class="lineno"> 2216</span>&#160;<span class="stringliteral">The purpose of each class data member (also called an instance variable or member variable) must be clear. If there are any invariants (special values, relationships between members, lifetime requirements) not clearly expressed by the type and name, they must be commented. However, if the type and name suffice (`int num_events_;`), no comment is needed.</span></div>
<div class="line"><a name="l02217"></a><span class="lineno"> 2217</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02218"></a><span class="lineno"> 2218</span>&#160;<span class="stringliteral">In particular, add comments to describe the existence and meaning of sentinel values, such as nullptr or -1, when they are not obvious. For example:</span></div>
<div class="line"><a name="l02219"></a><span class="lineno"> 2219</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02220"></a><span class="lineno"> 2220</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l02221"></a><span class="lineno"> 2221</span>&#160;<span class="stringliteral">private:</span></div>
<div class="line"><a name="l02222"></a><span class="lineno"> 2222</span>&#160;<span class="stringliteral"> // Used to bounds-check table accesses. -1 means</span></div>
<div class="line"><a name="l02223"></a><span class="lineno"> 2223</span>&#160;<span class="stringliteral"> // that we don&#39;</span>t yet know how many entries the table has.</div>
<div class="line"><a name="l02224"></a><span class="lineno"> 2224</span>&#160; <span class="keywordtype">int</span> num_total_entries_;</div>
<div class="line"><a name="l02225"></a><span class="lineno"> 2225</span>&#160;```</div>
<div class="line"><a name="l02226"></a><span class="lineno"> 2226</span>&#160;</div>
<div class="line"><a name="l02227"></a><span class="lineno"> 2227</span>&#160;<span class="preprocessor">#### Global Variable Comments</span></div>
<div class="line"><a name="l02228"></a><span class="lineno"> 2228</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l02229"></a><span class="lineno"> 2229</span>&#160;All global variables should have a comment describing what they are, what they are used <span class="keywordflow">for</span>, and (<span class="keywordflow">if</span> unclear) why it needs to be global. For example:</div>
<div class="line"><a name="l02230"></a><span class="lineno"> 2230</span>&#160;</div>
<div class="line"><a name="l02231"></a><span class="lineno"> 2231</span>&#160;```c++</div>
<div class="line"><a name="l02232"></a><span class="lineno"> 2232</span>&#160;<span class="comment">// The total number of tests cases that we run through in this regression test.</span></div>
<div class="line"><a name="l02233"></a><span class="lineno"> 2233</span>&#160;<span class="keyword">const</span> <span class="keywordtype">int</span> kNumTestCases = 6;</div>
<div class="line"><a name="l02234"></a><span class="lineno"> 2234</span>&#160;```</div>
<div class="line"><a name="l02235"></a><span class="lineno"> 2235</span>&#160;</div>
<div class="line"><a name="l02236"></a><span class="lineno"> 2236</span>&#160;<span class="preprocessor">### Implementation Comments</span></div>
<div class="line"><a name="l02237"></a><span class="lineno"> 2237</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l02238"></a><span class="lineno"> 2238</span>&#160;&gt; In your implementation you should have comments in tricky, non-obvious, interesting, or important parts of your code.</div>
<div class="line"><a name="l02239"></a><span class="lineno"> 2239</span>&#160;</div>
<div class="line"><a name="l02240"></a><span class="lineno"> 2240</span>&#160;#### Explanatory Comments</div>
<div class="line"><a name="l02241"></a><span class="lineno"> 2241</span>&#160;</div>
<div class="line"><a name="l02242"></a><span class="lineno"> 2242</span>&#160;Tricky or complicated code blocks should have comments before them. Example:</div>
<div class="line"><a name="l02243"></a><span class="lineno"> 2243</span>&#160;</div>
<div class="line"><a name="l02244"></a><span class="lineno"> 2244</span>&#160;```c++</div>
<div class="line"><a name="l02245"></a><span class="lineno"> 2245</span>&#160;<span class="comment">// Divide result by two, taking into account that x</span></div>
<div class="line"><a name="l02246"></a><span class="lineno"> 2246</span>&#160;<span class="comment">// contains the carry from the add.</span></div>
<div class="line"><a name="l02247"></a><span class="lineno"> 2247</span>&#160;<span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; result-&gt;size(); i++) {</div>
<div class="line"><a name="l02248"></a><span class="lineno"> 2248</span>&#160;  x = (x &lt;&lt; 8) + (*result)[i];</div>
<div class="line"><a name="l02249"></a><span class="lineno"> 2249</span>&#160;  (*result)[i] = x &gt;&gt; 1;</div>
<div class="line"><a name="l02250"></a><span class="lineno"> 2250</span>&#160;  x &amp;= 1;</div>
<div class="line"><a name="l02251"></a><span class="lineno"> 2251</span>&#160;}</div>
<div class="line"><a name="l02252"></a><span class="lineno"> 2252</span>&#160;```</div>
<div class="line"><a name="l02253"></a><span class="lineno"> 2253</span>&#160;</div>
<div class="line"><a name="l02254"></a><span class="lineno"> 2254</span>&#160;<span class="preprocessor">#### Line Comments</span></div>
<div class="line"><a name="l02255"></a><span class="lineno"> 2255</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l02256"></a><span class="lineno"> 2256</span>&#160;Also, lines that are non-obvious should <span class="keyword">get</span> a comment at the end of the line. These end-of-line comments should be separated from the code by 2 spaces. Example:</div>
<div class="line"><a name="l02257"></a><span class="lineno"> 2257</span>&#160;</div>
<div class="line"><a name="l02258"></a><span class="lineno"> 2258</span>&#160;```c++</div>
<div class="line"><a name="l02259"></a><span class="lineno"> 2259</span>&#160;<span class="comment">// If we have enough memory, mmap the data portion too.</span></div>
<div class="line"><a name="l02260"></a><span class="lineno"> 2260</span>&#160;mmap_budget = max&lt;int64&gt;(0, mmap_budget - index_-&gt;length());</div>
<div class="line"><a name="l02261"></a><span class="lineno"> 2261</span>&#160;<span class="keywordflow">if</span> (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock))</div>
<div class="line"><a name="l02262"></a><span class="lineno"> 2262</span>&#160;  <span class="keywordflow">return</span>;  <span class="comment">// Error already logged.</span></div>
<div class="line"><a name="l02263"></a><span class="lineno"> 2263</span>&#160;```</div>
<div class="line"><a name="l02264"></a><span class="lineno"> 2264</span>&#160;</div>
<div class="line"><a name="l02265"></a><span class="lineno"> 2265</span>&#160;Note that there are both comments that describe what the code is doing, and comments that mention that an error has already been logged when the <span class="keyword">function</span> returns.</div>
<div class="line"><a name="l02266"></a><span class="lineno"> 2266</span>&#160;</div>
<div class="line"><a name="l02267"></a><span class="lineno"> 2267</span>&#160;If you have several comments on subsequent lines, it can often be more readable to line them up:</div>
<div class="line"><a name="l02268"></a><span class="lineno"> 2268</span>&#160;</div>
<div class="line"><a name="l02269"></a><span class="lineno"> 2269</span>&#160;```c++</div>
<div class="line"><a name="l02270"></a><span class="lineno"> 2270</span>&#160;DoSomething();                  <span class="comment">// Comment here so the comments line up.</span></div>
<div class="line"><a name="l02271"></a><span class="lineno"> 2271</span>&#160;DoSomethingElseThatIsLonger();  <span class="comment">// Two spaces between the code and the comment.</span></div>
<div class="line"><a name="l02272"></a><span class="lineno"> 2272</span>&#160;{ <span class="comment">// One space before comment when opening a new scope is allowed,</span></div>
<div class="line"><a name="l02273"></a><span class="lineno"> 2273</span>&#160;  <span class="comment">// thus the comment lines up with the following comments and code.</span></div>
<div class="line"><a name="l02274"></a><span class="lineno"> 2274</span>&#160;  DoSomethingElse();  <span class="comment">// Two spaces before line comments normally.</span></div>
<div class="line"><a name="l02275"></a><span class="lineno"> 2275</span>&#160;}</div>
<div class="line"><a name="l02276"></a><span class="lineno"> 2276</span>&#160;std::vector&lt;string&gt; list{</div>
<div class="line"><a name="l02277"></a><span class="lineno"> 2277</span>&#160;                    <span class="comment">// Comments in braced lists describe the next element...</span></div>
<div class="line"><a name="l02278"></a><span class="lineno"> 2278</span>&#160;                    <span class="stringliteral">&quot;First item&quot;</span>,</div>
<div class="line"><a name="l02279"></a><span class="lineno"> 2279</span>&#160;                    <span class="comment">// .. and should be aligned appropriately.</span></div>
<div class="line"><a name="l02280"></a><span class="lineno"> 2280</span>&#160;                    <span class="stringliteral">&quot;Second item&quot;</span>};</div>
<div class="line"><a name="l02281"></a><span class="lineno"> 2281</span>&#160;DoSomething(); <span class="comment">/* For trailing block comments, one space is fine. */</span></div>
<div class="line"><a name="l02282"></a><span class="lineno"> 2282</span>&#160;```</div>
<div class="line"><a name="l02283"></a><span class="lineno"> 2283</span>&#160;</div>
<div class="line"><a name="l02284"></a><span class="lineno"> 2284</span>&#160;<span class="preprocessor">#### Function Argument Comments</span></div>
<div class="line"><a name="l02285"></a><span class="lineno"> 2285</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l02286"></a><span class="lineno"> 2286</span>&#160;When the meaning of a <span class="keyword">function</span> argument is nonobvious, consider one of the following remedies:</div>
<div class="line"><a name="l02287"></a><span class="lineno"> 2287</span>&#160;</div>
<div class="line"><a name="l02288"></a><span class="lineno"> 2288</span>&#160;* If the argument is a literal constant, and the same constant is used in multiple <span class="keyword">function</span> calls in a way that tacitly assumes they<span class="stringliteral">&#39;re the same, you should use a named constant to make that constraint explicit, and to guarantee that it holds.</span></div>
<div class="line"><a name="l02289"></a><span class="lineno"> 2289</span>&#160;<span class="stringliteral">* Consider changing the function signature to replace a `bool` argument with an `enum` argument. This will make the argument values self-describing.</span></div>
<div class="line"><a name="l02290"></a><span class="lineno"> 2290</span>&#160;<span class="stringliteral">* For functions that have several configuration options, consider defining a single class or struct to hold all the options , and pass an instance of that. This approach has several advantages. Options are referenced by name at the call site, which clarifies their meaning. It also reduces function argument count, which makes function calls easier to read and write. As an added benefit, you don&#39;</span>t have to change call sites when you add another option.</div>
<div class="line"><a name="l02291"></a><span class="lineno"> 2291</span>&#160;* Replace large or complex nested expressions with named variables.</div>
<div class="line"><a name="l02292"></a><span class="lineno"> 2292</span>&#160;* As a last resort, use comments to clarify argument meanings at the call site.</div>
<div class="line"><a name="l02293"></a><span class="lineno"> 2293</span>&#160;</div>
<div class="line"><a name="l02294"></a><span class="lineno"> 2294</span>&#160;Consider the following example:</div>
<div class="line"><a name="l02295"></a><span class="lineno"> 2295</span>&#160;</div>
<div class="line"><a name="l02296"></a><span class="lineno"> 2296</span>&#160;```c++</div>
<div class="line"><a name="l02297"></a><span class="lineno"> 2297</span>&#160;<span class="comment">// What are these arguments?</span></div>
<div class="line"><a name="l02298"></a><span class="lineno"> 2298</span>&#160;<span class="keyword">const</span> DecimalNumber product = CalculateProduct(values, 7, <span class="keyword">false</span>, <span class="keyword">nullptr</span>);</div>
<div class="line"><a name="l02299"></a><span class="lineno"> 2299</span>&#160;```</div>
<div class="line"><a name="l02300"></a><span class="lineno"> 2300</span>&#160;</div>
<div class="line"><a name="l02301"></a><span class="lineno"> 2301</span>&#160;versus:</div>
<div class="line"><a name="l02302"></a><span class="lineno"> 2302</span>&#160;</div>
<div class="line"><a name="l02303"></a><span class="lineno"> 2303</span>&#160;```c++</div>
<div class="line"><a name="l02304"></a><span class="lineno"> 2304</span>&#160;ProductOptions options;</div>
<div class="line"><a name="l02305"></a><span class="lineno"> 2305</span>&#160;options.set_precision_decimals(7);</div>
<div class="line"><a name="l02306"></a><span class="lineno"> 2306</span>&#160;options.set_use_cache(ProductOptions::kDontUseCache);</div>
<div class="line"><a name="l02307"></a><span class="lineno"> 2307</span>&#160;<span class="keyword">const</span> DecimalNumber product =</div>
<div class="line"><a name="l02308"></a><span class="lineno"> 2308</span>&#160;    CalculateProduct(values, options, <span class="comment">/*completion_callback=*/</span><span class="keyword">nullptr</span>);</div>
<div class="line"><a name="l02309"></a><span class="lineno"> 2309</span>&#160;```</div>
<div class="line"><a name="l02310"></a><span class="lineno"> 2310</span>&#160;</div>
<div class="line"><a name="l02311"></a><span class="lineno"> 2311</span>&#160;<span class="preprocessor">#### Don&#39;ts</span></div>
<div class="line"><a name="l02312"></a><span class="lineno"> 2312</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l02313"></a><span class="lineno"> 2313</span>&#160;Do not state the obvious. In particular, don<span class="stringliteral">&#39;t literally describe what code does, unless the behavior is nonobvious to a reader who understands C++ well. Instead, provide higher level comments that describe *why* the code does what it does, or make the code self describing.</span></div>
<div class="line"><a name="l02314"></a><span class="lineno"> 2314</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02315"></a><span class="lineno"> 2315</span>&#160;<span class="stringliteral">Compare this:</span></div>
<div class="line"><a name="l02316"></a><span class="lineno"> 2316</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02317"></a><span class="lineno"> 2317</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l02318"></a><span class="lineno"> 2318</span>&#160;<span class="stringliteral">// Find the element in the vector.  &lt;-- Bad: obvious!</span></div>
<div class="line"><a name="l02319"></a><span class="lineno"> 2319</span>&#160;<span class="stringliteral">auto iter = std::find(v.begin(), v.end(), element);</span></div>
<div class="line"><a name="l02320"></a><span class="lineno"> 2320</span>&#160;<span class="stringliteral">if (iter != v.end()) {</span></div>
<div class="line"><a name="l02321"></a><span class="lineno"> 2321</span>&#160;<span class="stringliteral">  Process(element);</span></div>
<div class="line"><a name="l02322"></a><span class="lineno"> 2322</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02323"></a><span class="lineno"> 2323</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l02324"></a><span class="lineno"> 2324</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02325"></a><span class="lineno"> 2325</span>&#160;<span class="stringliteral">To this:</span></div>
<div class="line"><a name="l02326"></a><span class="lineno"> 2326</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02327"></a><span class="lineno"> 2327</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l02328"></a><span class="lineno"> 2328</span>&#160;<span class="stringliteral">// Process &quot;element&quot; unless it was already processed.</span></div>
<div class="line"><a name="l02329"></a><span class="lineno"> 2329</span>&#160;<span class="stringliteral">auto iter = std::find(v.begin(), v.end(), element);</span></div>
<div class="line"><a name="l02330"></a><span class="lineno"> 2330</span>&#160;<span class="stringliteral">if (iter != v.end()) {</span></div>
<div class="line"><a name="l02331"></a><span class="lineno"> 2331</span>&#160;<span class="stringliteral">  Process(element);</span></div>
<div class="line"><a name="l02332"></a><span class="lineno"> 2332</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02333"></a><span class="lineno"> 2333</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l02334"></a><span class="lineno"> 2334</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02335"></a><span class="lineno"> 2335</span>&#160;<span class="stringliteral">Self-describing code doesn&#39;</span>t need a comment. The comment from the example above would be obvious:</div>
<div class="line"><a name="l02336"></a><span class="lineno"> 2336</span>&#160;</div>
<div class="line"><a name="l02337"></a><span class="lineno"> 2337</span>&#160;```c++</div>
<div class="line"><a name="l02338"></a><span class="lineno"> 2338</span>&#160;<span class="keywordflow">if</span> (!IsAlreadyProcessed(element)) {</div>
<div class="line"><a name="l02339"></a><span class="lineno"> 2339</span>&#160;  Process(element);</div>
<div class="line"><a name="l02340"></a><span class="lineno"> 2340</span>&#160;}</div>
<div class="line"><a name="l02341"></a><span class="lineno"> 2341</span>&#160;```</div>
<div class="line"><a name="l02342"></a><span class="lineno"> 2342</span>&#160;</div>
<div class="line"><a name="l02343"></a><span class="lineno"> 2343</span>&#160;<span class="preprocessor">### Punctuation, Spelling and Grammar</span></div>
<div class="line"><a name="l02344"></a><span class="lineno"> 2344</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l02345"></a><span class="lineno"> 2345</span>&#160;&gt; Pay attention to punctuation, spelling, and grammar; it is easier to read well-written comments than badly written ones.</div>
<div class="line"><a name="l02346"></a><span class="lineno"> 2346</span>&#160;</div>
<div class="line"><a name="l02347"></a><span class="lineno"> 2347</span>&#160;Comments should be as readable as narrative text, with proper capitalization and punctuation. In many cases, complete sentences are more readable than sentence fragments. Shorter comments, such as comments at the end of a line of code, can sometimes be less formal, but you should be consistent with your style.</div>
<div class="line"><a name="l02348"></a><span class="lineno"> 2348</span>&#160;</div>
<div class="line"><a name="l02349"></a><span class="lineno"> 2349</span>&#160;Although it can be frustrating to have a code reviewer point out that you are <span class="keyword">using</span> a comma when you should be <span class="keyword">using</span> a semicolon, it is very important that source code maintain a high level of clarity and readability. Proper punctuation, spelling, and grammar help with that goal.</div>
<div class="line"><a name="l02350"></a><span class="lineno"> 2350</span>&#160;</div>
<div class="line"><a name="l02351"></a><span class="lineno"> 2351</span>&#160;### TODO Comments</div>
<div class="line"><a name="l02352"></a><span class="lineno"> 2352</span>&#160;</div>
<div class="line"><a name="l02353"></a><span class="lineno"> 2353</span>&#160;&gt; Use `TODO` comments <span class="keywordflow">for</span> code that is temporary, a <span class="keywordtype">short</span>-term solution, or good-enough but not perfect.</div>
<div class="line"><a name="l02354"></a><span class="lineno"> 2354</span>&#160;</div>
<div class="line"><a name="l02355"></a><span class="lineno"> 2355</span>&#160;`TODO`s should include the <span class="keywordtype">string</span> `TODO` in all caps, followed by the name, e-mail address, bug ID, or other identifier of the person or issue with the best context about the problem referenced by the `TODO`. The main purpose is to have a consistent `TODO` that can be searched to find out how to <span class="keyword">get</span> more details upon request. A `TODO` is not a commitment that the person referenced will fix the problem. Thus when you create a `TODO` with a name, it is almost always your name that is given.</div>
<div class="line"><a name="l02356"></a><span class="lineno"> 2356</span>&#160;</div>
<div class="line"><a name="l02357"></a><span class="lineno"> 2357</span>&#160;```c++</div>
<div class="line"><a name="l02358"></a><span class="lineno"> 2358</span>&#160;<span class="comment">// TODO(kl@gmail.com): Use a &quot;*&quot; here for concatenation operator.</span></div>
<div class="line"><a name="l02359"></a><span class="lineno"> 2359</span>&#160;<span class="comment">// TODO(Zeke) change this to use relations.</span></div>
<div class="line"><a name="l02360"></a><span class="lineno"> 2360</span>&#160;<span class="comment">// TODO(bug 12345): remove the &quot;Last visitors&quot; feature</span></div>
<div class="line"><a name="l02361"></a><span class="lineno"> 2361</span>&#160;```</div>
<div class="line"><a name="l02362"></a><span class="lineno"> 2362</span>&#160;</div>
<div class="line"><a name="l02363"></a><span class="lineno"> 2363</span>&#160;If your `TODO` is of the form <span class="stringliteral">&quot;At a future date do something&quot;</span> make sure that you either include a very specific date (<span class="stringliteral">&quot;Fix by November 2005&quot;</span>) or a very specific event (&quot;Remove this code when all clients can handle XML responses.&quot;).</div>
<div class="line"><a name="l02364"></a><span class="lineno"> 2364</span>&#160;</div>
<div class="line"><a name="l02365"></a><span class="lineno"> 2365</span>&#160;<span class="preprocessor">### Deprecation Comments</span></div>
<div class="line"><a name="l02366"></a><span class="lineno"> 2366</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l02367"></a><span class="lineno"> 2367</span>&#160;&gt; Mark deprecated <span class="keyword">interface </span>points with `DEPRECATED` comments.</div>
<div class="line"><a name="l02368"></a><span class="lineno"> 2368</span>&#160;</div>
<div class="line"><a name="l02369"></a><span class="lineno"> 2369</span>&#160;You can mark an interface as deprecated by writing a comment containing the word `DEPRECATED` in all caps. The comment goes either before the declaration of the interface or on the same line as the declaration.</div>
<div class="line"><a name="l02370"></a><span class="lineno"> 2370</span>&#160;</div>
<div class="line"><a name="l02371"></a><span class="lineno"> 2371</span>&#160;After the word `DEPRECATED`, write your name, e-mail address, or other identifier in parentheses.</div>
<div class="line"><a name="l02372"></a><span class="lineno"> 2372</span>&#160;</div>
<div class="line"><a name="l02373"></a><span class="lineno"> 2373</span>&#160;A deprecation comment must include simple, clear directions for people to fix their callsites. In C++, you can implement a deprecated function as an inline function that calls the new interface point.</div>
<div class="line"><a name="l02374"></a><span class="lineno"> 2374</span>&#160;</div>
<div class="line"><a name="l02375"></a><span class="lineno"> 2375</span>&#160;Marking an interface point `DEPRECATED` will not magically cause any callsites to change. If you want people to actually stop using the deprecated facility, you will have to fix the callsites yourself or recruit a crew to help you.</div>
<div class="line"><a name="l02376"></a><span class="lineno"> 2376</span>&#160;</div>
<div class="line"><a name="l02377"></a><span class="lineno"> 2377</span>&#160;New code should not contain calls to deprecated interface points. Use the new interface point instead. If you cannot understand the directions, find the person who created the deprecation and ask them for help using the new interface point.</div>
<div class="line"><a name="l02378"></a><span class="lineno"> 2378</span>&#160;</div>
<div class="line"><a name="l02379"></a><span class="lineno"> 2379</span>&#160;## Formatting</div>
<div class="line"><a name="l02380"></a><span class="lineno"> 2380</span>&#160;</div>
<div class="line"><a name="l02381"></a><span class="lineno"> 2381</span>&#160;Coding style and formatting are pretty arbitrary, but a project is much easier to follow if everyone uses the same style. Individuals may not agree with every aspect of the formatting rules, and some of the rules may take some getting used to, but it is important that all project contributors follow the style rules so that they can all read and understand everyone&#39;s code easily.</div>
<div class="line"><a name="l02382"></a><span class="lineno"> 2382</span>&#160;</div>
<div class="line"><a name="l02383"></a><span class="lineno"> 2383</span>&#160;To help you format code correctly, we use &quot;Artistic Style&quot; 3.0. The `make astyle` target is available in the Kaleidoscope and plugin Makefiles. Our CI infrastructure enforces `astyle`&#39;s decisions.</div>
<div class="line"><a name="l02384"></a><span class="lineno"> 2384</span>&#160;</div>
<div class="line"><a name="l02385"></a><span class="lineno"> 2385</span>&#160;### Line Length</div>
<div class="line"><a name="l02386"></a><span class="lineno"> 2386</span>&#160;</div>
<div class="line"><a name="l02387"></a><span class="lineno"> 2387</span>&#160;&gt; Each line of text in your code should be at most 80 characters long.</div>
<div class="line"><a name="l02388"></a><span class="lineno"> 2388</span>&#160;</div>
<div class="line"><a name="l02389"></a><span class="lineno"> 2389</span>&#160;We recognize that this rule is controversial, but so much existing code already adheres to it, and we feel that consistency is important.</div>
<div class="line"><a name="l02390"></a><span class="lineno"> 2390</span>&#160;</div>
<div class="line"><a name="l02391"></a><span class="lineno"> 2391</span>&#160;**Pros**</div>
<div class="line"><a name="l02392"></a><span class="lineno"> 2392</span>&#160;</div>
<div class="line"><a name="l02393"></a><span class="lineno"> 2393</span>&#160;Those who favor <span class="keyword">this</span> rule argue that it is rude to force them to resize their windows and there is no need <span class="keywordflow">for</span> anything longer. Some folks are used to having several code windows side-by-side, and thus don<span class="stringliteral">&#39;t have room to widen their windows in any case. People set up their work environment assuming a particular maximum window width, and 80 columns has been the traditional standard. Why change it?</span></div>
<div class="line"><a name="l02394"></a><span class="lineno"> 2394</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02395"></a><span class="lineno"> 2395</span>&#160;<span class="stringliteral">**Cons**</span></div>
<div class="line"><a name="l02396"></a><span class="lineno"> 2396</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02397"></a><span class="lineno"> 2397</span>&#160;<span class="stringliteral">Proponents of change argue that a wider line can make code more readable. The 80-column limit is an hidebound throwback to 1960s mainframes; modern equipment has wide screens that can easily show longer lines.</span></div>
<div class="line"><a name="l02398"></a><span class="lineno"> 2398</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02399"></a><span class="lineno"> 2399</span>&#160;<span class="stringliteral">**Decision**</span></div>
<div class="line"><a name="l02400"></a><span class="lineno"> 2400</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02401"></a><span class="lineno"> 2401</span>&#160;<span class="stringliteral">80 characters is the maximum.</span></div>
<div class="line"><a name="l02402"></a><span class="lineno"> 2402</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02403"></a><span class="lineno"> 2403</span>&#160;<span class="stringliteral">**Exception**</span></div>
<div class="line"><a name="l02404"></a><span class="lineno"> 2404</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02405"></a><span class="lineno"> 2405</span>&#160;<span class="stringliteral">Comment lines can be longer than 80 characters if it is not feasible to split them without harming readability, ease of cut and paste or auto-linking -- e.g. if a line contains an example command or a literal URL longer than 80 characters.</span></div>
<div class="line"><a name="l02406"></a><span class="lineno"> 2406</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02407"></a><span class="lineno"> 2407</span>&#160;<span class="stringliteral">**Exception**</span></div>
<div class="line"><a name="l02408"></a><span class="lineno"> 2408</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02409"></a><span class="lineno"> 2409</span>&#160;<span class="stringliteral">A raw-string literal may have content that exceeds 80 characters. Except for test code, such literals should appear near the top of a file.</span></div>
<div class="line"><a name="l02410"></a><span class="lineno"> 2410</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02411"></a><span class="lineno"> 2411</span>&#160;<span class="stringliteral">**Exception**</span></div>
<div class="line"><a name="l02412"></a><span class="lineno"> 2412</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02413"></a><span class="lineno"> 2413</span>&#160;<span class="stringliteral">An `#include` statement with a long path may exceed 80 columns.</span></div>
<div class="line"><a name="l02414"></a><span class="lineno"> 2414</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02415"></a><span class="lineno"> 2415</span>&#160;<span class="stringliteral">### Non-ASCII Characters</span></div>
<div class="line"><a name="l02416"></a><span class="lineno"> 2416</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02417"></a><span class="lineno"> 2417</span>&#160;<span class="stringliteral">&gt; Non-ASCII characters should be rare, and must use UTF-8 formatting.</span></div>
<div class="line"><a name="l02418"></a><span class="lineno"> 2418</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02419"></a><span class="lineno"> 2419</span>&#160;<span class="stringliteral">You shouldn&#39;</span>t hard-code user-facing text in source, even English, so use of non-ASCII characters should be rare. However, in certain cases it is appropriate to include such words in your code. For example, <span class="keywordflow">if</span> your code parses data files from foreign sources, it may be appropriate to hard-code the non-ASCII string(s) used in those data files as delimiters. More commonly, unittest code (which does not need to be localized) might contain non-ASCII strings. In such cases, you should use UTF-8, since that is an encoding understood by most tools able to handle more than just ASCII.</div>
<div class="line"><a name="l02420"></a><span class="lineno"> 2420</span>&#160;</div>
<div class="line"><a name="l02421"></a><span class="lineno"> 2421</span>&#160;Hex encoding is also OK, and encouraged where it enhances readability - for example, `&quot;\xEF\xBB\xBF&quot;`, or, even more simply, `u8&quot;\uFEFF&quot;`, is the Unicode zero-width no-break space character, which would be invisible if included in the source as straight UTF-8.</div>
<div class="line"><a name="l02422"></a><span class="lineno"> 2422</span>&#160;</div>
<div class="line"><a name="l02423"></a><span class="lineno"> 2423</span>&#160;Use the `u8` prefix to guarantee that a <span class="keywordtype">string</span> literal containing `\uXXXX` escape sequences is encoded as UTF-8. Do not use it for strings containing non-ASCII characters encoded as UTF-8, because that will produce incorrect output if the compiler does not interpret the source file as UTF-8.</div>
<div class="line"><a name="l02424"></a><span class="lineno"> 2424</span>&#160;</div>
<div class="line"><a name="l02425"></a><span class="lineno"> 2425</span>&#160;You shouldn&#39;t use the C++11 `char16_t` and `char32_t` character types, since they&#39;re for non-UTF-8 text. For similar reasons you also shouldn&#39;t use `<span class="keywordtype">wchar_t</span>` (unless you&#39;re writing code that interacts with the Windows API, which uses `<span class="keywordtype">wchar_t</span>` extensively).</div>
<div class="line"><a name="l02426"></a><span class="lineno"> 2426</span>&#160;</div>
<div class="line"><a name="l02427"></a><span class="lineno"> 2427</span>&#160;<span class="preprocessor">### Spaces vs. Tabs</span></div>
<div class="line"><a name="l02428"></a><span class="lineno"> 2428</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l02429"></a><span class="lineno"> 2429</span>&#160;&gt; Use only spaces, and indent 2 spaces at a time.</div>
<div class="line"><a name="l02430"></a><span class="lineno"> 2430</span>&#160;</div>
<div class="line"><a name="l02431"></a><span class="lineno"> 2431</span>&#160;We use spaces <span class="keywordflow">for</span> indentation. Do not use tabs in your code. You should set your editor to emit spaces when you hit the tab key.</div>
<div class="line"><a name="l02432"></a><span class="lineno"> 2432</span>&#160;</div>
<div class="line"><a name="l02433"></a><span class="lineno"> 2433</span>&#160;### Function Declarations and Definitions</div>
<div class="line"><a name="l02434"></a><span class="lineno"> 2434</span>&#160;</div>
<div class="line"><a name="l02435"></a><span class="lineno"> 2435</span>&#160;&gt; Return type on the same line as <span class="keyword">function</span> name, parameters on the same line <span class="keywordflow">if</span> they fit. Wrap parameter lists which <span class="keywordflow">do</span> not fit on a single line as you would wrap arguments in a [<span class="keyword">function</span> call](#<span class="keyword">function</span>-calls).</div>
<div class="line"><a name="l02436"></a><span class="lineno"> 2436</span>&#160;</div>
<div class="line"><a name="l02437"></a><span class="lineno"> 2437</span>&#160;Functions look like <span class="keyword">this</span>:</div>
<div class="line"><a name="l02438"></a><span class="lineno"> 2438</span>&#160;</div>
<div class="line"><a name="l02439"></a><span class="lineno"> 2439</span>&#160;```c++</div>
<div class="line"><a name="l02440"></a><span class="lineno"> 2440</span>&#160;ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {</div>
<div class="line"><a name="l02441"></a><span class="lineno"> 2441</span>&#160;  DoSomething();</div>
<div class="line"><a name="l02442"></a><span class="lineno"> 2442</span>&#160;  ...</div>
<div class="line"><a name="l02443"></a><span class="lineno"> 2443</span>&#160;}</div>
<div class="line"><a name="l02444"></a><span class="lineno"> 2444</span>&#160;```</div>
<div class="line"><a name="l02445"></a><span class="lineno"> 2445</span>&#160;</div>
<div class="line"><a name="l02446"></a><span class="lineno"> 2446</span>&#160;If you have too much text to fit on one line:</div>
<div class="line"><a name="l02447"></a><span class="lineno"> 2447</span>&#160;</div>
<div class="line"><a name="l02448"></a><span class="lineno"> 2448</span>&#160;```c++</div>
<div class="line"><a name="l02449"></a><span class="lineno"> 2449</span>&#160;ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,</div>
<div class="line"><a name="l02450"></a><span class="lineno"> 2450</span>&#160;                                             Type par_name3) {</div>
<div class="line"><a name="l02451"></a><span class="lineno"> 2451</span>&#160;  DoSomething();</div>
<div class="line"><a name="l02452"></a><span class="lineno"> 2452</span>&#160;  ...</div>
<div class="line"><a name="l02453"></a><span class="lineno"> 2453</span>&#160;}</div>
<div class="line"><a name="l02454"></a><span class="lineno"> 2454</span>&#160;```</div>
<div class="line"><a name="l02455"></a><span class="lineno"> 2455</span>&#160;</div>
<div class="line"><a name="l02456"></a><span class="lineno"> 2456</span>&#160;or <span class="keywordflow">if</span> you cannot fit even the first parameter:</div>
<div class="line"><a name="l02457"></a><span class="lineno"> 2457</span>&#160;</div>
<div class="line"><a name="l02458"></a><span class="lineno"> 2458</span>&#160;```c++</div>
<div class="line"><a name="l02459"></a><span class="lineno"> 2459</span>&#160;ReturnType LongClassName::ReallyReallyReallyLongFunctionName(</div>
<div class="line"><a name="l02460"></a><span class="lineno"> 2460</span>&#160;    Type par_name1,  <span class="comment">// 4 space indent</span></div>
<div class="line"><a name="l02461"></a><span class="lineno"> 2461</span>&#160;    Type par_name2,</div>
<div class="line"><a name="l02462"></a><span class="lineno"> 2462</span>&#160;    Type par_name3) {</div>
<div class="line"><a name="l02463"></a><span class="lineno"> 2463</span>&#160;  DoSomething();  <span class="comment">// 2 space indent</span></div>
<div class="line"><a name="l02464"></a><span class="lineno"> 2464</span>&#160;  ...</div>
<div class="line"><a name="l02465"></a><span class="lineno"> 2465</span>&#160;}</div>
<div class="line"><a name="l02466"></a><span class="lineno"> 2466</span>&#160;```</div>
<div class="line"><a name="l02467"></a><span class="lineno"> 2467</span>&#160;</div>
<div class="line"><a name="l02468"></a><span class="lineno"> 2468</span>&#160;Some points to note:</div>
<div class="line"><a name="l02469"></a><span class="lineno"> 2469</span>&#160;</div>
<div class="line"><a name="l02470"></a><span class="lineno"> 2470</span>&#160;* Choose good parameter names.</div>
<div class="line"><a name="l02471"></a><span class="lineno"> 2471</span>&#160;* Parameter names may be omitted only <span class="keywordflow">if</span> the parameter is unused and its purpose is obvious.</div>
<div class="line"><a name="l02472"></a><span class="lineno"> 2472</span>&#160;* If you cannot fit the <span class="keywordflow">return</span> type and the <span class="keyword">function</span> name on a single line, <span class="keywordflow">break</span> between them.</div>
<div class="line"><a name="l02473"></a><span class="lineno"> 2473</span>&#160;* If you <span class="keywordflow">break</span> after the <span class="keywordflow">return</span> type of a <span class="keyword">function</span> declaration or definition, <span class="keywordflow">do</span> not indent.</div>
<div class="line"><a name="l02474"></a><span class="lineno"> 2474</span>&#160;* The open parenthesis is always on the same line as the <span class="keyword">function</span> name.</div>
<div class="line"><a name="l02475"></a><span class="lineno"> 2475</span>&#160;* There is never a space between the <span class="keyword">function</span> name and the open parenthesis.</div>
<div class="line"><a name="l02476"></a><span class="lineno"> 2476</span>&#160;* There is never a space between the parentheses and the parameters.</div>
<div class="line"><a name="l02477"></a><span class="lineno"> 2477</span>&#160;* The open curly brace is always on the end of the last line of the <span class="keyword">function</span> declaration, not the start of the next line.</div>
<div class="line"><a name="l02478"></a><span class="lineno"> 2478</span>&#160;* The close curly brace is either on the last line by itself or on the same line as the open curly brace.</div>
<div class="line"><a name="l02479"></a><span class="lineno"> 2479</span>&#160;* There should be a space between the close parenthesis and the open curly brace.</div>
<div class="line"><a name="l02480"></a><span class="lineno"> 2480</span>&#160;* All parameters should be aligned <span class="keywordflow">if</span> possible.</div>
<div class="line"><a name="l02481"></a><span class="lineno"> 2481</span>&#160;* Default indentation is 2 spaces.</div>
<div class="line"><a name="l02482"></a><span class="lineno"> 2482</span>&#160;* Wrapped parameters have a 4 space indent.</div>
<div class="line"><a name="l02483"></a><span class="lineno"> 2483</span>&#160;</div>
<div class="line"><a name="l02484"></a><span class="lineno"> 2484</span>&#160;Unused parameters that are obvious from context may be omitted:</div>
<div class="line"><a name="l02485"></a><span class="lineno"> 2485</span>&#160;</div>
<div class="line"><a name="l02486"></a><span class="lineno"> 2486</span>&#160;```c++</div>
<div class="line"><a name="l02487"></a><span class="lineno"> 2487</span>&#160;<span class="keyword">class </span>Foo {</div>
<div class="line"><a name="l02488"></a><span class="lineno"> 2488</span>&#160; <span class="keyword">public</span>:</div>
<div class="line"><a name="l02489"></a><span class="lineno"> 2489</span>&#160;  Foo(Foo&amp;&amp;);</div>
<div class="line"><a name="l02490"></a><span class="lineno"> 2490</span>&#160;  Foo(<span class="keyword">const</span> Foo&amp;);</div>
<div class="line"><a name="l02491"></a><span class="lineno"> 2491</span>&#160;  Foo&amp; operator=(Foo&amp;&amp;);</div>
<div class="line"><a name="l02492"></a><span class="lineno"> 2492</span>&#160;  Foo&amp; operator=(<span class="keyword">const</span> Foo&amp;);</div>
<div class="line"><a name="l02493"></a><span class="lineno"> 2493</span>&#160;};</div>
<div class="line"><a name="l02494"></a><span class="lineno"> 2494</span>&#160;```</div>
<div class="line"><a name="l02495"></a><span class="lineno"> 2495</span>&#160;</div>
<div class="line"><a name="l02496"></a><span class="lineno"> 2496</span>&#160;Unused parameters that might not be obvious should comment out the variable name in the <span class="keyword">function</span> definition:</div>
<div class="line"><a name="l02497"></a><span class="lineno"> 2497</span>&#160;</div>
<div class="line"><a name="l02498"></a><span class="lineno"> 2498</span>&#160;```c++</div>
<div class="line"><a name="l02499"></a><span class="lineno"> 2499</span>&#160;<span class="keyword">class </span>Shape {</div>
<div class="line"><a name="l02500"></a><span class="lineno"> 2500</span>&#160; <span class="keyword">public</span>:</div>
<div class="line"><a name="l02501"></a><span class="lineno"> 2501</span>&#160;  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Rotate(<span class="keywordtype">double</span> radians) = 0;</div>
<div class="line"><a name="l02502"></a><span class="lineno"> 2502</span>&#160;};</div>
<div class="line"><a name="l02503"></a><span class="lineno"> 2503</span>&#160;</div>
<div class="line"><a name="l02504"></a><span class="lineno"> 2504</span>&#160;<span class="keyword">class </span>Circle : <span class="keyword">public</span> Shape {</div>
<div class="line"><a name="l02505"></a><span class="lineno"> 2505</span>&#160; <span class="keyword">public</span>:</div>
<div class="line"><a name="l02506"></a><span class="lineno"> 2506</span>&#160;  <span class="keywordtype">void</span> Rotate(<span class="keywordtype">double</span> radians) <span class="keyword">override</span>;</div>
<div class="line"><a name="l02507"></a><span class="lineno"> 2507</span>&#160;};</div>
<div class="line"><a name="l02508"></a><span class="lineno"> 2508</span>&#160;</div>
<div class="line"><a name="l02509"></a><span class="lineno"> 2509</span>&#160;<span class="keywordtype">void</span> Circle::Rotate(<span class="keywordtype">double</span> <span class="comment">/*radians*/</span>) {}</div>
<div class="line"><a name="l02510"></a><span class="lineno"> 2510</span>&#160;```</div>
<div class="line"><a name="l02511"></a><span class="lineno"> 2511</span>&#160;</div>
<div class="line"><a name="l02512"></a><span class="lineno"> 2512</span>&#160;```c++</div>
<div class="line"><a name="l02513"></a><span class="lineno"> 2513</span>&#160;<span class="comment">// Bad - if someone wants to implement later, it&#39;s not clear what the</span></div>
<div class="line"><a name="l02514"></a><span class="lineno"> 2514</span>&#160;<span class="comment">// variable means.</span></div>
<div class="line"><a name="l02515"></a><span class="lineno"> 2515</span>&#160;<span class="keywordtype">void</span> Circle::Rotate(<span class="keywordtype">double</span>) {}</div>
<div class="line"><a name="l02516"></a><span class="lineno"> 2516</span>&#160;```</div>
<div class="line"><a name="l02517"></a><span class="lineno"> 2517</span>&#160;</div>
<div class="line"><a name="l02518"></a><span class="lineno"> 2518</span>&#160;Attributes, and macros that expand to attributes, appear at the very</div>
<div class="line"><a name="l02519"></a><span class="lineno"> 2519</span>&#160;beginning of the <span class="keyword">function</span> declaration or definition, before the</div>
<div class="line"><a name="l02520"></a><span class="lineno"> 2520</span>&#160;<span class="keywordflow">return</span> type:</div>
<div class="line"><a name="l02521"></a><span class="lineno"> 2521</span>&#160;</div>
<div class="line"><a name="l02522"></a><span class="lineno"> 2522</span>&#160;```c++</div>
<div class="line"><a name="l02523"></a><span class="lineno"> 2523</span>&#160;MUST_USE_RESULT <span class="keywordtype">bool</span> IsOK();</div>
<div class="line"><a name="l02524"></a><span class="lineno"> 2524</span>&#160;```</div>
<div class="line"><a name="l02525"></a><span class="lineno"> 2525</span>&#160;</div>
<div class="line"><a name="l02526"></a><span class="lineno"> 2526</span>&#160;<span class="preprocessor">### Formatting Lambda Expressions</span></div>
<div class="line"><a name="l02527"></a><span class="lineno"> 2527</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l02528"></a><span class="lineno"> 2528</span>&#160;&gt; Format parameters and bodies as <span class="keywordflow">for</span> any other <span class="keyword">function</span>, and capture lists like other comma-separated lists.</div>
<div class="line"><a name="l02529"></a><span class="lineno"> 2529</span>&#160;</div>
<div class="line"><a name="l02530"></a><span class="lineno"> 2530</span>&#160;For by-reference captures, <span class="keywordflow">do</span> not leave a space between the ampersand (&amp;) and the variable name.</div>
<div class="line"><a name="l02531"></a><span class="lineno"> 2531</span>&#160;</div>
<div class="line"><a name="l02532"></a><span class="lineno"> 2532</span>&#160;```c++</div>
<div class="line"><a name="l02533"></a><span class="lineno"> 2533</span>&#160;<span class="keywordtype">int</span> x = 0;</div>
<div class="line"><a name="l02534"></a><span class="lineno"> 2534</span>&#160;auto x_plus_n = [&amp;x](<span class="keywordtype">int</span> n) -&gt; <span class="keywordtype">int</span> { <span class="keywordflow">return</span> x + n; }</div>
<div class="line"><a name="l02535"></a><span class="lineno"> 2535</span>&#160;```</div>
<div class="line"><a name="l02536"></a><span class="lineno"> 2536</span>&#160;</div>
<div class="line"><a name="l02537"></a><span class="lineno"> 2537</span>&#160;Short lambdas may be written <span class="keyword">inline</span> as <span class="keyword">function</span> arguments.</div>
<div class="line"><a name="l02538"></a><span class="lineno"> 2538</span>&#160;</div>
<div class="line"><a name="l02539"></a><span class="lineno"> 2539</span>&#160;```c++</div>
<div class="line"><a name="l02540"></a><span class="lineno"> 2540</span>&#160;std::set&lt;int&gt; blacklist = {7, 8, 9};</div>
<div class="line"><a name="l02541"></a><span class="lineno"> 2541</span>&#160;std::vector&lt;int&gt; digits = {3, 9, 1, 8, 4, 7, 1};</div>
<div class="line"><a name="l02542"></a><span class="lineno"> 2542</span>&#160;digits.erase(std::remove_if(digits.begin(), digits.end(), [&amp;blacklist](<span class="keywordtype">int</span> i) {</div>
<div class="line"><a name="l02543"></a><span class="lineno"> 2543</span>&#160;               <span class="keywordflow">return</span> blacklist.find(i) != blacklist.end();</div>
<div class="line"><a name="l02544"></a><span class="lineno"> 2544</span>&#160;             }),</div>
<div class="line"><a name="l02545"></a><span class="lineno"> 2545</span>&#160;             digits.end());</div>
<div class="line"><a name="l02546"></a><span class="lineno"> 2546</span>&#160;```</div>
<div class="line"><a name="l02547"></a><span class="lineno"> 2547</span>&#160;</div>
<div class="line"><a name="l02548"></a><span class="lineno"> 2548</span>&#160;<span class="preprocessor">### Function Calls</span></div>
<div class="line"><a name="l02549"></a><span class="lineno"> 2549</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l02550"></a><span class="lineno"> 2550</span>&#160;&gt; Either write the call all on a single line, wrap the arguments at the parenthesis, or start the arguments on a <span class="keyword">new</span> line indented by four spaces and <span class="keywordflow">continue</span> at that 4 space indent. In the absence of other considerations, use the minimum number of lines, including placing multiple arguments on each line where appropriate.</div>
<div class="line"><a name="l02551"></a><span class="lineno"> 2551</span>&#160;</div>
<div class="line"><a name="l02552"></a><span class="lineno"> 2552</span>&#160;Function calls have the following format:</div>
<div class="line"><a name="l02553"></a><span class="lineno"> 2553</span>&#160;</div>
<div class="line"><a name="l02554"></a><span class="lineno"> 2554</span>&#160;```c++</div>
<div class="line"><a name="l02555"></a><span class="lineno"> 2555</span>&#160;<span class="keywordtype">bool</span> result = DoSomething(argument1, argument2, argument3);</div>
<div class="line"><a name="l02556"></a><span class="lineno"> 2556</span>&#160;```</div>
<div class="line"><a name="l02557"></a><span class="lineno"> 2557</span>&#160;</div>
<div class="line"><a name="l02558"></a><span class="lineno"> 2558</span>&#160;If the arguments <span class="keywordflow">do</span> not all fit on one line, they should be broken up onto multiple lines, with each subsequent line aligned with the first argument. Do not add spaces after the open paren or before the close paren:</div>
<div class="line"><a name="l02559"></a><span class="lineno"> 2559</span>&#160;</div>
<div class="line"><a name="l02560"></a><span class="lineno"> 2560</span>&#160;```c++</div>
<div class="line"><a name="l02561"></a><span class="lineno"> 2561</span>&#160;<span class="keywordtype">bool</span> result = DoSomething(averyveryveryverylongargument1,</div>
<div class="line"><a name="l02562"></a><span class="lineno"> 2562</span>&#160;                          argument2, argument3);</div>
<div class="line"><a name="l02563"></a><span class="lineno"> 2563</span>&#160;```</div>
<div class="line"><a name="l02564"></a><span class="lineno"> 2564</span>&#160;</div>
<div class="line"><a name="l02565"></a><span class="lineno"> 2565</span>&#160;Arguments may optionally all be placed on subsequent lines with a four space indent:</div>
<div class="line"><a name="l02566"></a><span class="lineno"> 2566</span>&#160;</div>
<div class="line"><a name="l02567"></a><span class="lineno"> 2567</span>&#160;```c++</div>
<div class="line"><a name="l02568"></a><span class="lineno"> 2568</span>&#160;<span class="keywordflow">if</span> (...) {</div>
<div class="line"><a name="l02569"></a><span class="lineno"> 2569</span>&#160;  ...</div>
<div class="line"><a name="l02570"></a><span class="lineno"> 2570</span>&#160;  ...</div>
<div class="line"><a name="l02571"></a><span class="lineno"> 2571</span>&#160;  <span class="keywordflow">if</span> (...) {</div>
<div class="line"><a name="l02572"></a><span class="lineno"> 2572</span>&#160;    <span class="keywordtype">bool</span> result = DoSomething(</div>
<div class="line"><a name="l02573"></a><span class="lineno"> 2573</span>&#160;        argument1, argument2,  <span class="comment">// 4 space indent</span></div>
<div class="line"><a name="l02574"></a><span class="lineno"> 2574</span>&#160;        argument3, argument4);</div>
<div class="line"><a name="l02575"></a><span class="lineno"> 2575</span>&#160;    ...</div>
<div class="line"><a name="l02576"></a><span class="lineno"> 2576</span>&#160;  }</div>
<div class="line"><a name="l02577"></a><span class="lineno"> 2577</span>&#160;```</div>
<div class="line"><a name="l02578"></a><span class="lineno"> 2578</span>&#160;</div>
<div class="line"><a name="l02579"></a><span class="lineno"> 2579</span>&#160;Put multiple arguments on a single line to reduce the number of lines necessary <span class="keywordflow">for</span> calling a <span class="keyword">function</span> unless there is a specific readability problem. Some find that formatting with strictly one argument on each line is more readable and simplifies editing of the arguments. However, we prioritize <span class="keywordflow">for</span> the reader over the ease of editing arguments, and most readability problems are better addressed with the following techniques.</div>
<div class="line"><a name="l02580"></a><span class="lineno"> 2580</span>&#160;</div>
<div class="line"><a name="l02581"></a><span class="lineno"> 2581</span>&#160;If having multiple arguments in a single line decreases readability due to the complexity or confusing nature of the expressions that make up some arguments, <span class="keywordflow">try</span> creating variables that capture those arguments in a descriptive name:</div>
<div class="line"><a name="l02582"></a><span class="lineno"> 2582</span>&#160;</div>
<div class="line"><a name="l02583"></a><span class="lineno"> 2583</span>&#160;```c++</div>
<div class="line"><a name="l02584"></a><span class="lineno"> 2584</span>&#160;<span class="keywordtype">int</span> my_heuristic = scores[x] * y + bases[x];</div>
<div class="line"><a name="l02585"></a><span class="lineno"> 2585</span>&#160;<span class="keywordtype">bool</span> result = DoSomething(my_heuristic, x, y, z);</div>
<div class="line"><a name="l02586"></a><span class="lineno"> 2586</span>&#160;```</div>
<div class="line"><a name="l02587"></a><span class="lineno"> 2587</span>&#160;</div>
<div class="line"><a name="l02588"></a><span class="lineno"> 2588</span>&#160;Or put the confusing argument on its own line with an explanatory comment:</div>
<div class="line"><a name="l02589"></a><span class="lineno"> 2589</span>&#160;</div>
<div class="line"><a name="l02590"></a><span class="lineno"> 2590</span>&#160;```c++</div>
<div class="line"><a name="l02591"></a><span class="lineno"> 2591</span>&#160;<span class="keywordtype">bool</span> result = DoSomething(scores[x] * y + bases[x],  <span class="comment">// Score heuristic.</span></div>
<div class="line"><a name="l02592"></a><span class="lineno"> 2592</span>&#160;                          x, y, z);</div>
<div class="line"><a name="l02593"></a><span class="lineno"> 2593</span>&#160;```</div>
<div class="line"><a name="l02594"></a><span class="lineno"> 2594</span>&#160;</div>
<div class="line"><a name="l02595"></a><span class="lineno"> 2595</span>&#160;If there is still a <span class="keywordflow">case</span> where one argument is significantly more readable on its own line, then put it on its own line. The decision should be specific to the argument which is made more readable rather than a general policy.</div>
<div class="line"><a name="l02596"></a><span class="lineno"> 2596</span>&#160;</div>
<div class="line"><a name="l02597"></a><span class="lineno"> 2597</span>&#160;Sometimes arguments form a structure that is important <span class="keywordflow">for</span> readability. In those cases, feel free to format the arguments according to that structure:</div>
<div class="line"><a name="l02598"></a><span class="lineno"> 2598</span>&#160;</div>
<div class="line"><a name="l02599"></a><span class="lineno"> 2599</span>&#160;```c++</div>
<div class="line"><a name="l02600"></a><span class="lineno"> 2600</span>&#160;<span class="comment">// Transform the widget by a 3x3 matrix.</span></div>
<div class="line"><a name="l02601"></a><span class="lineno"> 2601</span>&#160;my_widget.Transform(x1, x2, x3,</div>
<div class="line"><a name="l02602"></a><span class="lineno"> 2602</span>&#160;                    y1, y2, y3,</div>
<div class="line"><a name="l02603"></a><span class="lineno"> 2603</span>&#160;                    z1, z2, z3);</div>
<div class="line"><a name="l02604"></a><span class="lineno"> 2604</span>&#160;```</div>
<div class="line"><a name="l02605"></a><span class="lineno"> 2605</span>&#160;</div>
<div class="line"><a name="l02606"></a><span class="lineno"> 2606</span>&#160;<span class="preprocessor">### Braced Initializer List Format</span></div>
<div class="line"><a name="l02607"></a><span class="lineno"> 2607</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l02608"></a><span class="lineno"> 2608</span>&#160;&gt; Format a [braced initializer list](#braced-initializer-list) exactly like you would format a <span class="keyword">function</span> call in its place.</div>
<div class="line"><a name="l02609"></a><span class="lineno"> 2609</span>&#160;</div>
<div class="line"><a name="l02610"></a><span class="lineno"> 2610</span>&#160;If the braced list follows a name (e.g. a type or variable name), format as <span class="keywordflow">if</span> the `{}` were the parentheses of a <span class="keyword">function</span> call with that name. If there is no name, assume a zero-length name.</div>
<div class="line"><a name="l02611"></a><span class="lineno"> 2611</span>&#160;</div>
<div class="line"><a name="l02612"></a><span class="lineno"> 2612</span>&#160;```c++</div>
<div class="line"><a name="l02613"></a><span class="lineno"> 2613</span>&#160;<span class="comment">// Examples of braced init list on a single line.</span></div>
<div class="line"><a name="l02614"></a><span class="lineno"> 2614</span>&#160;<span class="keywordflow">return</span> {foo, bar};</div>
<div class="line"><a name="l02615"></a><span class="lineno"> 2615</span>&#160;functioncall({foo, bar});</div>
<div class="line"><a name="l02616"></a><span class="lineno"> 2616</span>&#160;std::pair&lt;int, int&gt; p{foo, bar};</div>
<div class="line"><a name="l02617"></a><span class="lineno"> 2617</span>&#160;</div>
<div class="line"><a name="l02618"></a><span class="lineno"> 2618</span>&#160;<span class="comment">// When you have to wrap.</span></div>
<div class="line"><a name="l02619"></a><span class="lineno"> 2619</span>&#160;SomeFunction(</div>
<div class="line"><a name="l02620"></a><span class="lineno"> 2620</span>&#160;    {<span class="stringliteral">&quot;assume a zero-length name before {&quot;</span>},</div>
<div class="line"><a name="l02621"></a><span class="lineno"> 2621</span>&#160;    some_other_function_parameter);</div>
<div class="line"><a name="l02622"></a><span class="lineno"> 2622</span>&#160;SomeType variable{</div>
<div class="line"><a name="l02623"></a><span class="lineno"> 2623</span>&#160;    some, other, values,</div>
<div class="line"><a name="l02624"></a><span class="lineno"> 2624</span>&#160;    {<span class="stringliteral">&quot;assume a zero-length name before {&quot;</span>},</div>
<div class="line"><a name="l02625"></a><span class="lineno"> 2625</span>&#160;    SomeOtherType{</div>
<div class="line"><a name="l02626"></a><span class="lineno"> 2626</span>&#160;        <span class="stringliteral">&quot;Very long string requiring the surrounding breaks.&quot;</span>,</div>
<div class="line"><a name="l02627"></a><span class="lineno"> 2627</span>&#160;        some, other values},</div>
<div class="line"><a name="l02628"></a><span class="lineno"> 2628</span>&#160;    SomeOtherType{<span class="stringliteral">&quot;Slightly shorter string&quot;</span>,</div>
<div class="line"><a name="l02629"></a><span class="lineno"> 2629</span>&#160;                  some, other, values}};</div>
<div class="line"><a name="l02630"></a><span class="lineno"> 2630</span>&#160;SomeType variable{</div>
<div class="line"><a name="l02631"></a><span class="lineno"> 2631</span>&#160;    <span class="stringliteral">&quot;This is too long to fit all in one line&quot;</span>};</div>
<div class="line"><a name="l02632"></a><span class="lineno"> 2632</span>&#160;MyType m = {  <span class="comment">// Here, you could also break before {.</span></div>
<div class="line"><a name="l02633"></a><span class="lineno"> 2633</span>&#160;    superlongvariablename1,</div>
<div class="line"><a name="l02634"></a><span class="lineno"> 2634</span>&#160;    superlongvariablename2,</div>
<div class="line"><a name="l02635"></a><span class="lineno"> 2635</span>&#160;    {short, interior, list},</div>
<div class="line"><a name="l02636"></a><span class="lineno"> 2636</span>&#160;    {interiorwrappinglist,</div>
<div class="line"><a name="l02637"></a><span class="lineno"> 2637</span>&#160;     interiorwrappinglist2}};</div>
<div class="line"><a name="l02638"></a><span class="lineno"> 2638</span>&#160;```</div>
<div class="line"><a name="l02639"></a><span class="lineno"> 2639</span>&#160;</div>
<div class="line"><a name="l02640"></a><span class="lineno"> 2640</span>&#160;<span class="preprocessor">### Conditionals</span></div>
<div class="line"><a name="l02641"></a><span class="lineno"> 2641</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l02642"></a><span class="lineno"> 2642</span>&#160;&gt; Prefer no spaces inside parentheses. The `<span class="keywordflow">if</span>` and `<span class="keywordflow">else</span>` keywords belong on separate lines.</div>
<div class="line"><a name="l02643"></a><span class="lineno"> 2643</span>&#160;</div>
<div class="line"><a name="l02644"></a><span class="lineno"> 2644</span>&#160;There are two acceptable formats <span class="keywordflow">for</span> a basic</div>
<div class="line"><a name="l02645"></a><span class="lineno"> 2645</span>&#160;conditional statement. One includes spaces between the</div>
<div class="line"><a name="l02646"></a><span class="lineno"> 2646</span>&#160;parentheses and the condition, and one does not.</div>
<div class="line"><a name="l02647"></a><span class="lineno"> 2647</span>&#160;</div>
<div class="line"><a name="l02648"></a><span class="lineno"> 2648</span>&#160;The most common form is without spaces. Either is fine, but *be consistent*. If you are modifying a file, use the format that is already present. If you are writing <span class="keyword">new</span> code, use the format that the other files in that directory or project use. If in doubt and you have no personal preference, <span class="keywordflow">do</span> not add the spaces.</div>
<div class="line"><a name="l02649"></a><span class="lineno"> 2649</span>&#160;</div>
<div class="line"><a name="l02650"></a><span class="lineno"> 2650</span>&#160;```c++</div>
<div class="line"><a name="l02651"></a><span class="lineno"> 2651</span>&#160;<span class="keywordflow">if</span> (condition) {  <span class="comment">// no spaces inside parentheses</span></div>
<div class="line"><a name="l02652"></a><span class="lineno"> 2652</span>&#160;  ...  <span class="comment">// 2 space indent.</span></div>
<div class="line"><a name="l02653"></a><span class="lineno"> 2653</span>&#160;} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (...) {  <span class="comment">// The else goes on the same line as the closing brace.</span></div>
<div class="line"><a name="l02654"></a><span class="lineno"> 2654</span>&#160;  ...</div>
<div class="line"><a name="l02655"></a><span class="lineno"> 2655</span>&#160;} <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l02656"></a><span class="lineno"> 2656</span>&#160;  ...</div>
<div class="line"><a name="l02657"></a><span class="lineno"> 2657</span>&#160;}</div>
<div class="line"><a name="l02658"></a><span class="lineno"> 2658</span>&#160;```</div>
<div class="line"><a name="l02659"></a><span class="lineno"> 2659</span>&#160;</div>
<div class="line"><a name="l02660"></a><span class="lineno"> 2660</span>&#160;If you prefer you may add spaces inside the parentheses:</div>
<div class="line"><a name="l02661"></a><span class="lineno"> 2661</span>&#160;</div>
<div class="line"><a name="l02662"></a><span class="lineno"> 2662</span>&#160;```c++</div>
<div class="line"><a name="l02663"></a><span class="lineno"> 2663</span>&#160;<span class="keywordflow">if</span> ( condition ) {  <span class="comment">// spaces inside parentheses - rare</span></div>
<div class="line"><a name="l02664"></a><span class="lineno"> 2664</span>&#160;  ...  <span class="comment">// 2 space indent.</span></div>
<div class="line"><a name="l02665"></a><span class="lineno"> 2665</span>&#160;} <span class="keywordflow">else</span> {  <span class="comment">// The else goes on the same line as the closing brace.</span></div>
<div class="line"><a name="l02666"></a><span class="lineno"> 2666</span>&#160;  ...</div>
<div class="line"><a name="l02667"></a><span class="lineno"> 2667</span>&#160;}</div>
<div class="line"><a name="l02668"></a><span class="lineno"> 2668</span>&#160;```</div>
<div class="line"><a name="l02669"></a><span class="lineno"> 2669</span>&#160;</div>
<div class="line"><a name="l02670"></a><span class="lineno"> 2670</span>&#160;Note that in all cases you must have a space between the `<span class="keywordflow">if</span>` and the open parenthesis. You must also have a space between the close parenthesis and the curly brace, <span class="keywordflow">if</span> you<span class="stringliteral">&#39;re using one.</span></div>
<div class="line"><a name="l02671"></a><span class="lineno"> 2671</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02672"></a><span class="lineno"> 2672</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l02673"></a><span class="lineno"> 2673</span>&#160;<span class="stringliteral">if(condition) {   // Bad - space missing after IF.</span></div>
<div class="line"><a name="l02674"></a><span class="lineno"> 2674</span>&#160;<span class="stringliteral">if (condition){   // Bad - space missing before {.</span></div>
<div class="line"><a name="l02675"></a><span class="lineno"> 2675</span>&#160;<span class="stringliteral">if(condition){    // Doubly bad.</span></div>
<div class="line"><a name="l02676"></a><span class="lineno"> 2676</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02677"></a><span class="lineno"> 2677</span>&#160;<span class="stringliteral">if (condition) {  // Good - proper space after IF and before {.</span></div>
<div class="line"><a name="l02678"></a><span class="lineno"> 2678</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l02679"></a><span class="lineno"> 2679</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02680"></a><span class="lineno"> 2680</span>&#160;<span class="stringliteral">Short conditional statements may be written on one line if this enhances readability. You may use this only when the line is brief and the statement does not use the `else` clause.</span></div>
<div class="line"><a name="l02681"></a><span class="lineno"> 2681</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02682"></a><span class="lineno"> 2682</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l02683"></a><span class="lineno"> 2683</span>&#160;<span class="stringliteral">if (x == kFoo) return new Foo();</span></div>
<div class="line"><a name="l02684"></a><span class="lineno"> 2684</span>&#160;<span class="stringliteral">if (x == kBar) return new Bar();</span></div>
<div class="line"><a name="l02685"></a><span class="lineno"> 2685</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l02686"></a><span class="lineno"> 2686</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02687"></a><span class="lineno"> 2687</span>&#160;<span class="stringliteral">This is not allowed when the if statement has an `else`:</span></div>
<div class="line"><a name="l02688"></a><span class="lineno"> 2688</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02689"></a><span class="lineno"> 2689</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l02690"></a><span class="lineno"> 2690</span>&#160;<span class="stringliteral">// Not allowed - IF statement on one line when there is an ELSE clause</span></div>
<div class="line"><a name="l02691"></a><span class="lineno"> 2691</span>&#160;<span class="stringliteral">if (x) DoThis();</span></div>
<div class="line"><a name="l02692"></a><span class="lineno"> 2692</span>&#160;<span class="stringliteral">else DoThat();</span></div>
<div class="line"><a name="l02693"></a><span class="lineno"> 2693</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l02694"></a><span class="lineno"> 2694</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02695"></a><span class="lineno"> 2695</span>&#160;<span class="stringliteral">In general, curly braces are not required for single-line statements, but they are allowed if you like them; conditional or loop statements with complex conditions or statements may be more readable with curly braces. Some projects require that an `if` must always always have an accompanying brace.</span></div>
<div class="line"><a name="l02696"></a><span class="lineno"> 2696</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02697"></a><span class="lineno"> 2697</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l02698"></a><span class="lineno"> 2698</span>&#160;<span class="stringliteral">if (condition)</span></div>
<div class="line"><a name="l02699"></a><span class="lineno"> 2699</span>&#160;<span class="stringliteral">  DoSomething();  // 2 space indent.</span></div>
<div class="line"><a name="l02700"></a><span class="lineno"> 2700</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02701"></a><span class="lineno"> 2701</span>&#160;<span class="stringliteral">if (condition) {</span></div>
<div class="line"><a name="l02702"></a><span class="lineno"> 2702</span>&#160;<span class="stringliteral">  DoSomething();  // 2 space indent.</span></div>
<div class="line"><a name="l02703"></a><span class="lineno"> 2703</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02704"></a><span class="lineno"> 2704</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l02705"></a><span class="lineno"> 2705</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02706"></a><span class="lineno"> 2706</span>&#160;<span class="stringliteral">However, if one part of an `if`-`else` statement uses curly braces, the other part must too:</span></div>
<div class="line"><a name="l02707"></a><span class="lineno"> 2707</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02708"></a><span class="lineno"> 2708</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l02709"></a><span class="lineno"> 2709</span>&#160;<span class="stringliteral">// Not allowed - curly on IF but not ELSE</span></div>
<div class="line"><a name="l02710"></a><span class="lineno"> 2710</span>&#160;<span class="stringliteral">if (condition) {</span></div>
<div class="line"><a name="l02711"></a><span class="lineno"> 2711</span>&#160;<span class="stringliteral">  foo;</span></div>
<div class="line"><a name="l02712"></a><span class="lineno"> 2712</span>&#160;<span class="stringliteral">} else</span></div>
<div class="line"><a name="l02713"></a><span class="lineno"> 2713</span>&#160;<span class="stringliteral">  bar;</span></div>
<div class="line"><a name="l02714"></a><span class="lineno"> 2714</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02715"></a><span class="lineno"> 2715</span>&#160;<span class="stringliteral">// Not allowed - curly on ELSE but not IF</span></div>
<div class="line"><a name="l02716"></a><span class="lineno"> 2716</span>&#160;<span class="stringliteral">if (condition)</span></div>
<div class="line"><a name="l02717"></a><span class="lineno"> 2717</span>&#160;<span class="stringliteral">  foo;</span></div>
<div class="line"><a name="l02718"></a><span class="lineno"> 2718</span>&#160;<span class="stringliteral">else {</span></div>
<div class="line"><a name="l02719"></a><span class="lineno"> 2719</span>&#160;<span class="stringliteral">  bar;</span></div>
<div class="line"><a name="l02720"></a><span class="lineno"> 2720</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02721"></a><span class="lineno"> 2721</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l02722"></a><span class="lineno"> 2722</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02723"></a><span class="lineno"> 2723</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l02724"></a><span class="lineno"> 2724</span>&#160;<span class="stringliteral">// Curly braces around both IF and ELSE required because</span></div>
<div class="line"><a name="l02725"></a><span class="lineno"> 2725</span>&#160;<span class="stringliteral">// one of the clauses used braces.</span></div>
<div class="line"><a name="l02726"></a><span class="lineno"> 2726</span>&#160;<span class="stringliteral">if (condition) {</span></div>
<div class="line"><a name="l02727"></a><span class="lineno"> 2727</span>&#160;<span class="stringliteral">  foo;</span></div>
<div class="line"><a name="l02728"></a><span class="lineno"> 2728</span>&#160;<span class="stringliteral">} else {</span></div>
<div class="line"><a name="l02729"></a><span class="lineno"> 2729</span>&#160;<span class="stringliteral">  bar;</span></div>
<div class="line"><a name="l02730"></a><span class="lineno"> 2730</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02731"></a><span class="lineno"> 2731</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l02732"></a><span class="lineno"> 2732</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02733"></a><span class="lineno"> 2733</span>&#160;<span class="stringliteral">### Loops and Switch Statements</span></div>
<div class="line"><a name="l02734"></a><span class="lineno"> 2734</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02735"></a><span class="lineno"> 2735</span>&#160;<span class="stringliteral">&gt; Switch statements may use braces for blocks. Annotate non-trivial fall-through between cases. Braces are optional for single-statement loops. Empty loop bodies should use empty braces or `continue`.</span></div>
<div class="line"><a name="l02736"></a><span class="lineno"> 2736</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02737"></a><span class="lineno"> 2737</span>&#160;<span class="stringliteral">`case` blocks in `switch` statements can have curly braces or not, depending on your preference. If you do include curly braces they should be placed as shown below.</span></div>
<div class="line"><a name="l02738"></a><span class="lineno"> 2738</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02739"></a><span class="lineno"> 2739</span>&#160;<span class="stringliteral">If not conditional on an enumerated value, switch statements should always have a `default` case (in the case of an enumerated value, the compiler will warn you if any values are not handled). If the default case should never execute, simply `assert`:</span></div>
<div class="line"><a name="l02740"></a><span class="lineno"> 2740</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02741"></a><span class="lineno"> 2741</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l02742"></a><span class="lineno"> 2742</span>&#160;<span class="stringliteral">switch (var) {</span></div>
<div class="line"><a name="l02743"></a><span class="lineno"> 2743</span>&#160;<span class="stringliteral">  case 0: {  // 2 space indent</span></div>
<div class="line"><a name="l02744"></a><span class="lineno"> 2744</span>&#160;<span class="stringliteral">    ...      // 4 space indent</span></div>
<div class="line"><a name="l02745"></a><span class="lineno"> 2745</span>&#160;<span class="stringliteral">    break;</span></div>
<div class="line"><a name="l02746"></a><span class="lineno"> 2746</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02747"></a><span class="lineno"> 2747</span>&#160;<span class="stringliteral">  case 1: {</span></div>
<div class="line"><a name="l02748"></a><span class="lineno"> 2748</span>&#160;<span class="stringliteral">    ...</span></div>
<div class="line"><a name="l02749"></a><span class="lineno"> 2749</span>&#160;<span class="stringliteral">    break;</span></div>
<div class="line"><a name="l02750"></a><span class="lineno"> 2750</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02751"></a><span class="lineno"> 2751</span>&#160;<span class="stringliteral">  default: {</span></div>
<div class="line"><a name="l02752"></a><span class="lineno"> 2752</span>&#160;<span class="stringliteral">    assert(false);</span></div>
<div class="line"><a name="l02753"></a><span class="lineno"> 2753</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02754"></a><span class="lineno"> 2754</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02755"></a><span class="lineno"> 2755</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l02756"></a><span class="lineno"> 2756</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02757"></a><span class="lineno"> 2757</span>&#160;<span class="stringliteral">Braces are optional for single-statement loops.</span></div>
<div class="line"><a name="l02758"></a><span class="lineno"> 2758</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02759"></a><span class="lineno"> 2759</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l02760"></a><span class="lineno"> 2760</span>&#160;<span class="stringliteral">for (int i = 0; i &lt; kSomeNumber; ++i)</span></div>
<div class="line"><a name="l02761"></a><span class="lineno"> 2761</span>&#160;<span class="stringliteral">  printf(&quot;I love you\n&quot;);</span></div>
<div class="line"><a name="l02762"></a><span class="lineno"> 2762</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02763"></a><span class="lineno"> 2763</span>&#160;<span class="stringliteral">for (int i = 0; i &lt; kSomeNumber; ++i) {</span></div>
<div class="line"><a name="l02764"></a><span class="lineno"> 2764</span>&#160;<span class="stringliteral">  printf(&quot;I take it back\n&quot;);</span></div>
<div class="line"><a name="l02765"></a><span class="lineno"> 2765</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02766"></a><span class="lineno"> 2766</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l02767"></a><span class="lineno"> 2767</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02768"></a><span class="lineno"> 2768</span>&#160;<span class="stringliteral">Empty loop bodies should use an empty pair of braces or `continue`, but not a single semicolon.</span></div>
<div class="line"><a name="l02769"></a><span class="lineno"> 2769</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02770"></a><span class="lineno"> 2770</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l02771"></a><span class="lineno"> 2771</span>&#160;<span class="stringliteral">while (condition) {</span></div>
<div class="line"><a name="l02772"></a><span class="lineno"> 2772</span>&#160;<span class="stringliteral">  // Repeat test until it returns false.</span></div>
<div class="line"><a name="l02773"></a><span class="lineno"> 2773</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02774"></a><span class="lineno"> 2774</span>&#160;<span class="stringliteral">for (int i = 0; i &lt; kSomeNumber; ++i) {}  // Good - one newline is also OK.</span></div>
<div class="line"><a name="l02775"></a><span class="lineno"> 2775</span>&#160;<span class="stringliteral">while (condition) continue;  // Good - continue indicates no logic.</span></div>
<div class="line"><a name="l02776"></a><span class="lineno"> 2776</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l02777"></a><span class="lineno"> 2777</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02778"></a><span class="lineno"> 2778</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l02779"></a><span class="lineno"> 2779</span>&#160;<span class="stringliteral">while (condition);  // Bad - looks like part of do/while loop.</span></div>
<div class="line"><a name="l02780"></a><span class="lineno"> 2780</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l02781"></a><span class="lineno"> 2781</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02782"></a><span class="lineno"> 2782</span>&#160;<span class="stringliteral">### Pointer and Reference Expressions</span></div>
<div class="line"><a name="l02783"></a><span class="lineno"> 2783</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02784"></a><span class="lineno"> 2784</span>&#160;<span class="stringliteral">&gt; No spaces around period or arrow. Pointer operators do not have trailing spaces.</span></div>
<div class="line"><a name="l02785"></a><span class="lineno"> 2785</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02786"></a><span class="lineno"> 2786</span>&#160;<span class="stringliteral">The following are examples of correctly-formatted pointer and reference expressions:</span></div>
<div class="line"><a name="l02787"></a><span class="lineno"> 2787</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02788"></a><span class="lineno"> 2788</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l02789"></a><span class="lineno"> 2789</span>&#160;<span class="stringliteral">x = *p;</span></div>
<div class="line"><a name="l02790"></a><span class="lineno"> 2790</span>&#160;<span class="stringliteral">p = &amp;x;</span></div>
<div class="line"><a name="l02791"></a><span class="lineno"> 2791</span>&#160;<span class="stringliteral">x = r.y;</span></div>
<div class="line"><a name="l02792"></a><span class="lineno"> 2792</span>&#160;<span class="stringliteral">x = r-&gt;y;</span></div>
<div class="line"><a name="l02793"></a><span class="lineno"> 2793</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l02794"></a><span class="lineno"> 2794</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02795"></a><span class="lineno"> 2795</span>&#160;<span class="stringliteral">Note that:</span></div>
<div class="line"><a name="l02796"></a><span class="lineno"> 2796</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02797"></a><span class="lineno"> 2797</span>&#160;<span class="stringliteral">* There are no spaces around the period or arrow when accessing a member.</span></div>
<div class="line"><a name="l02798"></a><span class="lineno"> 2798</span>&#160;<span class="stringliteral">* Pointer operators have no space after the `*` or `&amp;`.</span></div>
<div class="line"><a name="l02799"></a><span class="lineno"> 2799</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02800"></a><span class="lineno"> 2800</span>&#160;<span class="stringliteral">When declaring a pointer variable or argument, you may place the asterisk adjacent to either the type or to the variable name:</span></div>
<div class="line"><a name="l02801"></a><span class="lineno"> 2801</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02802"></a><span class="lineno"> 2802</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l02803"></a><span class="lineno"> 2803</span>&#160;<span class="stringliteral">// These are fine, space preceding.</span></div>
<div class="line"><a name="l02804"></a><span class="lineno"> 2804</span>&#160;<span class="stringliteral">char *c;</span></div>
<div class="line"><a name="l02805"></a><span class="lineno"> 2805</span>&#160;<span class="stringliteral">const string &amp;str;</span></div>
<div class="line"><a name="l02806"></a><span class="lineno"> 2806</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02807"></a><span class="lineno"> 2807</span>&#160;<span class="stringliteral">// These are fine, space following.</span></div>
<div class="line"><a name="l02808"></a><span class="lineno"> 2808</span>&#160;<span class="stringliteral">char* c;</span></div>
<div class="line"><a name="l02809"></a><span class="lineno"> 2809</span>&#160;<span class="stringliteral">const string&amp; str;</span></div>
<div class="line"><a name="l02810"></a><span class="lineno"> 2810</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l02811"></a><span class="lineno"> 2811</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02812"></a><span class="lineno"> 2812</span>&#160;<span class="stringliteral">It is allowed (if unusual) to declare multiple variables in the same declaration, but it is disallowed if any of those have pointer or reference decorations. Such declarations are easily misread.</span></div>
<div class="line"><a name="l02813"></a><span class="lineno"> 2813</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02814"></a><span class="lineno"> 2814</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l02815"></a><span class="lineno"> 2815</span>&#160;<span class="stringliteral">// Fine if helpful for readability.</span></div>
<div class="line"><a name="l02816"></a><span class="lineno"> 2816</span>&#160;<span class="stringliteral">int x, y;</span></div>
<div class="line"><a name="l02817"></a><span class="lineno"> 2817</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l02818"></a><span class="lineno"> 2818</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02819"></a><span class="lineno"> 2819</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l02820"></a><span class="lineno"> 2820</span>&#160;<span class="stringliteral">int x, *y;  // Disallowed - no &amp; or * in multiple declaration</span></div>
<div class="line"><a name="l02821"></a><span class="lineno"> 2821</span>&#160;<span class="stringliteral">char * c;  // Bad - spaces on both sides of *</span></div>
<div class="line"><a name="l02822"></a><span class="lineno"> 2822</span>&#160;<span class="stringliteral">const string &amp; str;  // Bad - spaces on both sides of &amp;</span></div>
<div class="line"><a name="l02823"></a><span class="lineno"> 2823</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l02824"></a><span class="lineno"> 2824</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02825"></a><span class="lineno"> 2825</span>&#160;<span class="stringliteral">You should do this consistently within a single file, so, when modifying an existing file, use the style in that file.</span></div>
<div class="line"><a name="l02826"></a><span class="lineno"> 2826</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02827"></a><span class="lineno"> 2827</span>&#160;<span class="stringliteral">### Boolean Expressions</span></div>
<div class="line"><a name="l02828"></a><span class="lineno"> 2828</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02829"></a><span class="lineno"> 2829</span>&#160;<span class="stringliteral">&gt; When you have a boolean expression that is longer than the [standard line length](#line-length) , be consistent in how you break up the lines.</span></div>
<div class="line"><a name="l02830"></a><span class="lineno"> 2830</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02831"></a><span class="lineno"> 2831</span>&#160;<span class="stringliteral">In this example, the logical AND operator is always at the end of the lines:</span></div>
<div class="line"><a name="l02832"></a><span class="lineno"> 2832</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02833"></a><span class="lineno"> 2833</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l02834"></a><span class="lineno"> 2834</span>&#160;<span class="stringliteral">if (this_one_thing &gt; this_other_thing &amp;&amp;</span></div>
<div class="line"><a name="l02835"></a><span class="lineno"> 2835</span>&#160;<span class="stringliteral">    a_third_thing == a_fourth_thing &amp;&amp;</span></div>
<div class="line"><a name="l02836"></a><span class="lineno"> 2836</span>&#160;<span class="stringliteral">    yet_another &amp;&amp; last_one) {</span></div>
<div class="line"><a name="l02837"></a><span class="lineno"> 2837</span>&#160;<span class="stringliteral">  ...</span></div>
<div class="line"><a name="l02838"></a><span class="lineno"> 2838</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02839"></a><span class="lineno"> 2839</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l02840"></a><span class="lineno"> 2840</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02841"></a><span class="lineno"> 2841</span>&#160;<span class="stringliteral">Note that when the code wraps in this example, both of the `&amp;&amp;` logical AND operators are at the end of the line. This is more common in Google code, though wrapping all operators at the beginning of the line is also allowed. Feel free to insert extra parentheses judiciously because they can be very helpful in increasing readability when used appropriately. Also note that you should always use the punctuation operators, such as `&amp;&amp;` and `~` , rather than the word operators, such as `and` and `compl`.</span></div>
<div class="line"><a name="l02842"></a><span class="lineno"> 2842</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02843"></a><span class="lineno"> 2843</span>&#160;<span class="stringliteral">### Return Values</span></div>
<div class="line"><a name="l02844"></a><span class="lineno"> 2844</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02845"></a><span class="lineno"> 2845</span>&#160;<span class="stringliteral">&gt; Do not needlessly surround the `return` expression with parentheses.</span></div>
<div class="line"><a name="l02846"></a><span class="lineno"> 2846</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02847"></a><span class="lineno"> 2847</span>&#160;<span class="stringliteral">Use parentheses in `return expr;` only where you would use them in `x = expr;`.</span></div>
<div class="line"><a name="l02848"></a><span class="lineno"> 2848</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02849"></a><span class="lineno"> 2849</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l02850"></a><span class="lineno"> 2850</span>&#160;<span class="stringliteral">return result;                  // No parentheses in the simple case.</span></div>
<div class="line"><a name="l02851"></a><span class="lineno"> 2851</span>&#160;<span class="stringliteral">// Parentheses OK to make a complex expression more readable.</span></div>
<div class="line"><a name="l02852"></a><span class="lineno"> 2852</span>&#160;<span class="stringliteral">return (some_long_condition &amp;&amp;</span></div>
<div class="line"><a name="l02853"></a><span class="lineno"> 2853</span>&#160;<span class="stringliteral">        another_condition);</span></div>
<div class="line"><a name="l02854"></a><span class="lineno"> 2854</span>&#160;<span class="stringliteral">```</span></div>
<div class="line"><a name="l02855"></a><span class="lineno"> 2855</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l02856"></a><span class="lineno"> 2856</span>&#160;<span class="stringliteral">```c++</span></div>
<div class="line"><a name="l02857"></a><span class="lineno"> 2857</span>&#160;<span class="stringliteral">return (value);                // You wouldn&#39;</span>t write var = (value);</div>
<div class="line"><a name="l02858"></a><span class="lineno"> 2858</span>&#160;<span class="keywordflow">return</span>(result);                <span class="comment">// return is not a function!</span></div>
<div class="line"><a name="l02859"></a><span class="lineno"> 2859</span>&#160;```</div>
<div class="line"><a name="l02860"></a><span class="lineno"> 2860</span>&#160;</div>
<div class="line"><a name="l02861"></a><span class="lineno"> 2861</span>&#160;<span class="preprocessor">### Variable and Array Initialization</span></div>
<div class="line"><a name="l02862"></a><span class="lineno"> 2862</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l02863"></a><span class="lineno"> 2863</span>&#160;&gt; Your choice of `=`, `()`, or `{}`.</div>
<div class="line"><a name="l02864"></a><span class="lineno"> 2864</span>&#160;</div>
<div class="line"><a name="l02865"></a><span class="lineno"> 2865</span>&#160;You may choose between `=`, `()`, or `{}`; the following are all correct:</div>
<div class="line"><a name="l02866"></a><span class="lineno"> 2866</span>&#160;</div>
<div class="line"><a name="l02867"></a><span class="lineno"> 2867</span>&#160;```c++</div>
<div class="line"><a name="l02868"></a><span class="lineno"> 2868</span>&#160;<span class="keywordtype">int</span> x = 3;</div>
<div class="line"><a name="l02869"></a><span class="lineno"> 2869</span>&#160;<span class="keywordtype">int</span> x(3);</div>
<div class="line"><a name="l02870"></a><span class="lineno"> 2870</span>&#160;<span class="keywordtype">int</span> x{3};</div>
<div class="line"><a name="l02871"></a><span class="lineno"> 2871</span>&#160;<span class="keywordtype">string</span> name = <span class="stringliteral">&quot;Some Name&quot;</span>;</div>
<div class="line"><a name="l02872"></a><span class="lineno"> 2872</span>&#160;<span class="keywordtype">string</span> name(<span class="stringliteral">&quot;Some Name&quot;</span>);</div>
<div class="line"><a name="l02873"></a><span class="lineno"> 2873</span>&#160;<span class="keywordtype">string</span> name{<span class="stringliteral">&quot;Some Name&quot;</span>};</div>
<div class="line"><a name="l02874"></a><span class="lineno"> 2874</span>&#160;```</div>
<div class="line"><a name="l02875"></a><span class="lineno"> 2875</span>&#160;</div>
<div class="line"><a name="l02876"></a><span class="lineno"> 2876</span>&#160;Be careful when <span class="keyword">using</span> a braced initialization list `{...}` on a type with an `std::initializer_list` constructor. A nonempty *braced-init-list* prefers the `std::initializer_list` constructor whenever possible. Note that empty braces `{}` are special, and will call a <span class="keywordflow">default</span> constructor <span class="keywordflow">if</span> available. To force the non-`std::initializer_list` constructor, use parentheses instead of braces.</div>
<div class="line"><a name="l02877"></a><span class="lineno"> 2877</span>&#160;</div>
<div class="line"><a name="l02878"></a><span class="lineno"> 2878</span>&#160;```c++</div>
<div class="line"><a name="l02879"></a><span class="lineno"> 2879</span>&#160;std::vector&lt;int&gt; v(100, 1);  <span class="comment">// A vector of 100 1s.</span></div>
<div class="line"><a name="l02880"></a><span class="lineno"> 2880</span>&#160;std::vector&lt;int&gt; v{100, 1};  <span class="comment">// A vector of 100, 1.</span></div>
<div class="line"><a name="l02881"></a><span class="lineno"> 2881</span>&#160;```</div>
<div class="line"><a name="l02882"></a><span class="lineno"> 2882</span>&#160;</div>
<div class="line"><a name="l02883"></a><span class="lineno"> 2883</span>&#160;Also, the brace form prevents narrowing of integral types. This can prevent some types of programming errors.</div>
<div class="line"><a name="l02884"></a><span class="lineno"> 2884</span>&#160;</div>
<div class="line"><a name="l02885"></a><span class="lineno"> 2885</span>&#160;```c++</div>
<div class="line"><a name="l02886"></a><span class="lineno"> 2886</span>&#160;<span class="keywordtype">int</span> pi(3.14);  <span class="comment">// OK -- pi == 3.</span></div>
<div class="line"><a name="l02887"></a><span class="lineno"> 2887</span>&#160;<span class="keywordtype">int</span> pi{3.14};  <span class="comment">// Compile error: narrowing conversion.</span></div>
<div class="line"><a name="l02888"></a><span class="lineno"> 2888</span>&#160;```</div>
<div class="line"><a name="l02889"></a><span class="lineno"> 2889</span>&#160;</div>
<div class="line"><a name="l02890"></a><span class="lineno"> 2890</span>&#160;<span class="preprocessor">### Preprocessor Directives</span></div>
<div class="line"><a name="l02891"></a><span class="lineno"> 2891</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l02892"></a><span class="lineno"> 2892</span>&#160;&gt; The hash mark that starts a preprocessor directive should always be at the beginning of the line.</div>
<div class="line"><a name="l02893"></a><span class="lineno"> 2893</span>&#160;</div>
<div class="line"><a name="l02894"></a><span class="lineno"> 2894</span>&#160;Even when preprocessor directives are within the body of indented code, the directives should start at the beginning of the line.</div>
<div class="line"><a name="l02895"></a><span class="lineno"> 2895</span>&#160;</div>
<div class="line"><a name="l02896"></a><span class="lineno"> 2896</span>&#160;```c++</div>
<div class="line"><a name="l02897"></a><span class="lineno"> 2897</span>&#160;<span class="comment">// Good - directives at beginning of line</span></div>
<div class="line"><a name="l02898"></a><span class="lineno"> 2898</span>&#160;  <span class="keywordflow">if</span> (lopsided_score) {</div>
<div class="line"><a name="l02899"></a><span class="lineno"> 2899</span>&#160;<span class="preprocessor">#if DISASTER_PENDING      // Correct -- Starts at beginning of line</span></div>
<div class="line"><a name="l02900"></a><span class="lineno"> 2900</span>&#160;<span class="preprocessor"></span>    DropEverything();</div>
<div class="line"><a name="l02901"></a><span class="lineno"> 2901</span>&#160;<span class="preprocessor"># if NOTIFY               // OK but not required -- Spaces after #</span></div>
<div class="line"><a name="l02902"></a><span class="lineno"> 2902</span>&#160;<span class="preprocessor"></span>    NotifyClient();</div>
<div class="line"><a name="l02903"></a><span class="lineno"> 2903</span>&#160;<span class="preprocessor"># endif</span></div>
<div class="line"><a name="l02904"></a><span class="lineno"> 2904</span>&#160;<span class="preprocessor"></span><span class="preprocessor">#endif</span></div>
<div class="line"><a name="l02905"></a><span class="lineno"> 2905</span>&#160;<span class="preprocessor"></span>    BackToNormal();</div>
<div class="line"><a name="l02906"></a><span class="lineno"> 2906</span>&#160;  }</div>
<div class="line"><a name="l02907"></a><span class="lineno"> 2907</span>&#160;```</div>
<div class="line"><a name="l02908"></a><span class="lineno"> 2908</span>&#160;</div>
<div class="line"><a name="l02909"></a><span class="lineno"> 2909</span>&#160;```c++</div>
<div class="line"><a name="l02910"></a><span class="lineno"> 2910</span>&#160;<span class="comment">// Bad - indented directives</span></div>
<div class="line"><a name="l02911"></a><span class="lineno"> 2911</span>&#160;  <span class="keywordflow">if</span> (lopsided_score) {</div>
<div class="line"><a name="l02912"></a><span class="lineno"> 2912</span>&#160;<span class="preprocessor">    #if DISASTER_PENDING  // Wrong!  The &quot;#if&quot; should be at beginning of line</span></div>
<div class="line"><a name="l02913"></a><span class="lineno"> 2913</span>&#160;<span class="preprocessor"></span>    DropEverything();</div>
<div class="line"><a name="l02914"></a><span class="lineno"> 2914</span>&#160;<span class="preprocessor">    #endif                // Wrong!  Do not indent &quot;#endif&quot;</span></div>
<div class="line"><a name="l02915"></a><span class="lineno"> 2915</span>&#160;<span class="preprocessor"></span>    BackToNormal();</div>
<div class="line"><a name="l02916"></a><span class="lineno"> 2916</span>&#160;  }</div>
<div class="line"><a name="l02917"></a><span class="lineno"> 2917</span>&#160;```</div>
<div class="line"><a name="l02918"></a><span class="lineno"> 2918</span>&#160;</div>
<div class="line"><a name="l02919"></a><span class="lineno"> 2919</span>&#160;<span class="preprocessor">### Class Format</span></div>
<div class="line"><a name="l02920"></a><span class="lineno"> 2920</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l02921"></a><span class="lineno"> 2921</span>&#160;&gt; Sections in `<span class="keyword">public</span>`, `<span class="keyword">protected</span>` and `<span class="keyword">private</span>` order, each indented one space.</div>
<div class="line"><a name="l02922"></a><span class="lineno"> 2922</span>&#160;</div>
<div class="line"><a name="l02923"></a><span class="lineno"> 2923</span>&#160;The basic format <span class="keywordflow">for</span> a <span class="keyword">class </span>definition (lacking the comments, see [class comments](#class-comments) for a discussion of what comments are needed) is:</div>
<div class="line"><a name="l02924"></a><span class="lineno"> 2924</span>&#160;</div>
<div class="line"><a name="l02925"></a><span class="lineno"> 2925</span>&#160;```c++</div>
<div class="line"><a name="l02926"></a><span class="lineno"> 2926</span>&#160;class MyClass : <span class="keyword">public</span> OtherClass {</div>
<div class="line"><a name="l02927"></a><span class="lineno"> 2927</span>&#160; <span class="keyword">public</span>:      <span class="comment">// Note the 1 space indent!</span></div>
<div class="line"><a name="l02928"></a><span class="lineno"> 2928</span>&#160;  MyClass();  <span class="comment">// Regular 2 space indent.</span></div>
<div class="line"><a name="l02929"></a><span class="lineno"> 2929</span>&#160;  <span class="keyword">explicit</span> MyClass(<span class="keywordtype">int</span> var);</div>
<div class="line"><a name="l02930"></a><span class="lineno"> 2930</span>&#160;  ~MyClass() {}</div>
<div class="line"><a name="l02931"></a><span class="lineno"> 2931</span>&#160;</div>
<div class="line"><a name="l02932"></a><span class="lineno"> 2932</span>&#160;  <span class="keywordtype">void</span> SomeFunction();</div>
<div class="line"><a name="l02933"></a><span class="lineno"> 2933</span>&#160;  <span class="keywordtype">void</span> SomeFunctionThatDoesNothing() {</div>
<div class="line"><a name="l02934"></a><span class="lineno"> 2934</span>&#160;  }</div>
<div class="line"><a name="l02935"></a><span class="lineno"> 2935</span>&#160;</div>
<div class="line"><a name="l02936"></a><span class="lineno"> 2936</span>&#160;  <span class="keywordtype">void</span> set_some_var(<span class="keywordtype">int</span> var) { some_var_ = var; }</div>
<div class="line"><a name="l02937"></a><span class="lineno"> 2937</span>&#160;  <span class="keywordtype">int</span> some_var()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> some_var_; }</div>
<div class="line"><a name="l02938"></a><span class="lineno"> 2938</span>&#160;</div>
<div class="line"><a name="l02939"></a><span class="lineno"> 2939</span>&#160; <span class="keyword">private</span>:</div>
<div class="line"><a name="l02940"></a><span class="lineno"> 2940</span>&#160;  <span class="keywordtype">bool</span> SomeInternalFunction();</div>
<div class="line"><a name="l02941"></a><span class="lineno"> 2941</span>&#160;</div>
<div class="line"><a name="l02942"></a><span class="lineno"> 2942</span>&#160;  <span class="keywordtype">int</span> some_var_;</div>
<div class="line"><a name="l02943"></a><span class="lineno"> 2943</span>&#160;  <span class="keywordtype">int</span> some_other_var_;</div>
<div class="line"><a name="l02944"></a><span class="lineno"> 2944</span>&#160;};</div>
<div class="line"><a name="l02945"></a><span class="lineno"> 2945</span>&#160;```</div>
<div class="line"><a name="l02946"></a><span class="lineno"> 2946</span>&#160;</div>
<div class="line"><a name="l02947"></a><span class="lineno"> 2947</span>&#160;Things to note:</div>
<div class="line"><a name="l02948"></a><span class="lineno"> 2948</span>&#160;</div>
<div class="line"><a name="l02949"></a><span class="lineno"> 2949</span>&#160;* Any base <span class="keyword">class </span>name should be on the same line as the subclass name, subject to the 80-column limit.</div>
<div class="line"><a name="l02950"></a><span class="lineno"> 2950</span>&#160;* The `<span class="keyword">public</span>:`, `<span class="keyword">protected</span>:`, and `<span class="keyword">private</span>:` keywords should be indented one space.</div>
<div class="line"><a name="l02951"></a><span class="lineno"> 2951</span>&#160;* Except <span class="keywordflow">for</span> the first instance, these keywords should be preceded by a blank line. This rule is optional in small classes.</div>
<div class="line"><a name="l02952"></a><span class="lineno"> 2952</span>&#160;* Do not leave a blank line after these keywords.</div>
<div class="line"><a name="l02953"></a><span class="lineno"> 2953</span>&#160;* The `<span class="keyword">public</span>` section should be first, followed by the `<span class="keyword">protected</span>` and <span class="keywordflow">finally</span> the `<span class="keyword">private</span>` section.</div>
<div class="line"><a name="l02954"></a><span class="lineno"> 2954</span>&#160;* See [declaration order](#declaration-order) <span class="keywordflow">for</span> rules on ordering declarations within each of these sections.</div>
<div class="line"><a name="l02955"></a><span class="lineno"> 2955</span>&#160;</div>
<div class="line"><a name="l02956"></a><span class="lineno"> 2956</span>&#160;### Constructor Initializer Lists</div>
<div class="line"><a name="l02957"></a><span class="lineno"> 2957</span>&#160;</div>
<div class="line"><a name="l02958"></a><span class="lineno"> 2958</span>&#160;&gt; Constructor initializer lists can be all on one line or with subsequent lines indented four spaces.</div>
<div class="line"><a name="l02959"></a><span class="lineno"> 2959</span>&#160;</div>
<div class="line"><a name="l02960"></a><span class="lineno"> 2960</span>&#160;The acceptable formats <span class="keywordflow">for</span> initializer lists are:</div>
<div class="line"><a name="l02961"></a><span class="lineno"> 2961</span>&#160;</div>
<div class="line"><a name="l02962"></a><span class="lineno"> 2962</span>&#160;```c++</div>
<div class="line"><a name="l02963"></a><span class="lineno"> 2963</span>&#160;<span class="comment">// When everything fits on one line:</span></div>
<div class="line"><a name="l02964"></a><span class="lineno"> 2964</span>&#160;MyClass::MyClass(<span class="keywordtype">int</span> var) : some_var_(var) {</div>
<div class="line"><a name="l02965"></a><span class="lineno"> 2965</span>&#160;  DoSomething();</div>
<div class="line"><a name="l02966"></a><span class="lineno"> 2966</span>&#160;}</div>
<div class="line"><a name="l02967"></a><span class="lineno"> 2967</span>&#160;</div>
<div class="line"><a name="l02968"></a><span class="lineno"> 2968</span>&#160;<span class="comment">// If the signature and initializer list are not all on one line,</span></div>
<div class="line"><a name="l02969"></a><span class="lineno"> 2969</span>&#160;<span class="comment">// you must wrap before the colon and indent 4 spaces:</span></div>
<div class="line"><a name="l02970"></a><span class="lineno"> 2970</span>&#160;MyClass::MyClass(<span class="keywordtype">int</span> var)</div>
<div class="line"><a name="l02971"></a><span class="lineno"> 2971</span>&#160;    : some_var_(var), some_other_var_(var + 1) {</div>
<div class="line"><a name="l02972"></a><span class="lineno"> 2972</span>&#160;  DoSomething();</div>
<div class="line"><a name="l02973"></a><span class="lineno"> 2973</span>&#160;}</div>
<div class="line"><a name="l02974"></a><span class="lineno"> 2974</span>&#160;</div>
<div class="line"><a name="l02975"></a><span class="lineno"> 2975</span>&#160;<span class="comment">// When the list spans multiple lines, put each member on its own line</span></div>
<div class="line"><a name="l02976"></a><span class="lineno"> 2976</span>&#160;<span class="comment">// and align them:</span></div>
<div class="line"><a name="l02977"></a><span class="lineno"> 2977</span>&#160;MyClass::MyClass(<span class="keywordtype">int</span> var)</div>
<div class="line"><a name="l02978"></a><span class="lineno"> 2978</span>&#160;    : some_var_(var),             <span class="comment">// 4 space indent</span></div>
<div class="line"><a name="l02979"></a><span class="lineno"> 2979</span>&#160;      some_other_var_(var + 1) {  <span class="comment">// lined up</span></div>
<div class="line"><a name="l02980"></a><span class="lineno"> 2980</span>&#160;  DoSomething();</div>
<div class="line"><a name="l02981"></a><span class="lineno"> 2981</span>&#160;}</div>
<div class="line"><a name="l02982"></a><span class="lineno"> 2982</span>&#160;</div>
<div class="line"><a name="l02983"></a><span class="lineno"> 2983</span>&#160;<span class="comment">// As with any other code block, the close curly can be on the same</span></div>
<div class="line"><a name="l02984"></a><span class="lineno"> 2984</span>&#160;<span class="comment">// line as the open curly, if it fits.</span></div>
<div class="line"><a name="l02985"></a><span class="lineno"> 2985</span>&#160;MyClass::MyClass(<span class="keywordtype">int</span> var)</div>
<div class="line"><a name="l02986"></a><span class="lineno"> 2986</span>&#160;    : some_var_(var) {}</div>
<div class="line"><a name="l02987"></a><span class="lineno"> 2987</span>&#160;```</div>
<div class="line"><a name="l02988"></a><span class="lineno"> 2988</span>&#160;</div>
<div class="line"><a name="l02989"></a><span class="lineno"> 2989</span>&#160;<span class="preprocessor">### Namespace Formatting</span></div>
<div class="line"><a name="l02990"></a><span class="lineno"> 2990</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l02991"></a><span class="lineno"> 2991</span>&#160;&gt; The contents of namespaces are not indented.</div>
<div class="line"><a name="l02992"></a><span class="lineno"> 2992</span>&#160;</div>
<div class="line"><a name="l02993"></a><span class="lineno"> 2993</span>&#160;[Namespaces](#namespaces) <span class="keywordflow">do</span> not add an extra level of indentation. For example, use:</div>
<div class="line"><a name="l02994"></a><span class="lineno"> 2994</span>&#160;</div>
<div class="line"><a name="l02995"></a><span class="lineno"> 2995</span>&#160;```c++</div>
<div class="line"><a name="l02996"></a><span class="lineno"> 2996</span>&#160;<span class="keyword">namespace</span> {</div>
<div class="line"><a name="l02997"></a><span class="lineno"> 2997</span>&#160;</div>
<div class="line"><a name="l02998"></a><span class="lineno"> 2998</span>&#160;<span class="keywordtype">void</span> foo() {  <span class="comment">// Correct.  No extra indentation within namespace.</span></div>
<div class="line"><a name="l02999"></a><span class="lineno"> 2999</span>&#160;  ...</div>
<div class="line"><a name="l03000"></a><span class="lineno"> 3000</span>&#160;}</div>
<div class="line"><a name="l03001"></a><span class="lineno"> 3001</span>&#160;</div>
<div class="line"><a name="l03002"></a><span class="lineno"> 3002</span>&#160;}  <span class="comment">// namespace</span></div>
<div class="line"><a name="l03003"></a><span class="lineno"> 3003</span>&#160;```</div>
<div class="line"><a name="l03004"></a><span class="lineno"> 3004</span>&#160;</div>
<div class="line"><a name="l03005"></a><span class="lineno"> 3005</span>&#160;Do not indent within a <span class="keyword">namespace</span>:</div>
<div class="line"><a name="l03006"></a><span class="lineno"> 3006</span>&#160;</div>
<div class="line"><a name="l03007"></a><span class="lineno"> 3007</span>&#160;```c++</div>
<div class="line"><a name="l03008"></a><span class="lineno"> 3008</span>&#160;<span class="keyword">namespace </span>{</div>
<div class="line"><a name="l03009"></a><span class="lineno"> 3009</span>&#160;</div>
<div class="line"><a name="l03010"></a><span class="lineno"> 3010</span>&#160;  <span class="comment">// Wrong.  Indented when it should not be.</span></div>
<div class="line"><a name="l03011"></a><span class="lineno"> 3011</span>&#160;  <span class="keywordtype">void</span> foo() {</div>
<div class="line"><a name="l03012"></a><span class="lineno"> 3012</span>&#160;    ...</div>
<div class="line"><a name="l03013"></a><span class="lineno"> 3013</span>&#160;  }</div>
<div class="line"><a name="l03014"></a><span class="lineno"> 3014</span>&#160;</div>
<div class="line"><a name="l03015"></a><span class="lineno"> 3015</span>&#160;}  <span class="comment">// namespace</span></div>
<div class="line"><a name="l03016"></a><span class="lineno"> 3016</span>&#160;```</div>
<div class="line"><a name="l03017"></a><span class="lineno"> 3017</span>&#160;</div>
<div class="line"><a name="l03018"></a><span class="lineno"> 3018</span>&#160;When declaring nested namespaces, put each <span class="keyword">namespace </span>on its own line.</div>
<div class="line"><a name="l03019"></a><span class="lineno"> 3019</span>&#160;</div>
<div class="line"><a name="l03020"></a><span class="lineno"> 3020</span>&#160;```c++</div>
<div class="line"><a name="l03021"></a><span class="lineno"> 3021</span>&#160;namespace foo {</div>
<div class="line"><a name="l03022"></a><span class="lineno"> 3022</span>&#160;<span class="keyword">namespace </span>bar {</div>
<div class="line"><a name="l03023"></a><span class="lineno"> 3023</span>&#160;```</div>
<div class="line"><a name="l03024"></a><span class="lineno"> 3024</span>&#160;</div>
<div class="line"><a name="l03025"></a><span class="lineno"> 3025</span>&#160;<span class="preprocessor">### Horizontal Whitespace</span></div>
<div class="line"><a name="l03026"></a><span class="lineno"> 3026</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l03027"></a><span class="lineno"> 3027</span>&#160;&gt; Use of horizontal whitespace depends on location. Never put trailing whitespace at the end of a line.</div>
<div class="line"><a name="l03028"></a><span class="lineno"> 3028</span>&#160;</div>
<div class="line"><a name="l03029"></a><span class="lineno"> 3029</span>&#160;#### General</div>
<div class="line"><a name="l03030"></a><span class="lineno"> 3030</span>&#160;</div>
<div class="line"><a name="l03031"></a><span class="lineno"> 3031</span>&#160;```c++</div>
<div class="line"><a name="l03032"></a><span class="lineno"> 3032</span>&#160;<span class="keywordtype">void</span> f(<span class="keywordtype">bool</span> b) {  <span class="comment">// Open braces should always have a space before them.</span></div>
<div class="line"><a name="l03033"></a><span class="lineno"> 3033</span>&#160;  ...</div>
<div class="line"><a name="l03034"></a><span class="lineno"> 3034</span>&#160;int i = 0;  <span class="comment">// Semicolons usually have no space before them.</span></div>
<div class="line"><a name="l03035"></a><span class="lineno"> 3035</span>&#160;<span class="comment">// Spaces inside braces for braced-init-list are optional.  If you use them,</span></div>
<div class="line"><a name="l03036"></a><span class="lineno"> 3036</span>&#160;<span class="comment">// put them on both sides!</span></div>
<div class="line"><a name="l03037"></a><span class="lineno"> 3037</span>&#160;<span class="keywordtype">int</span> x[] = { 0 };</div>
<div class="line"><a name="l03038"></a><span class="lineno"> 3038</span>&#160;<span class="keywordtype">int</span> x[] = {0};</div>
<div class="line"><a name="l03039"></a><span class="lineno"> 3039</span>&#160;</div>
<div class="line"><a name="l03040"></a><span class="lineno"> 3040</span>&#160;<span class="comment">// Spaces around the colon in inheritance and initializer lists.</span></div>
<div class="line"><a name="l03041"></a><span class="lineno"> 3041</span>&#160;<span class="keyword">class </span>Foo : <span class="keyword">public</span> Bar {</div>
<div class="line"><a name="l03042"></a><span class="lineno"> 3042</span>&#160; <span class="keyword">public</span>:</div>
<div class="line"><a name="l03043"></a><span class="lineno"> 3043</span>&#160;  <span class="comment">// For inline function implementations, put spaces between the braces</span></div>
<div class="line"><a name="l03044"></a><span class="lineno"> 3044</span>&#160;  <span class="comment">// and the implementation itself.</span></div>
<div class="line"><a name="l03045"></a><span class="lineno"> 3045</span>&#160;  Foo(<span class="keywordtype">int</span> b) : Bar(), baz_(b) {}  <span class="comment">// No spaces inside empty braces.</span></div>
<div class="line"><a name="l03046"></a><span class="lineno"> 3046</span>&#160;  <span class="keywordtype">void</span> Reset() { baz_ = 0; }  <span class="comment">// Spaces separating braces from implementation.</span></div>
<div class="line"><a name="l03047"></a><span class="lineno"> 3047</span>&#160;  ...</div>
<div class="line"><a name="l03048"></a><span class="lineno"> 3048</span>&#160;```</div>
<div class="line"><a name="l03049"></a><span class="lineno"> 3049</span>&#160;</div>
<div class="line"><a name="l03050"></a><span class="lineno"> 3050</span>&#160;Adding trailing whitespace can cause extra work <span class="keywordflow">for</span> others editing the same file, when they merge, as can removing existing trailing whitespace. So: Don<span class="stringliteral">&#39;t introduce trailing whitespace. Remove it if you&#39;</span>re already changing that line, or <span class="keywordflow">do</span> it in a separate clean-up operation (preferably when no-one <span class="keywordflow">else</span> is working on the file).</div>
<div class="line"><a name="l03051"></a><span class="lineno"> 3051</span>&#160;</div>
<div class="line"><a name="l03052"></a><span class="lineno"> 3052</span>&#160;#### Loops and Conditionals</div>
<div class="line"><a name="l03053"></a><span class="lineno"> 3053</span>&#160;</div>
<div class="line"><a name="l03054"></a><span class="lineno"> 3054</span>&#160;```c++</div>
<div class="line"><a name="l03055"></a><span class="lineno"> 3055</span>&#160;<span class="keywordflow">if</span> (b) {          <span class="comment">// Space after the keyword in conditions and loops.</span></div>
<div class="line"><a name="l03056"></a><span class="lineno"> 3056</span>&#160;} <span class="keywordflow">else</span> {          <span class="comment">// Spaces around else.</span></div>
<div class="line"><a name="l03057"></a><span class="lineno"> 3057</span>&#160;}</div>
<div class="line"><a name="l03058"></a><span class="lineno"> 3058</span>&#160;<span class="keywordflow">while</span> (test) {}   <span class="comment">// There is usually no space inside parentheses.</span></div>
<div class="line"><a name="l03059"></a><span class="lineno"> 3059</span>&#160;<span class="keywordflow">switch</span> (i) {</div>
<div class="line"><a name="l03060"></a><span class="lineno"> 3060</span>&#160;<span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 5; ++i) {</div>
<div class="line"><a name="l03061"></a><span class="lineno"> 3061</span>&#160;<span class="comment">// Loops and conditions may have spaces inside parentheses, but this</span></div>
<div class="line"><a name="l03062"></a><span class="lineno"> 3062</span>&#160;<span class="comment">// is rare.  Be consistent.</span></div>
<div class="line"><a name="l03063"></a><span class="lineno"> 3063</span>&#160;<span class="keywordflow">switch</span> ( i ) {</div>
<div class="line"><a name="l03064"></a><span class="lineno"> 3064</span>&#160;<span class="keywordflow">if</span> ( test ) {</div>
<div class="line"><a name="l03065"></a><span class="lineno"> 3065</span>&#160;<span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; 5; ++i ) {</div>
<div class="line"><a name="l03066"></a><span class="lineno"> 3066</span>&#160;<span class="comment">// For loops always have a space after the semicolon.  They may have a space</span></div>
<div class="line"><a name="l03067"></a><span class="lineno"> 3067</span>&#160;<span class="comment">// before the semicolon, but this is rare.</span></div>
<div class="line"><a name="l03068"></a><span class="lineno"> 3068</span>&#160;<span class="keywordflow">for</span> ( ; i &lt; 5 ; ++i) {</div>
<div class="line"><a name="l03069"></a><span class="lineno"> 3069</span>&#160;  ...</div>
<div class="line"><a name="l03070"></a><span class="lineno"> 3070</span>&#160;</div>
<div class="line"><a name="l03071"></a><span class="lineno"> 3071</span>&#160;<span class="comment">// Range-based for loops always have a space before and after the colon.</span></div>
<div class="line"><a name="l03072"></a><span class="lineno"> 3072</span>&#160;for (<span class="keyword">auto</span> x : counts) {</div>
<div class="line"><a name="l03073"></a><span class="lineno"> 3073</span>&#160;  ...</div>
<div class="line"><a name="l03074"></a><span class="lineno"> 3074</span>&#160;}</div>
<div class="line"><a name="l03075"></a><span class="lineno"> 3075</span>&#160;<span class="keywordflow">switch</span> (i) {</div>
<div class="line"><a name="l03076"></a><span class="lineno"> 3076</span>&#160;  <span class="keywordflow">case</span> 1:         <span class="comment">// No space before colon in a switch case.</span></div>
<div class="line"><a name="l03077"></a><span class="lineno"> 3077</span>&#160;    ...</div>
<div class="line"><a name="l03078"></a><span class="lineno"> 3078</span>&#160;  <span class="keywordflow">case</span> 2: <span class="keywordflow">break</span>;  <span class="comment">// Use a space after a colon if there&#39;s code after it.</span></div>
<div class="line"><a name="l03079"></a><span class="lineno"> 3079</span>&#160;```</div>
<div class="line"><a name="l03080"></a><span class="lineno"> 3080</span>&#160;</div>
<div class="line"><a name="l03081"></a><span class="lineno"> 3081</span>&#160;<span class="preprocessor">#### Operators</span></div>
<div class="line"><a name="l03082"></a><span class="lineno"> 3082</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l03083"></a><span class="lineno"> 3083</span>&#160;```c++</div>
<div class="line"><a name="l03084"></a><span class="lineno"> 3084</span>&#160;<span class="comment">// Assignment operators always have spaces around them.</span></div>
<div class="line"><a name="l03085"></a><span class="lineno"> 3085</span>&#160;x = 0;</div>
<div class="line"><a name="l03086"></a><span class="lineno"> 3086</span>&#160;</div>
<div class="line"><a name="l03087"></a><span class="lineno"> 3087</span>&#160;<span class="comment">// Other binary operators usually have spaces around them, but it&#39;s</span></div>
<div class="line"><a name="l03088"></a><span class="lineno"> 3088</span>&#160;<span class="comment">// OK to remove spaces around factors.  Parentheses should have no</span></div>
<div class="line"><a name="l03089"></a><span class="lineno"> 3089</span>&#160;<span class="comment">// internal padding.</span></div>
<div class="line"><a name="l03090"></a><span class="lineno"> 3090</span>&#160;v = w * x + y / z;</div>
<div class="line"><a name="l03091"></a><span class="lineno"> 3091</span>&#160;v = w*x + y/z;</div>
<div class="line"><a name="l03092"></a><span class="lineno"> 3092</span>&#160;v = w * (x + z);</div>
<div class="line"><a name="l03093"></a><span class="lineno"> 3093</span>&#160;</div>
<div class="line"><a name="l03094"></a><span class="lineno"> 3094</span>&#160;<span class="comment">// No spaces separating unary operators and their arguments.</span></div>
<div class="line"><a name="l03095"></a><span class="lineno"> 3095</span>&#160;x = -5;</div>
<div class="line"><a name="l03096"></a><span class="lineno"> 3096</span>&#160;++x;</div>
<div class="line"><a name="l03097"></a><span class="lineno"> 3097</span>&#160;<span class="keywordflow">if</span> (x &amp;&amp; !y)</div>
<div class="line"><a name="l03098"></a><span class="lineno"> 3098</span>&#160;  ...</div>
<div class="line"><a name="l03099"></a><span class="lineno"> 3099</span>&#160;```</div>
<div class="line"><a name="l03100"></a><span class="lineno"> 3100</span>&#160;</div>
<div class="line"><a name="l03101"></a><span class="lineno"> 3101</span>&#160;<span class="preprocessor">#### Templates and Casts</span></div>
<div class="line"><a name="l03102"></a><span class="lineno"> 3102</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l03103"></a><span class="lineno"> 3103</span>&#160;```c++</div>
<div class="line"><a name="l03104"></a><span class="lineno"> 3104</span>&#160;<span class="comment">// No spaces inside the angle brackets (&lt; and &gt;), before</span></div>
<div class="line"><a name="l03105"></a><span class="lineno"> 3105</span>&#160;<span class="comment">// &lt;, or between &gt;( in a cast</span></div>
<div class="line"><a name="l03106"></a><span class="lineno"> 3106</span>&#160;std::vector&lt;string&gt; x;</div>
<div class="line"><a name="l03107"></a><span class="lineno"> 3107</span>&#160;y = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(x);</div>
<div class="line"><a name="l03108"></a><span class="lineno"> 3108</span>&#160;</div>
<div class="line"><a name="l03109"></a><span class="lineno"> 3109</span>&#160;<span class="comment">// Spaces between type and pointer are OK, but be consistent.</span></div>
<div class="line"><a name="l03110"></a><span class="lineno"> 3110</span>&#160;std::vector&lt;char *&gt; x;</div>
<div class="line"><a name="l03111"></a><span class="lineno"> 3111</span>&#160;```</div>
<div class="line"><a name="l03112"></a><span class="lineno"> 3112</span>&#160;</div>
<div class="line"><a name="l03113"></a><span class="lineno"> 3113</span>&#160;<span class="preprocessor">### Vertical Whitespace</span></div>
<div class="line"><a name="l03114"></a><span class="lineno"> 3114</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l03115"></a><span class="lineno"> 3115</span>&#160;&gt; Minimize use of vertical whitespace.</div>
<div class="line"><a name="l03116"></a><span class="lineno"> 3116</span>&#160;</div>
<div class="line"><a name="l03117"></a><span class="lineno"> 3117</span>&#160;This is more a principle than a rule: don<span class="stringliteral">&#39;t use blank lines when you don&#39;</span>t have to. In particular, don<span class="stringliteral">&#39;t put more than one or two blank lines between functions, resist starting functions with a blank line, don&#39;</span>t end functions with a blank line, and be discriminating with your use of blank lines inside functions.</div>
<div class="line"><a name="l03118"></a><span class="lineno"> 3118</span>&#160;</div>
<div class="line"><a name="l03119"></a><span class="lineno"> 3119</span>&#160;The basic principle is: The more code that fits on one screen, the easier it is to follow and understand the control flow of the program. Of course, readability can suffer from code being too dense as well as too spread out, so use your judgement. But in general, minimize use of vertical whitespace.</div>
<div class="line"><a name="l03120"></a><span class="lineno"> 3120</span>&#160;</div>
<div class="line"><a name="l03121"></a><span class="lineno"> 3121</span>&#160;Some rules of thumb to help when blank lines may be useful:</div>
<div class="line"><a name="l03122"></a><span class="lineno"> 3122</span>&#160;</div>
<div class="line"><a name="l03123"></a><span class="lineno"> 3123</span>&#160;* Blank lines at the beginning or end of a <span class="keyword">function</span> very rarely help readability.</div>
<div class="line"><a name="l03124"></a><span class="lineno"> 3124</span>&#160;* Blank lines inside a chain of <span class="keywordflow">if</span>-<span class="keywordflow">else</span> blocks may well help readability.</div>
<div class="line"><a name="l03125"></a><span class="lineno"> 3125</span>&#160;</div>
<div class="line"><a name="l03126"></a><span class="lineno"> 3126</span>&#160;## Exceptions to the Rules</div>
<div class="line"><a name="l03127"></a><span class="lineno"> 3127</span>&#160;</div>
<div class="line"><a name="l03128"></a><span class="lineno"> 3128</span>&#160;The coding conventions described above are mandatory. However, like all good rules, these sometimes have exceptions, which we discuss here.</div>
<div class="line"><a name="l03129"></a><span class="lineno"> 3129</span>&#160;</div>
<div class="line"><a name="l03130"></a><span class="lineno"> 3130</span>&#160;### Existing Non-conformant Code</div>
<div class="line"><a name="l03131"></a><span class="lineno"> 3131</span>&#160;</div>
<div class="line"><a name="l03132"></a><span class="lineno"> 3132</span>&#160;&gt; You may diverge from the rules when dealing with code that does not conform to <span class="keyword">this</span> style guide.</div>
<div class="line"><a name="l03133"></a><span class="lineno"> 3133</span>&#160;</div>
<div class="line"><a name="l03134"></a><span class="lineno"> 3134</span>&#160;If you find yourself modifying code that was written to specifications other than those presented by <span class="keyword">this</span> guide, you may have to diverge from these rules in order to stay consistent with the local conventions in that code. If you are in doubt about how to <span class="keywordflow">do</span> <span class="keyword">this</span>, ask the original author or the person currently responsible <span class="keywordflow">for</span> the code. Remember that *consistency* includes local consistency, too.</div>
<div class="line"><a name="l03135"></a><span class="lineno"> 3135</span>&#160;</div>
<div class="line"><a name="l03136"></a><span class="lineno"> 3136</span>&#160;## Parting Words</div>
<div class="line"><a name="l03137"></a><span class="lineno"> 3137</span>&#160;</div>
<div class="line"><a name="l03138"></a><span class="lineno"> 3138</span>&#160;Use common sense and *BE CONSISTENT*.</div>
<div class="line"><a name="l03139"></a><span class="lineno"> 3139</span>&#160;</div>
<div class="line"><a name="l03140"></a><span class="lineno"> 3140</span>&#160;If you are editing code, take a few minutes to look at the code around you and determine its style. If they use spaces around their `<span class="keywordflow">if</span>` clauses, you should, too. If their comments have little boxes of stars around them, make your comments have little boxes of stars around them too.</div>
<div class="line"><a name="l03141"></a><span class="lineno"> 3141</span>&#160;</div>
<div class="line"><a name="l03142"></a><span class="lineno"> 3142</span>&#160;The point of having style guidelines is to have a common vocabulary of coding so people can concentrate on what you are saying, rather than on how you are saying it. We present global style rules here so people know the vocabulary. But local style is also important. If code you add to a file looks drastically different from the existing code around it, the discontinuity <span class="keywordflow">throws</span> readers out of their rhythm when they go to read it. Try to avoid this.</div>
<div class="line"><a name="l03143"></a><span class="lineno"> 3143</span>&#160;</div>
<div class="line"><a name="l03144"></a><span class="lineno"> 3144</span>&#160;OK, enough writing about writing code; the code itself is much more interesting. Have fun!</div>
<div class="line"><a name="l03145"></a><span class="lineno"> 3145</span>&#160;</div>
<div class="line"><a name="l03146"></a><span class="lineno"> 3146</span>&#160;&lt;!--</div>
<div class="line"><a name="l03147"></a><span class="lineno"> 3147</span>&#160;</div>
<div class="line"><a name="l03148"></a><span class="lineno"> 3148</span>&#160;<span class="preprocessor"># Content to integrate into the guide above</span></div>
<div class="line"><a name="l03149"></a><span class="lineno"> 3149</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l03150"></a><span class="lineno"> 3150</span>&#160;&lt;pre&gt;</div>
<div class="line"><a name="l03151"></a><span class="lineno"> 3151</span>&#160;</div>
<div class="line"><a name="l03152"></a><span class="lineno"> 3152</span>&#160;From @algernon:</div>
<div class="line"><a name="l03153"></a><span class="lineno"> 3153</span>&#160;</div>
<div class="line"><a name="l03154"></a><span class="lineno"> 3154</span>&#160;<span class="preprocessor"># [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html)</span></div>
<div class="line"><a name="l03155"></a><span class="lineno"> 3155</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l03156"></a><span class="lineno"> 3156</span>&#160;One of the selling points of <span class="keyword">this</span> guide is that we use the formatting anyway, and it is a thorough guide, covering pretty much all aspects of the code. However, it has a number of issues too, which prevents us from <span class="keyword">using</span> it as-is.</div>
<div class="line"><a name="l03157"></a><span class="lineno"> 3157</span>&#160;</div>
<div class="line"><a name="l03158"></a><span class="lineno"> 3158</span>&#160;First of all, it is written with traditional x86-64 libraries and applications in mind, where you control the build system, and so on. This can be easily seen when it talks about [names and order of includes](https:<span class="comment">//google.github.io/styleguide/cppguide.html#Names_and_Order_of_Includes). We can&#39;t name our things like that, because of limitation of the Arduino build system: we can&#39;t use `#include &lt;Kaleidoscope/LED/Theme/Something.h&gt;`, or `#include &lt;Kaleidoscope/OneShot.h&gt;`, because Arduino won&#39;t find the libraries then. We may be able to build a tool on top of it that would, but then we&#39;d lose the ability to use the Arduino IDE.</span></div>
<div class="line"><a name="l03159"></a><span class="lineno"> 3159</span>&#160;</div>
<div class="line"><a name="l03160"></a><span class="lineno"> 3160</span>&#160;The guide discourages <span class="keyword">static</span> members too (though allows them), along with globals - <span class="keywordflow">while</span> we build heavily on those to conserve space, to be friendlier to the end-user, among other things.</div>
<div class="line"><a name="l03161"></a><span class="lineno"> 3161</span>&#160;</div>
<div class="line"><a name="l03162"></a><span class="lineno"> 3162</span>&#160;The aim of Google<span class="stringliteral">&#39;s style guide is to make the code better organized, and more understandable for other developers. Our aim is to make the code easier to use for the novice user, for whom their firmware may be the first program they ever create.</span></div>
<div class="line"><a name="l03163"></a><span class="lineno"> 3163</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l03164"></a><span class="lineno"> 3164</span>&#160;<span class="stringliteral">## Existing differences</span></div>
<div class="line"><a name="l03165"></a><span class="lineno"> 3165</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l03166"></a><span class="lineno"> 3166</span>&#160;<span class="stringliteral">The list below is a collection of issues where our code differs from the recommendation, and where adapting to the guide is not immediately an obvious win. There are other cases where our code differs which I don&#39;</span>t list, when adapting to the guide is a no-brainer.</div>
<div class="line"><a name="l03167"></a><span class="lineno"> 3167</span>&#160;</div>
<div class="line"><a name="l03168"></a><span class="lineno"> 3168</span>&#160;* The guide mandates [lowercase <span class="keyword">namespace </span>names](https:<span class="comment">//google.github.io/styleguide/cppguide.html#Namespace_Names), while we (my plugins, mostly) use CamelCase. Lowercase makes sense, making it clear that a namespace is not a class, though.</span></div>
<div class="line"><a name="l03169"></a><span class="lineno"> 3169</span>&#160;* We use `#pragma once` instead of [`#define` guards](https:<span class="comment">//google.github.io/styleguide/cppguide.html#The__define_Guard), but that accomplishes the same thing. Nevertheless, we should use one or the other, so we&#39;d either have to switch, or augment the guide with a note.</span></div>
<div class="line"><a name="l03170"></a><span class="lineno"> 3170</span>&#160;* We use preprocessor macros a lot, while the guide [discourages them](https:<span class="comment">//google.github.io/styleguide/cppguide.html#Preprocessor_Macros).</span></div>
<div class="line"><a name="l03171"></a><span class="lineno"> 3171</span>&#160;* We use plenty of non-standard language extensions, while the guide [does not allow them](https:<span class="comment">//google.github.io/styleguide/cppguide.html#Nonstandard_Extensions). We don&#39;t need to care much about portability, because we&#39;ll be using GCC anyway. (Or perhaps Clang, which pretty much supports all the same extensions, as far as we are concerned)</span></div>
<div class="line"><a name="l03172"></a><span class="lineno"> 3172</span>&#160;* Our naming rules differ: the guide [suggests](https:<span class="comment">//google.github.io/styleguide/cppguide.html#General_Naming_Rules) snake_case for variables, for example. It also uses [lowercase names for files](https://google.github.io/styleguide/cppguide.html#File_Names). These all stem from the same goal of not using CamelCase by default, it seems. Mind you, reserving CamelCase for classes, and snake_case for variables is not a terrible idea... It does go against Arduino practices as far as I see, though. Even when it comes to CamelCase, Arduino usually goes for `fooBar` for functions, while Google would use `FooBar`. I think the Arduino convention is better here, to distinguish between member functions and classes.</span></div>
<div class="line"><a name="l03173"></a><span class="lineno"> 3173</span>&#160;</div>
<div class="line"><a name="l03174"></a><span class="lineno"> 3174</span>&#160;## Things not covered</div>
<div class="line"><a name="l03175"></a><span class="lineno"> 3175</span>&#160;</div>
<div class="line"><a name="l03176"></a><span class="lineno"> 3176</span>&#160;The guide does not cover naming, in a sense that it only controls how names should look, and does not impose a naming convention otherwise. As in, it does not tell whether to use `addHook` or `hookAdd` (or rather, `AddHook` or `HookAdd`).</div>
<div class="line"><a name="l03177"></a><span class="lineno"> 3177</span>&#160;</div>
<div class="line"><a name="l03178"></a><span class="lineno"> 3178</span>&#160;## Summary</div>
<div class="line"><a name="l03179"></a><span class="lineno"> 3179</span>&#160;</div>
<div class="line"><a name="l03180"></a><span class="lineno"> 3180</span>&#160;There are differences between the usual Arduino way, and between Google&#39;s guide, but not too much. It feels like we could opt for following Google&#39;s guide, with a few exceptions added to cover our use-cases.</div>
<div class="line"><a name="l03181"></a><span class="lineno"> 3181</span>&#160;</div>
<div class="line"><a name="l03182"></a><span class="lineno"> 3182</span>&#160;---</div>
<div class="line"><a name="l03183"></a><span class="lineno"> 3183</span>&#160;I looked at a few other guides, but a lot of them are old, or far less comprehensive than Google&#39;s one, so my suggestion would be to go with that, with the following exceptions, to be applied on top of it, overriding when in conflict:</div>
<div class="line"><a name="l03184"></a><span class="lineno"> 3184</span>&#160;</div>
<div class="line"><a name="l03185"></a><span class="lineno"> 3185</span>&#160;### File layout conventions</div>
<div class="line"><a name="l03186"></a><span class="lineno"> 3186</span>&#160;</div>
<div class="line"><a name="l03187"></a><span class="lineno"> 3187</span>&#160;* We are targeting modern Arduino, and as such, libraries should follow the [rev2.1](https:<span class="comment">//github.com/arduino/Arduino/wiki/Arduino-IDE-1.5:-Library-specification) layout and library specification.</span></div>
<div class="line"><a name="l03188"></a><span class="lineno"> 3188</span>&#160;* The main include header must have the same name as the library, and must be in the `src/` directory, as required by Arduino.</div>
<div class="line"><a name="l03189"></a><span class="lineno"> 3189</span>&#160;  + As we can&#39;t namespace public headers, their names should be prefixed with `Kaleidoscope-`.</div>
<div class="line"><a name="l03190"></a><span class="lineno"> 3190</span>&#160;  + Following Arduino conventions, library names are `CamelCase` - with the first letter being a capital letter too. Dashes may be used to denote namespaceing.</div>
<div class="line"><a name="l03191"></a><span class="lineno"> 3191</span>&#160;</div>
<div class="line"><a name="l03192"></a><span class="lineno"> 3192</span>&#160;### Headers</div>
<div class="line"><a name="l03193"></a><span class="lineno"> 3193</span>&#160;</div>
<div class="line"><a name="l03194"></a><span class="lineno"> 3194</span>&#160;* We are using `#pragma once` include guards in all public headers, not `#define` guards.</div>
<div class="line"><a name="l03195"></a><span class="lineno"> 3195</span>&#160;* Pre-processor macros are valid, and useful constructs, use them for helping the end-user define data structures, or static data to be stored in `PROGMEM`, where dynamic initialization is not an option.</div>
<div class="line"><a name="l03196"></a><span class="lineno"> 3196</span>&#160;</div>
<div class="line"><a name="l03197"></a><span class="lineno"> 3197</span>&#160;### Non-standard features</div>
<div class="line"><a name="l03198"></a><span class="lineno"> 3198</span>&#160;</div>
<div class="line"><a name="l03199"></a><span class="lineno"> 3199</span>&#160;* As our target compiler is GCC, use of non-standard extensions, such as compound statements is allowed, though not recommended, unless necessary for optimization purposes. Do it only if you must.</div>
<div class="line"><a name="l03200"></a><span class="lineno"> 3200</span>&#160;</div>
<div class="line"><a name="l03201"></a><span class="lineno"> 3201</span>&#160;### Naming &amp; organizing things</div>
<div class="line"><a name="l03202"></a><span class="lineno"> 3202</span>&#160;</div>
<div class="line"><a name="l03203"></a><span class="lineno"> 3203</span>&#160;* Namespaces should be lowercase, and preferably contain no underscores - not top-level namespaces, anyway.</div>
<div class="line"><a name="l03204"></a><span class="lineno"> 3204</span>&#160;* Class names are `CamelCase`, with the first letter being capital too.</div>
<div class="line"><a name="l03205"></a><span class="lineno"> 3205</span>&#160;* Data members in classes are `snake_case`, with an underscore at the end if they are not public.</div>
<div class="line"><a name="l03206"></a><span class="lineno"> 3206</span>&#160;* Function members are `camelCase`, with the first letter being lowercase.</div>
<div class="line"><a name="l03207"></a><span class="lineno"> 3207</span>&#160;  + Accessors may be `snake_case`, but prefer making the data member public, if it is of a simple type. (For performance and size considerations).</div>
<div class="line"><a name="l03208"></a><span class="lineno"> 3208</span>&#160;  + Function members should have their verb part first, so `addHook` instead of `hookAdd`. Group with namespaces, if need be, otherwise arrange functions that belong together, together, separate from the rest (in source code).</div>
<div class="line"><a name="l03209"></a><span class="lineno"> 3209</span>&#160;  + Do not repeat the class or namespace in the member names.</div>
<div class="line"><a name="l03210"></a><span class="lineno"> 3210</span>&#160;* Variables are `snake_case`, like data members, unless they are global instances of various classes, in which case they are `CamelCase`.</div>
<div class="line"><a name="l03211"></a><span class="lineno"> 3211</span>&#160;* It is recommended to put the class in a namespace, and when declaring the global, use the same name, but outside of the namespace. For example: `extern Kaleidoscope::Plugin::OneShot OneShot`.</div>
<div class="line"><a name="l03212"></a><span class="lineno"> 3212</span>&#160;</div>
<div class="line"><a name="l03213"></a><span class="lineno"> 3213</span>&#160;### Indentation and visual style</div>
<div class="line"><a name="l03214"></a><span class="lineno"> 3214</span>&#160;</div>
<div class="line"><a name="l03215"></a><span class="lineno"> 3215</span>&#160;* Follow the `make astyle` recommendations, and the Google Style Guide.</div>
<div class="line"><a name="l03216"></a><span class="lineno"> 3216</span>&#160;</div>
<div class="line"><a name="l03217"></a><span class="lineno"> 3217</span>&#160;</div>
<div class="line"><a name="l03218"></a><span class="lineno"> 3218</span>&#160;For context, some of the reasoning behind my proposal:</div>
<div class="line"><a name="l03219"></a><span class="lineno"> 3219</span>&#160;</div>
<div class="line"><a name="l03220"></a><span class="lineno"> 3220</span>&#160;* File conventions is pretty much what we have now. It is Arduino-compatible, and there&#39;s nothing wrong with it. It&#39;s just current practice codified.</div>
<div class="line"><a name="l03221"></a><span class="lineno"> 3221</span>&#160;* Headers &amp; non-standard features similarly.</div>
<div class="line"><a name="l03222"></a><span class="lineno"> 3222</span>&#160;</div>
<div class="line"><a name="l03223"></a><span class="lineno"> 3223</span>&#160;### Naming things</div>
<div class="line"><a name="l03224"></a><span class="lineno"> 3224</span>&#160;</div>
<div class="line"><a name="l03225"></a><span class="lineno"> 3225</span>&#160;I think lower-case namespace names make sense, as a way to differentiate classes, global objects, and namespaces. At the moment, `Kaleidoscope` is a global object, `KaleidoscopePlugins` is a namespace, and this is confusing. `kaledioscope::Keyboard`, or `kaleidoscope::Kaleidoscope` as the class is clearer than `Kaleidoscope_`, and we can still have a global `Kaleidoscope` object, because the namespace would be `kaleidoscope`.</div>
<div class="line"><a name="l03226"></a><span class="lineno"> 3226</span>&#160;</div>
<div class="line"><a name="l03227"></a><span class="lineno"> 3227</span>&#160;Thus:</div>
<div class="line"><a name="l03228"></a><span class="lineno"> 3228</span>&#160;</div>
<div class="line"><a name="l03229"></a><span class="lineno"> 3229</span>&#160;```c++</div>
<div class="line"><a name="l03230"></a><span class="lineno"> 3230</span>&#160;namespace kaleidoscope {</div>
<div class="line"><a name="l03231"></a><span class="lineno"> 3231</span>&#160;  class Kaleidoscope {</div>
<div class="line"><a name="l03232"></a><span class="lineno"> 3232</span>&#160;  public:</div>
<div class="line"><a name="l03233"></a><span class="lineno"> 3233</span>&#160;    uint16_t some_variable;</div>
<div class="line"><a name="l03234"></a><span class="lineno"> 3234</span>&#160;</div>
<div class="line"><a name="l03235"></a><span class="lineno"> 3235</span>&#160;    Kaleidoscope ();</div>
<div class="line"><a name="l03236"></a><span class="lineno"> 3236</span>&#160;</div>
<div class="line"><a name="l03237"></a><span class="lineno"> 3237</span>&#160;    void addSomething (...);</div>
<div class="line"><a name="l03238"></a><span class="lineno"> 3238</span>&#160;    void removeSomething (...);</div>
<div class="line"><a name="l03239"></a><span class="lineno"> 3239</span>&#160;</div>
<div class="line"><a name="l03240"></a><span class="lineno"> 3240</span>&#160;    SomeComplexType foo_bar(); <span class="comment">// getter</span></div>
<div class="line"><a name="l03241"></a><span class="lineno"> 3241</span>&#160;    void foo_bar(SomeComplexType v); <span class="comment">// setter</span></div>
<div class="line"><a name="l03242"></a><span class="lineno"> 3242</span>&#160;</div>
<div class="line"><a name="l03243"></a><span class="lineno"> 3243</span>&#160;  private:</div>
<div class="line"><a name="l03244"></a><span class="lineno"> 3244</span>&#160;    SomeComplexType foo_bar_;</div>
<div class="line"><a name="l03245"></a><span class="lineno"> 3245</span>&#160;  };</div>
<div class="line"><a name="l03246"></a><span class="lineno"> 3246</span>&#160;};</div>
<div class="line"><a name="l03247"></a><span class="lineno"> 3247</span>&#160;</div>
<div class="line"><a name="l03248"></a><span class="lineno"> 3248</span>&#160;extern kaleidoscope::Kaleidoscope Kaleidoscope;</div>
<div class="line"><a name="l03249"></a><span class="lineno"> 3249</span>&#160;```</div>
<div class="line"><a name="l03250"></a><span class="lineno"> 3250</span>&#160;</div>
<div class="line"><a name="l03251"></a><span class="lineno"> 3251</span>&#160;This would allow us to get rid of the ugly `KaleidoscopePlugin` namespace. Using namespaces in general would make a lot of code look much nicer. They are not a big thing in the Arduino world, as far as I see, but they are great tools for clarity.</div>
<div class="line"><a name="l03252"></a><span class="lineno"> 3252</span>&#160;</div>
<div class="line"><a name="l03253"></a><span class="lineno"> 3253</span>&#160;The above code demonstrates all the various ways to name things, and how they make it clearer what is what:</div>
<div class="line"><a name="l03254"></a><span class="lineno"> 3254</span>&#160;</div>
<div class="line"><a name="l03255"></a><span class="lineno"> 3255</span>&#160;* All classes are namespaced, so start with a `namespace::` prefix when used.</div>
<div class="line"><a name="l03256"></a><span class="lineno"> 3256</span>&#160;* Classes are always namespaced, and are `CamelCase`.</div>
<div class="line"><a name="l03257"></a><span class="lineno"> 3257</span>&#160;* All global objects are `CamelCase`. Whether a symbol is a class or an instance is not immediately clear from the name, but the position makes it easy to figure out. As our focus is on the end-user who will rarely - if ever - have to care about classes, and works with objects most of the time, this is fine, and as such, we do not need a more visible distinction.</div>
<div class="line"><a name="l03258"></a><span class="lineno"> 3258</span>&#160;* Data members are `snake_case`, and have a trailing underscore when not public.</div>
<div class="line"><a name="l03259"></a><span class="lineno"> 3259</span>&#160;* Data members are public, if setters/getters would be simple assignments or returns, and when access to them from outside is required.</div>
<div class="line"><a name="l03260"></a><span class="lineno"> 3260</span>&#160;* Function members are `camelCase`, and start with a verb, different from class and global object names that start with a capital letter.</div>
<div class="line"><a name="l03261"></a><span class="lineno"> 3261</span>&#160;  + Except setter/getter methods, which follow the data member naming convention.</div>
<div class="line"><a name="l03262"></a><span class="lineno"> 3262</span>&#160;</div>
<div class="line"><a name="l03263"></a><span class="lineno"> 3263</span>&#160;Due to size constraints, and with the goal of being easier for the novice user to get started, we use a lot of global objects, and prefer to avoid inheritance in user-facing APIs. The goal is that the end-user will not have to subclass anything, and that building on top of existing plugins is possible by composing them, as opposed to deriving from them.</div>
<div class="line"><a name="l03264"></a><span class="lineno"> 3264</span>&#160;</div>
<div class="line"><a name="l03265"></a><span class="lineno"> 3265</span>&#160;-- from @obra:</div>
<div class="line"><a name="l03266"></a><span class="lineno"> 3266</span>&#160;</div>
<div class="line"><a name="l03267"></a><span class="lineno"> 3267</span>&#160;11:42 &lt;@obra&gt; https:<span class="comment">//google.github.io/styleguide/cppguide.html#Inline_Functions - Our version of that is going</span></div>
<div class="line"><a name="l03268"></a><span class="lineno"> 3268</span>&#160;              to be more along the lines of &quot;explicitly inline functions when it saves compiled space. For the</div>
<div class="line"><a name="l03269"></a><span class="lineno"> 3269</span>&#160;              most part, the compiler will do the right thing without hinting. It is sometimes acceptable to</div>
<div class="line"><a name="l03270"></a><span class="lineno"> 3270</span>&#160;              force a function to not be inlined using the GCC extension void __attribute__ ((noinline)) foo() &quot;</div>
<div class="line"><a name="l03271"></a><span class="lineno"> 3271</span>&#160;</div>
<div class="line"><a name="l03272"></a><span class="lineno"> 3272</span>&#160;&lt;pre&gt;</div>
<div class="line"><a name="l03273"></a><span class="lineno"> 3273</span>&#160;</div>
<div class="line"><a name="l03274"></a><span class="lineno"> 3274</span>&#160;</div>
<div class="line"><a name="l03275"></a><span class="lineno"> 3275</span>&#160;&lt;h1&gt;The following content is the Arduino library API style guide. In places where it does not contradict the style guide above, you should follow it.&lt;/h1&gt;</div>
<div class="line"><a name="l03276"></a><span class="lineno"> 3276</span>&#160;&lt;p&gt;We should work to integrate this content into the main style guide&lt;/p&gt;</div>
<div class="line"><a name="l03277"></a><span class="lineno"> 3277</span>&#160;</div>
<div class="line"><a name="l03278"></a><span class="lineno"> 3278</span>&#160;&lt;h1&gt;Arduino Style Guide for Writing Libraries&lt;/h1&gt;</div>
<div class="line"><a name="l03279"></a><span class="lineno"> 3279</span>&#160;&lt;p&gt;This is a style guide to writing library &lt;span class=&#39;wikiword&#39;&gt;APIs&lt;/span&gt; in an Arduino style. Some of these run counter to professional programming practice. We re aware of that, but its whats made it possible for so many beginners to get started with Arduino easily. So please code with these principles in mind. If you have suggestions on how to make Arduino libraries clearer for that core audience, please jump in the discussion. This is a work in progress.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Be kind to the end user.&lt;/strong&gt;
Assume you are writing an API for an intelligent person who has not programmed before. Come up with a clear mental model of the concept youre working with, and the terms and functions you will use.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Match your API to the underlying capabilities.&lt;/strong&gt; You dont want to expose implementation details to the user but you also dont want an API that suggests an inaccurate mental model of the possibilities. For example, if there are only a few possible options for a particular setting, dont use a function that takes an int, as it implies you can use any value you want.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Organize your public functions around the data and functionality that the user wants.&lt;/strong&gt; Quite often, the command set for a particular electronic module is overly complicated for the most common uses, or can be re-organized around higher level functionality. Think about what the average person thinks the thing does, and try to organise your API functions around that. Adafruit&#39;s &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;BMP085 library&lt;/a&gt; is a good example. The readPressure() command performs all the necessary steps to get the final pressure. The library wraps this commonly executed series of functions into a high-level single command which returns the value the user&#39;s looking for in a format she expects. It abstracts away not only the low-level &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt; commands, but also the mid-level temperature and pressure calculations, while still offering those mid-level functions as public functions for those who want them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use full, everyday words.&lt;/strong&gt; Dont be terse with your function names or variables. Use everyday terms instead of technical ones. Pick terms that correspond to popular perception of the concept at hand. Dont assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 re aware of that, but its whats made it possible for so many beginners to get started with Arduino easily. So please code with these principles in mind. If you have suggestions on how to make Arduino libraries clearer for that core audience, please jump in the discussion. This is a work in progress.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Be kind to the end user.&lt;/strong&gt;
Assume you are writing an API for an intelligent person who has not programmed before. Come up with a clear mental model of the concept youre working with, and the terms and functions you will use.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Match your API to the underlying capabilities.&lt;/strong&gt; You dont want to expose implementation details to the user but you also dont want an API that suggests an inaccurate mental model of the possibilities. For example, if there are only a few possible options for a particular setting, dont use a function that takes an int, as it implies you can use any value you want.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Organize your public functions around the data and functionality that the user wants.&lt;/strong&gt; Quite often, the command set for a particular electronic module is overly complicated for the most common uses, or can be re-organized around higher level functionality. Think about what the average person thinks the thing does, and try to organise your API functions around that. Adafruit&#39;s &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;BMP085 library&lt;/a&gt; is a good example. The readPressure() command performs all the necessary steps to get the final pressure. The library wraps this commonly executed series of functions into a high-level single command which returns the value the user&#39;s looking for in a format she expects. It abstracts away not only the low-level &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt; commands, but also the mid-level temperature and pressure calculations, while still offering those mid-level functions as public functions for those who want them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use full, everyday words.&lt;/strong&gt; Dont be terse with your function names or variables. Use everyday terms instead of technical ones. Pick terms that correspond to popular perception of the concept at hand. Dont assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 e aware of that, but its whats made it possible for so many beginners to get started with Arduino easily. So please code with these principles in mind. If you have suggestions on how to make Arduino libraries clearer for that core audience, please jump in the discussion. This is a work in progress.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Be kind to the end user.&lt;/strong&gt;
Assume you are writing an API for an intelligent person who has not programmed before. Come up with a clear mental model of the concept youre working with, and the terms and functions you will use.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Match your API to the underlying capabilities.&lt;/strong&gt; You dont want to expose implementation details to the user but you also dont want an API that suggests an inaccurate mental model of the possibilities. For example, if there are only a few possible options for a particular setting, dont use a function that takes an int, as it implies you can use any value you want.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Organize your public functions around the data and functionality that the user wants.&lt;/strong&gt; Quite often, the command set for a particular electronic module is overly complicated for the most common uses, or can be re-organized around higher level functionality. Think about what the average person thinks the thing does, and try to organise your API functions around that. Adafruit&#39;s &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;BMP085 library&lt;/a&gt; is a good example. The readPressure() command performs all the necessary steps to get the final pressure. The library wraps this commonly executed series of functions into a high-level single command which returns the value the user&#39;s looking for in a format she expects. It abstracts away not only the low-level &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt; commands, but also the mid-level temperature and pressure calculations, while still offering those mid-level functions as public functions for those who want them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use full, everyday words.&lt;/strong&gt; Dont be terse with your function names or variables. Use everyday terms instead of technical ones. Pick terms that correspond to popular perception of the concept at hand. Dont assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
re aware of that, but it s whats made it possible for so many beginners to get started with Arduino easily. So please code with these principles in mind. If you have suggestions on how to make Arduino libraries clearer for that core audience, please jump in the discussion. This is a work in progress.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Be kind to the end user.&lt;/strong&gt;
Assume you are writing an API for an intelligent person who has not programmed before. Come up with a clear mental model of the concept youre working with, and the terms and functions you will use.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Match your API to the underlying capabilities.&lt;/strong&gt; You dont want to expose implementation details to the user but you also dont want an API that suggests an inaccurate mental model of the possibilities. For example, if there are only a few possible options for a particular setting, dont use a function that takes an int, as it implies you can use any value you want.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Organize your public functions around the data and functionality that the user wants.&lt;/strong&gt; Quite often, the command set for a particular electronic module is overly complicated for the most common uses, or can be re-organized around higher level functionality. Think about what the average person thinks the thing does, and try to organise your API functions around that. Adafruit&#39;s &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;BMP085 library&lt;/a&gt; is a good example. The readPressure() command performs all the necessary steps to get the final pressure. The library wraps this commonly executed series of functions into a high-level single command which returns the value the user&#39;s looking for in a format she expects. It abstracts away not only the low-level &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt; commands, but also the mid-level temperature and pressure calculations, while still offering those mid-level functions as public functions for those who want them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use full, everyday words.&lt;/strong&gt; Dont be terse with your function names or variables. Use everyday terms instead of technical ones. Pick terms that correspond to popular perception of the concept at hand. Dont assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 s whats made it possible for so many beginners to get started with Arduino easily. So please code with these principles in mind. If you have suggestions on how to make Arduino libraries clearer for that core audience, please jump in the discussion. This is a work in progress.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Be kind to the end user.&lt;/strong&gt;
Assume you are writing an API for an intelligent person who has not programmed before. Come up with a clear mental model of the concept youre working with, and the terms and functions you will use.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Match your API to the underlying capabilities.&lt;/strong&gt; You dont want to expose implementation details to the user but you also dont want an API that suggests an inaccurate mental model of the possibilities. For example, if there are only a few possible options for a particular setting, dont use a function that takes an int, as it implies you can use any value you want.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Organize your public functions around the data and functionality that the user wants.&lt;/strong&gt; Quite often, the command set for a particular electronic module is overly complicated for the most common uses, or can be re-organized around higher level functionality. Think about what the average person thinks the thing does, and try to organise your API functions around that. Adafruit&#39;s &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;BMP085 library&lt;/a&gt; is a good example. The readPressure() command performs all the necessary steps to get the final pressure. The library wraps this commonly executed series of functions into a high-level single command which returns the value the user&#39;s looking for in a format she expects. It abstracts away not only the low-level &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt; commands, but also the mid-level temperature and pressure calculations, while still offering those mid-level functions as public functions for those who want them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use full, everyday words.&lt;/strong&gt; Dont be terse with your function names or variables. Use everyday terms instead of technical ones. Pick terms that correspond to popular perception of the concept at hand. Dont assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
  whats made it possible for so many beginners to get started with Arduino easily. So please code with these principles in mind. If you have suggestions on how to make Arduino libraries clearer for that core audience, please jump in the discussion. This is a work in progress.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Be kind to the end user.&lt;/strong&gt;
Assume you are writing an API for an intelligent person who has not programmed before. Come up with a clear mental model of the concept youre working with, and the terms and functions you will use.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Match your API to the underlying capabilities.&lt;/strong&gt; You dont want to expose implementation details to the user but you also dont want an API that suggests an inaccurate mental model of the possibilities. For example, if there are only a few possible options for a particular setting, dont use a function that takes an int, as it implies you can use any value you want.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Organize your public functions around the data and functionality that the user wants.&lt;/strong&gt; Quite often, the command set for a particular electronic module is overly complicated for the most common uses, or can be re-organized around higher level functionality. Think about what the average person thinks the thing does, and try to organise your API functions around that. Adafruit&#39;s &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;BMP085 library&lt;/a&gt; is a good example. The readPressure() command performs all the necessary steps to get the final pressure. The library wraps this commonly executed series of functions into a high-level single command which returns the value the user&#39;s looking for in a format she expects. It abstracts away not only the low-level &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt; commands, but also the mid-level temperature and pressure calculations, while still offering those mid-level functions as public functions for those who want them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use full, everyday words.&lt;/strong&gt; Dont be terse with your function names or variables. Use everyday terms instead of technical ones. Pick terms that correspond to popular perception of the concept at hand. Dont assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
s what s made it possible for so many beginners to get started with Arduino easily. So please code with these principles in mind. If you have suggestions on how to make Arduino libraries clearer for that core audience, please jump in the discussion. This is a work in progress.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Be kind to the end user.&lt;/strong&gt;
Assume you are writing an API for an intelligent person who has not programmed before. Come up with a clear mental model of the concept youre working with, and the terms and functions you will use.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Match your API to the underlying capabilities.&lt;/strong&gt; You dont want to expose implementation details to the user but you also dont want an API that suggests an inaccurate mental model of the possibilities. For example, if there are only a few possible options for a particular setting, dont use a function that takes an int, as it implies you can use any value you want.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Organize your public functions around the data and functionality that the user wants.&lt;/strong&gt; Quite often, the command set for a particular electronic module is overly complicated for the most common uses, or can be re-organized around higher level functionality. Think about what the average person thinks the thing does, and try to organise your API functions around that. Adafruit&#39;s &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;BMP085 library&lt;/a&gt; is a good example. The readPressure() command performs all the necessary steps to get the final pressure. The library wraps this commonly executed series of functions into a high-level single command which returns the value the user&#39;s looking for in a format she expects. It abstracts away not only the low-level &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt; commands, but also the mid-level temperature and pressure calculations, while still offering those mid-level functions as public functions for those who want them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use full, everyday words.&lt;/strong&gt; Dont be terse with your function names or variables. Use everyday terms instead of technical ones. Pick terms that correspond to popular perception of the concept at hand. Dont assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 s made it possible for so many beginners to get started with Arduino easily. So please code with these principles in mind. If you have suggestions on how to make Arduino libraries clearer for that core audience, please jump in the discussion. This is a work in progress.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Be kind to the end user.&lt;/strong&gt;
Assume you are writing an API for an intelligent person who has not programmed before. Come up with a clear mental model of the concept youre working with, and the terms and functions you will use.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Match your API to the underlying capabilities.&lt;/strong&gt; You dont want to expose implementation details to the user but you also dont want an API that suggests an inaccurate mental model of the possibilities. For example, if there are only a few possible options for a particular setting, dont use a function that takes an int, as it implies you can use any value you want.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Organize your public functions around the data and functionality that the user wants.&lt;/strong&gt; Quite often, the command set for a particular electronic module is overly complicated for the most common uses, or can be re-organized around higher level functionality. Think about what the average person thinks the thing does, and try to organise your API functions around that. Adafruit&#39;s &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;BMP085 library&lt;/a&gt; is a good example. The readPressure() command performs all the necessary steps to get the final pressure. The library wraps this commonly executed series of functions into a high-level single command which returns the value the user&#39;s looking for in a format she expects. It abstracts away not only the low-level &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt; commands, but also the mid-level temperature and pressure calculations, while still offering those mid-level functions as public functions for those who want them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use full, everyday words.&lt;/strong&gt; Dont be terse with your function names or variables. Use everyday terms instead of technical ones. Pick terms that correspond to popular perception of the concept at hand. Dont assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
  made it possible for so many beginners to get started with Arduino easily. So please code with these principles in mind. If you have suggestions on how to make Arduino libraries clearer for that core audience, please jump in the discussion. This is a work in progress.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Be kind to the end user.&lt;/strong&gt;
Assume you are writing an API for an intelligent person who has not programmed before. Come up with a clear mental model of the concept youre working with, and the terms and functions you will use.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Match your API to the underlying capabilities.&lt;/strong&gt; You dont want to expose implementation details to the user but you also dont want an API that suggests an inaccurate mental model of the possibilities. For example, if there are only a few possible options for a particular setting, dont use a function that takes an int, as it implies you can use any value you want.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Organize your public functions around the data and functionality that the user wants.&lt;/strong&gt; Quite often, the command set for a particular electronic module is overly complicated for the most common uses, or can be re-organized around higher level functionality. Think about what the average person thinks the thing does, and try to organise your API functions around that. Adafruit&#39;s &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;BMP085 library&lt;/a&gt; is a good example. The readPressure() command performs all the necessary steps to get the final pressure. The library wraps this commonly executed series of functions into a high-level single command which returns the value the user&#39;s looking for in a format she expects. It abstracts away not only the low-level &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt; commands, but also the mid-level temperature and pressure calculations, while still offering those mid-level functions as public functions for those who want them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use full, everyday words.&lt;/strong&gt; Dont be terse with your function names or variables. Use everyday terms instead of technical ones. Pick terms that correspond to popular perception of the concept at hand. Dont assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
s made it possible for so many beginners to get started with Arduino easily. So please code with these principles in mind. If you have suggestions on how to make Arduino libraries clearer for that core audience, please jump in the discussion. This is a work in progress.</div>
<div class="line"><a name="l03280"></a><span class="lineno"> 3280</span>&#160;&lt;/p&gt;</div>
<div class="line"><a name="l03281"></a><span class="lineno"> 3281</span>&#160;&lt;p&gt;&lt;strong&gt;Be kind to the end user.&lt;/strong&gt;</div>
<div class="line"><a name="l03282"></a><span class="lineno"> 3282</span>&#160;Assume you are writing an API for an intelligent person who has not programmed before. Come up with a clear mental model of the concept you re working with, and the terms and functions you will use.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Match your API to the underlying capabilities.&lt;/strong&gt; You dont want to expose implementation details to the user but you also dont want an API that suggests an inaccurate mental model of the possibilities. For example, if there are only a few possible options for a particular setting, dont use a function that takes an int, as it implies you can use any value you want.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Organize your public functions around the data and functionality that the user wants.&lt;/strong&gt; Quite often, the command set for a particular electronic module is overly complicated for the most common uses, or can be re-organized around higher level functionality. Think about what the average person thinks the thing does, and try to organise your API functions around that. Adafruit&#39;s &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;BMP085 library&lt;/a&gt; is a good example. The readPressure() command performs all the necessary steps to get the final pressure. The library wraps this commonly executed series of functions into a high-level single command which returns the value the user&#39;s looking for in a format she expects. It abstracts away not only the low-level &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt; commands, but also the mid-level temperature and pressure calculations, while still offering those mid-level functions as public functions for those who want them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use full, everyday words.&lt;/strong&gt; Dont be terse with your function names or variables. Use everyday terms instead of technical ones. Pick terms that correspond to popular perception of the concept at hand. Dont assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 re working with, and the terms and functions you will use.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Match your API to the underlying capabilities.&lt;/strong&gt; You dont want to expose implementation details to the user but you also dont want an API that suggests an inaccurate mental model of the possibilities. For example, if there are only a few possible options for a particular setting, dont use a function that takes an int, as it implies you can use any value you want.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Organize your public functions around the data and functionality that the user wants.&lt;/strong&gt; Quite often, the command set for a particular electronic module is overly complicated for the most common uses, or can be re-organized around higher level functionality. Think about what the average person thinks the thing does, and try to organise your API functions around that. Adafruit&#39;s &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;BMP085 library&lt;/a&gt; is a good example. The readPressure() command performs all the necessary steps to get the final pressure. The library wraps this commonly executed series of functions into a high-level single command which returns the value the user&#39;s looking for in a format she expects. It abstracts away not only the low-level &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt; commands, but also the mid-level temperature and pressure calculations, while still offering those mid-level functions as public functions for those who want them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use full, everyday words.&lt;/strong&gt; Dont be terse with your function names or variables. Use everyday terms instead of technical ones. Pick terms that correspond to popular perception of the concept at hand. Dont assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 e working with, and the terms and functions you will use.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Match your API to the underlying capabilities.&lt;/strong&gt; You dont want to expose implementation details to the user but you also dont want an API that suggests an inaccurate mental model of the possibilities. For example, if there are only a few possible options for a particular setting, dont use a function that takes an int, as it implies you can use any value you want.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Organize your public functions around the data and functionality that the user wants.&lt;/strong&gt; Quite often, the command set for a particular electronic module is overly complicated for the most common uses, or can be re-organized around higher level functionality. Think about what the average person thinks the thing does, and try to organise your API functions around that. Adafruit&#39;s &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;BMP085 library&lt;/a&gt; is a good example. The readPressure() command performs all the necessary steps to get the final pressure. The library wraps this commonly executed series of functions into a high-level single command which returns the value the user&#39;s looking for in a format she expects. It abstracts away not only the low-level &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt; commands, but also the mid-level temperature and pressure calculations, while still offering those mid-level functions as public functions for those who want them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use full, everyday words.&lt;/strong&gt; Dont be terse with your function names or variables. Use everyday terms instead of technical ones. Pick terms that correspond to popular perception of the concept at hand. Dont assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
re working with, and the terms and functions you will use.</div>
<div class="line"><a name="l03283"></a><span class="lineno"> 3283</span>&#160;&lt;/p&gt;</div>
<div class="line"><a name="l03284"></a><span class="lineno"> 3284</span>&#160;&lt;p&gt;&lt;strong&gt;Match your API to the underlying capabilities.&lt;/strong&gt; You don t want to expose implementation details to the user but you also dont want an API that suggests an inaccurate mental model of the possibilities. For example, if there are only a few possible options for a particular setting, dont use a function that takes an int, as it implies you can use any value you want.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Organize your public functions around the data and functionality that the user wants.&lt;/strong&gt; Quite often, the command set for a particular electronic module is overly complicated for the most common uses, or can be re-organized around higher level functionality. Think about what the average person thinks the thing does, and try to organise your API functions around that. Adafruit&#39;s &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;BMP085 library&lt;/a&gt; is a good example. The readPressure() command performs all the necessary steps to get the final pressure. The library wraps this commonly executed series of functions into a high-level single command which returns the value the user&#39;s looking for in a format she expects. It abstracts away not only the low-level &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt; commands, but also the mid-level temperature and pressure calculations, while still offering those mid-level functions as public functions for those who want them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use full, everyday words.&lt;/strong&gt; Dont be terse with your function names or variables. Use everyday terms instead of technical ones. Pick terms that correspond to popular perception of the concept at hand. Dont assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 t want to expose implementation details to the user but you also dont want an API that suggests an inaccurate mental model of the possibilities. For example, if there are only a few possible options for a particular setting, dont use a function that takes an int, as it implies you can use any value you want.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Organize your public functions around the data and functionality that the user wants.&lt;/strong&gt; Quite often, the command set for a particular electronic module is overly complicated for the most common uses, or can be re-organized around higher level functionality. Think about what the average person thinks the thing does, and try to organise your API functions around that. Adafruit&#39;s &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;BMP085 library&lt;/a&gt; is a good example. The readPressure() command performs all the necessary steps to get the final pressure. The library wraps this commonly executed series of functions into a high-level single command which returns the value the user&#39;s looking for in a format she expects. It abstracts away not only the low-level &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt; commands, but also the mid-level temperature and pressure calculations, while still offering those mid-level functions as public functions for those who want them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use full, everyday words.&lt;/strong&gt; Dont be terse with your function names or variables. Use everyday terms instead of technical ones. Pick terms that correspond to popular perception of the concept at hand. Dont assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
  want to expose implementation details to the user but you also dont want an API that suggests an inaccurate mental model of the possibilities. For example, if there are only a few possible options for a particular setting, dont use a function that takes an int, as it implies you can use any value you want.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Organize your public functions around the data and functionality that the user wants.&lt;/strong&gt; Quite often, the command set for a particular electronic module is overly complicated for the most common uses, or can be re-organized around higher level functionality. Think about what the average person thinks the thing does, and try to organise your API functions around that. Adafruit&#39;s &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;BMP085 library&lt;/a&gt; is a good example. The readPressure() command performs all the necessary steps to get the final pressure. The library wraps this commonly executed series of functions into a high-level single command which returns the value the user&#39;s looking for in a format she expects. It abstracts away not only the low-level &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt; commands, but also the mid-level temperature and pressure calculations, while still offering those mid-level functions as public functions for those who want them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use full, everyday words.&lt;/strong&gt; Dont be terse with your function names or variables. Use everyday terms instead of technical ones. Pick terms that correspond to popular perception of the concept at hand. Dont assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
t want to expose implementation details to the user but you also don t want an API that suggests an inaccurate mental model of the possibilities. For example, if there are only a few possible options for a particular setting, dont use a function that takes an int, as it implies you can use any value you want.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Organize your public functions around the data and functionality that the user wants.&lt;/strong&gt; Quite often, the command set for a particular electronic module is overly complicated for the most common uses, or can be re-organized around higher level functionality. Think about what the average person thinks the thing does, and try to organise your API functions around that. Adafruit&#39;s &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;BMP085 library&lt;/a&gt; is a good example. The readPressure() command performs all the necessary steps to get the final pressure. The library wraps this commonly executed series of functions into a high-level single command which returns the value the user&#39;s looking for in a format she expects. It abstracts away not only the low-level &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt; commands, but also the mid-level temperature and pressure calculations, while still offering those mid-level functions as public functions for those who want them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use full, everyday words.&lt;/strong&gt; Dont be terse with your function names or variables. Use everyday terms instead of technical ones. Pick terms that correspond to popular perception of the concept at hand. Dont assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 t want an API that suggests an inaccurate mental model of the possibilities. For example, if there are only a few possible options for a particular setting, dont use a function that takes an int, as it implies you can use any value you want.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Organize your public functions around the data and functionality that the user wants.&lt;/strong&gt; Quite often, the command set for a particular electronic module is overly complicated for the most common uses, or can be re-organized around higher level functionality. Think about what the average person thinks the thing does, and try to organise your API functions around that. Adafruit&#39;s &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;BMP085 library&lt;/a&gt; is a good example. The readPressure() command performs all the necessary steps to get the final pressure. The library wraps this commonly executed series of functions into a high-level single command which returns the value the user&#39;s looking for in a format she expects. It abstracts away not only the low-level &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt; commands, but also the mid-level temperature and pressure calculations, while still offering those mid-level functions as public functions for those who want them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use full, everyday words.&lt;/strong&gt; Dont be terse with your function names or variables. Use everyday terms instead of technical ones. Pick terms that correspond to popular perception of the concept at hand. Dont assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
  want an API that suggests an inaccurate mental model of the possibilities. For example, if there are only a few possible options for a particular setting, dont use a function that takes an int, as it implies you can use any value you want.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Organize your public functions around the data and functionality that the user wants.&lt;/strong&gt; Quite often, the command set for a particular electronic module is overly complicated for the most common uses, or can be re-organized around higher level functionality. Think about what the average person thinks the thing does, and try to organise your API functions around that. Adafruit&#39;s &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;BMP085 library&lt;/a&gt; is a good example. The readPressure() command performs all the necessary steps to get the final pressure. The library wraps this commonly executed series of functions into a high-level single command which returns the value the user&#39;s looking for in a format she expects. It abstracts away not only the low-level &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt; commands, but also the mid-level temperature and pressure calculations, while still offering those mid-level functions as public functions for those who want them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use full, everyday words.&lt;/strong&gt; Dont be terse with your function names or variables. Use everyday terms instead of technical ones. Pick terms that correspond to popular perception of the concept at hand. Dont assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
t want an API that suggests an inaccurate mental model of the possibilities. For example, if there are only a few possible options for a particular setting, don t use a function that takes an int, as it implies you can use any value you want.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Organize your public functions around the data and functionality that the user wants.&lt;/strong&gt; Quite often, the command set for a particular electronic module is overly complicated for the most common uses, or can be re-organized around higher level functionality. Think about what the average person thinks the thing does, and try to organise your API functions around that. Adafruit&#39;s &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;BMP085 library&lt;/a&gt; is a good example. The readPressure() command performs all the necessary steps to get the final pressure. The library wraps this commonly executed series of functions into a high-level single command which returns the value the user&#39;s looking for in a format she expects. It abstracts away not only the low-level &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt; commands, but also the mid-level temperature and pressure calculations, while still offering those mid-level functions as public functions for those who want them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use full, everyday words.&lt;/strong&gt; Dont be terse with your function names or variables. Use everyday terms instead of technical ones. Pick terms that correspond to popular perception of the concept at hand. Dont assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 t use a function that takes an int, as it implies you can use any value you want.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Organize your public functions around the data and functionality that the user wants.&lt;/strong&gt; Quite often, the command set for a particular electronic module is overly complicated for the most common uses, or can be re-organized around higher level functionality. Think about what the average person thinks the thing does, and try to organise your API functions around that. Adafruit&#39;s &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;BMP085 library&lt;/a&gt; is a good example. The readPressure() command performs all the necessary steps to get the final pressure. The library wraps this commonly executed series of functions into a high-level single command which returns the value the user&#39;s looking for in a format she expects. It abstracts away not only the low-level &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt; commands, but also the mid-level temperature and pressure calculations, while still offering those mid-level functions as public functions for those who want them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use full, everyday words.&lt;/strong&gt; Dont be terse with your function names or variables. Use everyday terms instead of technical ones. Pick terms that correspond to popular perception of the concept at hand. Dont assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
  use a function that takes an int, as it implies you can use any value you want.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Organize your public functions around the data and functionality that the user wants.&lt;/strong&gt; Quite often, the command set for a particular electronic module is overly complicated for the most common uses, or can be re-organized around higher level functionality. Think about what the average person thinks the thing does, and try to organise your API functions around that. Adafruit&#39;s &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;BMP085 library&lt;/a&gt; is a good example. The readPressure() command performs all the necessary steps to get the final pressure. The library wraps this commonly executed series of functions into a high-level single command which returns the value the user&#39;s looking for in a format she expects. It abstracts away not only the low-level &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt; commands, but also the mid-level temperature and pressure calculations, while still offering those mid-level functions as public functions for those who want them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use full, everyday words.&lt;/strong&gt; Dont be terse with your function names or variables. Use everyday terms instead of technical ones. Pick terms that correspond to popular perception of the concept at hand. Dont assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
t use a function that takes an int, as it implies you can use any value you want.</div>
<div class="line"><a name="l03285"></a><span class="lineno"> 3285</span>&#160;&lt;/p&gt;</div>
<div class="line"><a name="l03286"></a><span class="lineno"> 3286</span>&#160;&lt;p&gt;&lt;strong&gt;Organize your public functions around the data and functionality that the user wants.&lt;/strong&gt; Quite often, the command set for a particular electronic module is overly complicated for the most common uses, or can be re-organized around higher level functionality. Think about what the average person thinks the thing does, and try to organise your API functions around that. Adafruit&#39;s &lt;a class=&#39;urllink&#39; href=&#39;https:<span class="comment">//github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;BMP085 library&lt;/a&gt; is a good example. The readPressure() command performs all the necessary steps to get the final pressure. The library wraps this commonly executed series of functions into a high-level single command which returns the value the user&#39;s looking for in a format she expects. It abstracts away not only the low-level &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt; commands, but also the mid-level temperature and pressure calculations, while still offering those mid-level functions as public functions for those who want them.</span></div>
<div class="line"><a name="l03287"></a><span class="lineno"> 3287</span>&#160;&lt;/p&gt;</div>
<div class="line"><a name="l03288"></a><span class="lineno"> 3288</span>&#160;&lt;p&gt;&lt;strong&gt;Use full, everyday words.&lt;/strong&gt; Don t be terse with your function names or variables. Use everyday terms instead of technical ones. Pick terms that correspond to popular perception of the concept at hand. Dont assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 t be terse with your function names or variables. Use everyday terms instead of technical ones. Pick terms that correspond to popular perception of the concept at hand. Dont assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
  be terse with your function names or variables. Use everyday terms instead of technical ones. Pick terms that correspond to popular perception of the concept at hand. Dont assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
t be terse with your function names or variables. Use everyday terms instead of technical ones. Pick terms that correspond to popular perception of the concept at hand. Don t assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 t assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
  assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if theyre in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
t assume specialized knowledge. For example, this is why we used analogWrite() rather than pwm(). Abbreviations are acceptable, though, if they re in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 re in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 e in common use or are the primary name for something.For example, HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
re in common use or are the primary name for something.For example,  HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 HTML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 TML is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
HTML  is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
  is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 is relatively common and SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 is relatively common and  SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 SPI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 PI is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
SPI  is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
  is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 is effectively the name of that protocol (serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 is effectively the name of that protocol ( serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 serial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 erial-peripheral interface is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
serial-peripheral interface  is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
  is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 is probably too long). (Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 is probably too long). ( Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 Wire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 ire was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
Wire  was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
  was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 was probably a mistake, as the protocol it uses is typically called TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 was probably a mistake, as the protocol it uses is typically called  TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 TWI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 WI or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
TWI  or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
  or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 or &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 or  &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 &lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;.)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt; .)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 .)
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 )
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; Youll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
.)</div>
<div class="line"><a name="l03289"></a><span class="lineno"> 3289</span>&#160;&lt;/p&gt;</div>
<div class="line"><a name="l03290"></a><span class="lineno"> 3290</span>&#160;&lt;p&gt;&lt;strong&gt;Avoid words that have different meanings to the general public.&lt;/strong&gt; For example, to programmers, an error is a notification that something happened. To the general public, errors are bad things.</div>
<div class="line"><a name="l03291"></a><span class="lineno"> 3291</span>&#160;&lt;/p&gt;</div>
<div class="line"><a name="l03292"></a><span class="lineno"> 3292</span>&#160;&lt;p&gt;&lt;strong&gt;When you have to use a domain-specific term, write a sentence or two describing it to the general public FIRST.&lt;/strong&gt; You ll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 ll likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 l likely come across a better term, and if not, youll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
ll likely come across a better term, and if not, you ll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 ll have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 l have started the documentation on your library.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http://arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;
&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.
* Use the Stream.h and Print.h libraries when dealing with byte streams. If its not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
ll have started the documentation on your library.</div>
<div class="line"><a name="l03293"></a><span class="lineno"> 3293</span>&#160;&lt;/p&gt;</div>
<div class="line"><a name="l03294"></a><span class="lineno"> 3294</span>&#160;&lt;p&gt;&lt;strong&gt;Document and comment as you go.&lt;/strong&gt; When writing examples and documentation, follow this style guide: &lt;a class=&#39;urllink&#39; href=&#39;http:<span class="comment">//arduino.cc/en/Reference/StyleGuide&#39; rel=&#39;nofollow&#39;&gt;http://arduino.cc/en/Reference/StyleGuide&lt;/a&gt;</span></div>
<div class="line"><a name="l03295"></a><span class="lineno"> 3295</span>&#160;&lt;/p&gt;</div>
<div class="line"><a name="l03296"></a><span class="lineno"> 3296</span>&#160;&lt;p&gt;&lt;strong&gt;Use the established core libraries and styles.&lt;/strong&gt;</div>
<div class="line"><a name="l03297"></a><span class="lineno"> 3297</span>&#160;&lt;/p&gt;&lt;ul&gt;* Use read() to read inputs, and write() to write to outputs, e.g. digitalRead(), analogWrite(), etc.</div>
<div class="line"><a name="l03298"></a><span class="lineno"> 3298</span>&#160;* Use the Stream.h and Print.h libraries when dealing with byte streams. If it s not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 s not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
  not appropriate, at least try to use its API as a model. For more on this, see below
* For network applications, use the Client and Server libraries as the basis.
* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dont assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
s not appropriate, at least try to use its API as a model. For more on this, see below</div>
<div class="line"><a name="l03299"></a><span class="lineno"> 3299</span>&#160;* For network applications, use the Client and Server libraries as the basis.</div>
<div class="line"><a name="l03300"></a><span class="lineno"> 3300</span>&#160;* Use begin() to initialize a library instance, usually with some settings. Use end() to stop it.</div>
<div class="line"><a name="l03301"></a><span class="lineno"> 3301</span>&#160;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Use camel case function names, not underscore.&lt;/strong&gt; For example, analogRead, not analog_read. Or myNewFunction, not my_new_function.  We&#39;ve adopted this from Processing.org for readability&#39;s sake.</div>
<div class="line"><a name="l03302"></a><span class="lineno"> 3302</span>&#160;&lt;/p&gt;</div>
<div class="line"><a name="l03303"></a><span class="lineno"> 3303</span>&#160;&lt;p&gt;&lt;strong&gt;LONG_CONSTANT_NAMES_FULL_OF_CAPS are hard to read.&lt;/strong&gt; Try to simplify when possible, without being terse.</div>
<div class="line"><a name="l03304"></a><span class="lineno"> 3304</span>&#160;&lt;/p&gt;</div>
<div class="line"><a name="l03305"></a><span class="lineno"> 3305</span>&#160;&lt;p&gt;&lt;strong&gt;Try to avoid boolean arguments.&lt;/strong&gt;  Instead, consider providing two different functions with names the describe the differences between them.</div>
<div class="line"><a name="l03306"></a><span class="lineno"> 3306</span>&#160;&lt;/p&gt;</div>
<div class="line"><a name="l03307"></a><span class="lineno"> 3307</span>&#160;&lt;p&gt;&lt;strong&gt;Don t assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 t assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
  assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.
&lt;/p&gt;
&lt;pre&gt;   void printArray( char* array);
&lt;/pre&gt;
&lt;p&gt;can be replaced by
&lt;/p&gt;
&lt;pre&gt;    void printArray(char[] array);
&lt;/pre&gt;
&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:
&lt;/p&gt;
&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);
&lt;/pre&gt;
&lt;p&gt;use something like this:
&lt;/p&gt;
&lt;pre&gt;   xAxis = adxl.readX();
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
t assume knowledge of pointers.&lt;/strong&gt;  Beginning users of C find this the biggest roadblock, and get very confused by &amp; and *, so whenever you can avoid having them hanging out in the API, do so. One way is to pass by reference using array notation  rather than * notation, for example.</div>
<div class="line"><a name="l03308"></a><span class="lineno"> 3308</span>&#160;&lt;/p&gt;</div>
<div class="line"><a name="l03309"></a><span class="lineno"> 3309</span>&#160;&lt;pre&gt;   void printArray( char* array);</div>
<div class="line"><a name="l03310"></a><span class="lineno"> 3310</span>&#160;&lt;/pre&gt;</div>
<div class="line"><a name="l03311"></a><span class="lineno"> 3311</span>&#160;&lt;p&gt;can be replaced by</div>
<div class="line"><a name="l03312"></a><span class="lineno"> 3312</span>&#160;&lt;/p&gt;</div>
<div class="line"><a name="l03313"></a><span class="lineno"> 3313</span>&#160;&lt;pre&gt;    void printArray(char[] array);</div>
<div class="line"><a name="l03314"></a><span class="lineno"> 3314</span>&#160;&lt;/pre&gt;</div>
<div class="line"><a name="l03315"></a><span class="lineno"> 3315</span>&#160;&lt;p&gt;Though there are some libraries where we pass pointers by using structures like const chars, avoid anything that requires the user to pass them. For example,rather than:</div>
<div class="line"><a name="l03316"></a><span class="lineno"> 3316</span>&#160;&lt;/p&gt;</div>
<div class="line"><a name="l03317"></a><span class="lineno"> 3317</span>&#160;&lt;pre&gt;  foo.readAccel(&amp;x, &amp;y, &amp;z);</div>
<div class="line"><a name="l03318"></a><span class="lineno"> 3318</span>&#160;&lt;/pre&gt;</div>
<div class="line"><a name="l03319"></a><span class="lineno"> 3319</span>&#160;&lt;p&gt;use something like this:</div>
<div class="line"><a name="l03320"></a><span class="lineno"> 3320</span>&#160;&lt;/p&gt;</div>
<div class="line"><a name="l03321"></a><span class="lineno"> 3321</span>&#160;&lt;pre&gt;   xAxis = adxl.readX(); 
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 
   yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
    yAxis = adxl.readY();
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
</div>
<div class="line"><a name="l03322"></a><span class="lineno"> 3322</span>&#160;   yAxis = adxl.readY(); 
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
 
   zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
    zAxis = adxl.readZ();
&lt;/pre&gt;
&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http://www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.
&lt;/p&gt;
&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.
&lt;/p&gt;
&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:
&lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;
&lt;a class=&#39;wikilink&#39; href=&#39;//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

--&gt;
</div>
<div class="line"><a name="l03323"></a><span class="lineno"> 3323</span>&#160;   zAxis = adxl.readZ();</div>
<div class="line"><a name="l03324"></a><span class="lineno"> 3324</span>&#160;&lt;/pre&gt;</div>
<div class="line"><a name="l03325"></a><span class="lineno"> 3325</span>&#160;&lt;p&gt;When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;.  This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like &lt;span class=&#39;wikiword&#39;&gt;SoftwareSerial&lt;/span&gt;.  The Stream object can be passed to your library&#39;s constructor or to a begin() function (as a reference, not a pointer).  See &lt;a class=&#39;urllink&#39; href=&#39;http:<span class="comment">//www.firmata.org/wiki/Main_Page&#39; rel=&#39;nofollow&#39;&gt;Firmata 2.3&lt;/a&gt; or &lt;a class=&#39;urllink&#39; href=&#39;https://code.google.com/p/xbee-arduino/&#39; rel=&#39;nofollow&#39;&gt;XBee 0.4&lt;/a&gt; for examples of each approach.</span></div>
<div class="line"><a name="l03326"></a><span class="lineno"> 3326</span>&#160;&lt;/p&gt;</div>
<div class="line"><a name="l03327"></a><span class="lineno"> 3327</span>&#160;&lt;p&gt;When writing a library that provides byte-stream communication, inherit Arduino&#39;s Stream class, so your library can be used with all other libraries that accept Stream objects.  If possible, buffer incoming data, so that read() immediately accesses data the buffer but does not wait for more data to arrive. If possible, your write() method should store data to a transmit buffer, but write() must wait if the buffer does not have enough space to immediately store all outgoing data.  The yield() function should be called while waiting.</div>
<div class="line"><a name="l03328"></a><span class="lineno"> 3328</span>&#160;&lt;/p&gt;</div>
<div class="line"><a name="l03329"></a><span class="lineno"> 3329</span>&#160;&lt;p&gt;Here are a few libraries  that are exemplary from Adafruit. She breaks the functions of the devices down into their high-level activities really well. &lt;a class=&#39;urllink&#39; href=&#39;https:<span class="comment">//github.com/adafruit/Adafruit-BMP085-Library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/Adafruit-BMP085-Library&lt;/a&gt; &lt;a class=&#39;urllink&#39; href=&#39;https://github.com/adafruit/DHT-sensor-library&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/DHT-sensor-library &lt;/a&gt;</span></div>
<div class="line"><a name="l03330"></a><span class="lineno"> 3330</span>&#160;&lt;/p&gt;</div>
<div class="line"><a name="l03331"></a><span class="lineno"> 3331</span>&#160;&lt;p&gt;This does a nice job of abstracting from the Wire (&lt;span class=&#39;wikiword&#39;&gt;I2C&lt;/span&gt;) library:</div>
<div class="line"><a name="l03332"></a><span class="lineno"> 3332</span>&#160;&lt;a class=&#39;urllink&#39; href=&#39;https:<span class="comment">//github.com/adafruit/RTClib&#39; rel=&#39;nofollow&#39;&gt;https://github.com/adafruit/RTClib&lt;/a&gt;</span></div>
<div class="line"><a name="l03333"></a><span class="lineno"> 3333</span>&#160;&lt;a class=&#39;wikilink&#39; href=&#39;<span class="comment">//www.arduino.cc/en/Reference/HomePage&#39;&gt;Reference Home&lt;/a&gt;</span></div>
<div class="line"><a name="l03334"></a><span class="lineno"> 3334</span>&#160;&lt;/p&gt;</div>
<div class="line"><a name="l03335"></a><span class="lineno"> 3335</span>&#160;&lt;/body&gt;</div>
<div class="line"><a name="l03336"></a><span class="lineno"> 3336</span>&#160;&lt;/html&gt;</div>
<div class="line"><a name="l03337"></a><span class="lineno"> 3337</span>&#160;</div>
<div class="line"><a name="l03338"></a><span class="lineno"> 3338</span>&#160;--&gt;</div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
